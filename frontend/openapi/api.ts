/* tslint:disable */
/* eslint-disable */
/**
 * Yukichi
 * The Yukichi API
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApplicableRoomTypeResponseDto
 */
export interface ApplicableRoomTypeResponseDto {
    /**
     * 
     * @type {string}
     * @memberof ApplicableRoomTypeResponseDto
     */
    'applicable_room_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicableRoomTypeResponseDto
     */
    'base_applicable_room_type_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicableRoomTypeResponseDto
     */
    'delete_flag': boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicableRoomTypeResponseDto
     */
    'hotel_code': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicableRoomTypeResponseDto
     */
    'stock_control_room_type_code': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicableRoomTypeResponseDto
     */
    'travel_plan_code': string;
    /**
     * 
     * @type {string}
     * @memberof ApplicableRoomTypeResponseDto
     */
    'travel_plan_id': string;
}
/**
 * 
 * @export
 * @interface AuthenticateRequestDto
 */
export interface AuthenticateRequestDto {
    /**
     * ユーザー名
     * @type {string}
     * @memberof AuthenticateRequestDto
     */
    'name': string;
    /**
     * パスワード
     * @type {string}
     * @memberof AuthenticateRequestDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthorizeResponseDto
 */
export interface AuthorizeResponseDto {
    /**
     * 
     * @type {AuthorizeResponseDtoIdToken}
     * @memberof AuthorizeResponseDto
     */
    'idToken': AuthorizeResponseDtoIdToken;
    /**
     * 
     * @type {AuthorizeResponseDtoAccessToken}
     * @memberof AuthorizeResponseDto
     */
    'accessToken': AuthorizeResponseDtoAccessToken;
    /**
     * 
     * @type {AuthorizeResponseDtoRefreshToken}
     * @memberof AuthorizeResponseDto
     */
    'refreshToken': AuthorizeResponseDtoRefreshToken;
    /**
     * clockDrift
     * @type {number}
     * @memberof AuthorizeResponseDto
     */
    'clockDrift': number;
}
/**
 * AccessToken
 * @export
 * @interface AuthorizeResponseDtoAccessToken
 */
export interface AuthorizeResponseDtoAccessToken {
    /**
     * token
     * @type {string}
     * @memberof AuthorizeResponseDtoAccessToken
     */
    'jwtToken': string;
    /**
     * 
     * @type {IdTokenDtoPayload}
     * @memberof AuthorizeResponseDtoAccessToken
     */
    'payload': IdTokenDtoPayload;
}
/**
 * idToken
 * @export
 * @interface AuthorizeResponseDtoIdToken
 */
export interface AuthorizeResponseDtoIdToken {
    /**
     * token
     * @type {string}
     * @memberof AuthorizeResponseDtoIdToken
     */
    'jwtToken': string;
    /**
     * 
     * @type {IdTokenDtoPayload}
     * @memberof AuthorizeResponseDtoIdToken
     */
    'payload': IdTokenDtoPayload;
}
/**
 * RefreshToken
 * @export
 * @interface AuthorizeResponseDtoRefreshToken
 */
export interface AuthorizeResponseDtoRefreshToken {
    /**
     * token
     * @type {string}
     * @memberof AuthorizeResponseDtoRefreshToken
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface BodyRequesDto
 */
export interface BodyRequesDto {
    /**
     * 
     * @type {string}
     * @memberof BodyRequesDto
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface BookletDetailResponseDto
 */
export interface BookletDetailResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof BookletDetailResponseDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodePublicDto}
     * @memberof BookletDetailResponseDto
     */
    'masterEditionCode'?: MasterEditionCodePublicDto;
    /**
     * ProjectID
     * @type {number}
     * @memberof BookletDetailResponseDto
     */
    'projectId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof BookletDetailResponseDto
     */
    'numberOfPages': number;
    /**
     * 原稿連番
     * @type {number}
     * @memberof BookletDetailResponseDto
     */
    'documentSerialNumber': number;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof BookletDetailResponseDto
     */
    'documents': Array<DocumentResponseDto>;
    /**
     * 版コード
     * @type {string}
     * @memberof BookletDetailResponseDto
     */
    'editionCode': BookletDetailResponseDtoEditionCodeEnum;
    /**
     * 入稿ロック
     * @type {boolean}
     * @memberof BookletDetailResponseDto
     */
    'locked': boolean;
    /**
     * 作成日
     * @type {string}
     * @memberof BookletDetailResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof BookletDetailResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof BookletDetailResponseDto
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<PageForBookletDto>}
     * @memberof BookletDetailResponseDto
     */
    'pages': Array<PageForBookletDto>;
    /**
     * 
     * @type {ProjectResponseDto}
     * @memberof BookletDetailResponseDto
     */
    'project': ProjectResponseDto;
}

export const BookletDetailResponseDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type BookletDetailResponseDtoEditionCodeEnum = typeof BookletDetailResponseDtoEditionCodeEnum[keyof typeof BookletDetailResponseDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface BookletForProjectListDto
 */
export interface BookletForProjectListDto {
    /**
     * ID
     * @type {number}
     * @memberof BookletForProjectListDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodePublicDto}
     * @memberof BookletForProjectListDto
     */
    'masterEditionCode'?: MasterEditionCodePublicDto;
    /**
     * ProjectID
     * @type {number}
     * @memberof BookletForProjectListDto
     */
    'projectId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof BookletForProjectListDto
     */
    'numberOfPages': number;
    /**
     * 原稿連番
     * @type {number}
     * @memberof BookletForProjectListDto
     */
    'documentSerialNumber': number;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof BookletForProjectListDto
     */
    'documents': Array<DocumentResponseDto>;
    /**
     * 
     * @type {ProjectListInBookletInProjectDto}
     * @memberof BookletForProjectListDto
     */
    'project'?: ProjectListInBookletInProjectDto;
}
/**
 * 
 * @export
 * @interface BookletForProjectResponseDto
 */
export interface BookletForProjectResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof BookletForProjectResponseDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodePublicDto}
     * @memberof BookletForProjectResponseDto
     */
    'masterEditionCode'?: MasterEditionCodePublicDto;
    /**
     * ProjectID
     * @type {number}
     * @memberof BookletForProjectResponseDto
     */
    'projectId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof BookletForProjectResponseDto
     */
    'numberOfPages': number;
    /**
     * 原稿連番
     * @type {number}
     * @memberof BookletForProjectResponseDto
     */
    'documentSerialNumber': number;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof BookletForProjectResponseDto
     */
    'documents': Array<DocumentResponseDto>;
    /**
     * 版コード
     * @type {string}
     * @memberof BookletForProjectResponseDto
     */
    'editionCode': BookletForProjectResponseDtoEditionCodeEnum;
    /**
     * 入稿ロック
     * @type {boolean}
     * @memberof BookletForProjectResponseDto
     */
    'locked': boolean;
    /**
     * 作成日
     * @type {string}
     * @memberof BookletForProjectResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof BookletForProjectResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof BookletForProjectResponseDto
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<PageResponseDto>}
     * @memberof BookletForProjectResponseDto
     */
    'pages': Array<PageResponseDto>;
}

export const BookletForProjectResponseDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type BookletForProjectResponseDtoEditionCodeEnum = typeof BookletForProjectResponseDtoEditionCodeEnum[keyof typeof BookletForProjectResponseDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface BookletInMyStockDto
 */
export interface BookletInMyStockDto {
    /**
     * id
     * @type {number}
     * @memberof BookletInMyStockDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodeDto}
     * @memberof BookletInMyStockDto
     */
    'masterEditionCode': MasterEditionCodeDto;
}
/**
 * 
 * @export
 * @interface BookletProgressAggregationDto
 */
export interface BookletProgressAggregationDto {
    /**
     * ID
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodePublicDto}
     * @memberof BookletProgressAggregationDto
     */
    'masterEditionCode'?: MasterEditionCodePublicDto;
    /**
     * ProjectID
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'projectId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'numberOfPages': number;
    /**
     * 原稿連番
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'documentSerialNumber': number;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof BookletProgressAggregationDto
     */
    'documents': Array<DocumentResponseDto>;
    /**
     * 未着手ステータスカウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'notStart': number;
    /**
     * 作成中ステータスカウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'makingCount': number;
    /**
     * チェックステータスカウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'checkingCount': number;
    /**
     * 差し戻しステータスカウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'sendBackCount': number;
    /**
     * 校了ステータスカウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'proofreadingCount': number;
    /**
     * 下書き原稿カウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'myStockCount': number;
    /**
     * マッチングOKカウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'matchedCount': number;
    /**
     * 不要原稿カウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'unusedCount': number;
    /**
     * エントリ数カウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'entryCount': number;
    /**
     * 校了完了未校了フラグ false=未校了 true=ボタンをそれぞれ表示(入稿ロックボタンなど)
     * @type {boolean}
     * @memberof BookletProgressAggregationDto
     */
    'isEndProofreading': boolean;
    /**
     * 入稿ロックフラグ
     * @type {boolean}
     * @memberof BookletProgressAggregationDto
     */
    'locked': boolean;
    /**
     * ロックドキュメント数 カウント
     * @type {number}
     * @memberof BookletProgressAggregationDto
     */
    'lockedCount': number;
    /**
     * 
     * @type {Array<DocumentSearchDto>}
     * @memberof BookletProgressAggregationDto
     */
    'matchedDocuments': Array<DocumentSearchDto>;
    /**
     * 
     * @type {Array<DocumentSearchDto>}
     * @memberof BookletProgressAggregationDto
     */
    'unusedDocuments': Array<DocumentSearchDto>;
    /**
     * 
     * @type {Array<DocumentSearchDto>}
     * @memberof BookletProgressAggregationDto
     */
    'myStockDocuments': Array<DocumentSearchDto>;
}
/**
 * 
 * @export
 * @interface BookletPublicDto
 */
export interface BookletPublicDto {
    /**
     * ID
     * @type {number}
     * @memberof BookletPublicDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodePublicDto}
     * @memberof BookletPublicDto
     */
    'masterEditionCode'?: MasterEditionCodePublicDto;
    /**
     * ProjectID
     * @type {number}
     * @memberof BookletPublicDto
     */
    'projectId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof BookletPublicDto
     */
    'numberOfPages': number;
    /**
     * 原稿連番
     * @type {number}
     * @memberof BookletPublicDto
     */
    'documentSerialNumber': number;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof BookletPublicDto
     */
    'documents': Array<DocumentResponseDto>;
}
/**
 * 
 * @export
 * @interface BookletResponseDto
 */
export interface BookletResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof BookletResponseDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodePublicDto}
     * @memberof BookletResponseDto
     */
    'masterEditionCode'?: MasterEditionCodePublicDto;
    /**
     * ProjectID
     * @type {number}
     * @memberof BookletResponseDto
     */
    'projectId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof BookletResponseDto
     */
    'numberOfPages': number;
    /**
     * 原稿連番
     * @type {number}
     * @memberof BookletResponseDto
     */
    'documentSerialNumber': number;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof BookletResponseDto
     */
    'documents': Array<DocumentResponseDto>;
    /**
     * 版コード
     * @type {string}
     * @memberof BookletResponseDto
     */
    'editionCode': BookletResponseDtoEditionCodeEnum;
    /**
     * 入稿ロック
     * @type {boolean}
     * @memberof BookletResponseDto
     */
    'locked': boolean;
    /**
     * 作成日
     * @type {string}
     * @memberof BookletResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof BookletResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof BookletResponseDto
     */
    'deletedAt'?: string;
}

export const BookletResponseDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type BookletResponseDtoEditionCodeEnum = typeof BookletResponseDtoEditionCodeEnum[keyof typeof BookletResponseDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface BookletSearchResponseDto
 */
export interface BookletSearchResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof BookletSearchResponseDto
     */
    'id': number;
    /**
     * 
     * @type {MasterEditionCodePublicDto}
     * @memberof BookletSearchResponseDto
     */
    'masterEditionCode'?: MasterEditionCodePublicDto;
    /**
     * ProjectID
     * @type {number}
     * @memberof BookletSearchResponseDto
     */
    'projectId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof BookletSearchResponseDto
     */
    'numberOfPages': number;
    /**
     * 原稿連番
     * @type {number}
     * @memberof BookletSearchResponseDto
     */
    'documentSerialNumber': number;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof BookletSearchResponseDto
     */
    'documents': Array<DocumentResponseDto>;
    /**
     * 版コード
     * @type {string}
     * @memberof BookletSearchResponseDto
     */
    'editionCode': BookletSearchResponseDtoEditionCodeEnum;
    /**
     * 入稿ロック
     * @type {boolean}
     * @memberof BookletSearchResponseDto
     */
    'locked': boolean;
    /**
     * 作成日
     * @type {string}
     * @memberof BookletSearchResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof BookletSearchResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof BookletSearchResponseDto
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {ProjectListInBookletInProjectDto}
     * @memberof BookletSearchResponseDto
     */
    'project': ProjectListInBookletInProjectDto;
}

export const BookletSearchResponseDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type BookletSearchResponseDtoEditionCodeEnum = typeof BookletSearchResponseDtoEditionCodeEnum[keyof typeof BookletSearchResponseDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface BookletSearchWithCountDto
 */
export interface BookletSearchWithCountDto {
    /**
     * 
     * @type {Array<BookletSearchResponseDto>}
     * @memberof BookletSearchWithCountDto
     */
    'data': Array<BookletSearchResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof BookletSearchWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ConvertResponseDto
 */
export interface ConvertResponseDto {
    /**
     * EPS画像(base64)
     * @type {string}
     * @memberof ConvertResponseDto
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface CopyBookletDto
 */
export interface CopyBookletDto {
    /**
     * id
     * @type {number}
     * @memberof CopyBookletDto
     */
    'id': number;
    /**
     * ProjectID
     * @type {number}
     * @memberof CopyBookletDto
     */
    'projectId': number;
}
/**
 * 
 * @export
 * @interface CopyPageDto
 */
export interface CopyPageDto {
    /**
     * pageId to edit
     * @type {number}
     * @memberof CopyPageDto
     */
    'pageId'?: number;
    /**
     * projectID
     * @type {number}
     * @memberof CopyPageDto
     */
    'projectId': number;
    /**
     * BookletID
     * @type {number}
     * @memberof CopyPageDto
     */
    'bookletId': number;
    /**
     * ページ番号
     * @type {number}
     * @memberof CopyPageDto
     */
    'pageNumber': number;
    /**
     * ページ種別
     * @type {string}
     * @memberof CopyPageDto
     */
    'pageTypeCode': CopyPageDtoPageTypeCodeEnum;
    /**
     * PageId
     * @type {number}
     * @memberof CopyPageDto
     */
    'id': number;
}

export const CopyPageDtoPageTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    ChapterTitlePage: 'CHAPTER_TITLE_PAGE',
    Advertisement: 'ADVERTISEMENT',
    Information: 'INFORMATION'
} as const;

export type CopyPageDtoPageTypeCodeEnum = typeof CopyPageDtoPageTypeCodeEnum[keyof typeof CopyPageDtoPageTypeCodeEnum];

/**
 * 
 * @export
 * @interface CreateBookletDto
 */
export interface CreateBookletDto {
    /**
     * 版コード
     * @type {string}
     * @memberof CreateBookletDto
     */
    'editionCode': CreateBookletDtoEditionCodeEnum;
    /**
     * ProjectID
     * @type {number}
     * @memberof CreateBookletDto
     */
    'projectId': number;
    /**
     * ページ数
     * @type {number}
     * @memberof CreateBookletDto
     */
    'numberOfPages': number;
}

export const CreateBookletDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type CreateBookletDtoEditionCodeEnum = typeof CreateBookletDtoEditionCodeEnum[keyof typeof CreateBookletDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface CreateDocumentDto
 */
export interface CreateDocumentDto {
    /**
     * documentCode
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'documentCode'?: string;
    /**
     * projectId
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'projectId': number;
    /**
     * bookletId
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'bookletId': number;
    /**
     * pageId
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'pageId'?: number;
    /**
     * 原稿種別コード
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'documentTypeCode': CreateDocumentDtoDocumentTypeCodeEnum;
    /**
     * 原稿サイズコード
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'documentSizeCode': CreateDocumentDtoDocumentSizeCodeEnum;
    /**
     * ページ番号
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'pageNumber'?: number;
    /**
     * 使用テンプレートid
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'templateId'?: number;
    /**
     * 埋草id
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'fillerId'?: number;
    /**
     * 見出しid
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'headLineId'?: number;
    /**
     * 営業担当者コード
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'salesPersonCognito': string;
    /**
     * エントリーから登録
     * @type {boolean}
     * @memberof CreateDocumentDto
     */
    'fromEntry'?: boolean;
    /**
     * ステータスコード
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'statusCode'?: CreateDocumentDtoStatusCodeEnum;
    /**
     * 表示順
     * @type {number}
     * @memberof CreateDocumentDto
     */
    'order'?: number;
    /**
     * 宿泊コード
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'hotelCode'?: string;
    /**
     * 原稿担当者コード
     * @type {string}
     * @memberof CreateDocumentDto
     */
    'manuscriptPersonCognito': string;
}

export const CreateDocumentDtoDocumentTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    HeadLine: 'HEAD_LINE',
    Filler: 'FILLER'
} as const;

export type CreateDocumentDtoDocumentTypeCodeEnum = typeof CreateDocumentDtoDocumentTypeCodeEnum[keyof typeof CreateDocumentDtoDocumentTypeCodeEnum];
export const CreateDocumentDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type CreateDocumentDtoDocumentSizeCodeEnum = typeof CreateDocumentDtoDocumentSizeCodeEnum[keyof typeof CreateDocumentDtoDocumentSizeCodeEnum];
export const CreateDocumentDtoStatusCodeEnum = {
    Making: 'MAKING',
    NotStart: 'NOT_START',
    Checking: 'CHECKING',
    SendBack: 'SEND_BACK',
    Proofreading: 'PROOFREADING'
} as const;

export type CreateDocumentDtoStatusCodeEnum = typeof CreateDocumentDtoStatusCodeEnum[keyof typeof CreateDocumentDtoStatusCodeEnum];

/**
 * 
 * @export
 * @interface CreateDocumentPartsContentDto
 */
export interface CreateDocumentPartsContentDto {
    /**
     * Document id
     * @type {number}
     * @memberof CreateDocumentPartsContentDto
     */
    'id': number;
    /**
     * Document Parts id
     * @type {number}
     * @memberof CreateDocumentPartsContentDto
     */
    'documentPartsId': number;
    /**
     * テンプレートによって分けられた区画の何番目かを表すインデックス
     * @type {number}
     * @memberof CreateDocumentPartsContentDto
     */
    'templateIndex': number;
    /**
     * パターンによって分けられた区画の何番目かを表すインデックス
     * @type {number}
     * @memberof CreateDocumentPartsContentDto
     */
    'patternIndex': number;
}
/**
 * 
 * @export
 * @interface CreateIdmlDocumentShare
 */
export interface CreateIdmlDocumentShare {
    /**
     * File Base
     * @type {string}
     * @memberof CreateIdmlDocumentShare
     */
    'filebase64': string;
    /**
     * filepath
     * @type {string}
     * @memberof CreateIdmlDocumentShare
     */
    'filepath': string;
}
/**
 * 
 * @export
 * @interface CreatePageDto
 */
export interface CreatePageDto {
    /**
     * pageId to edit
     * @type {number}
     * @memberof CreatePageDto
     */
    'pageId'?: number;
    /**
     * projectID
     * @type {number}
     * @memberof CreatePageDto
     */
    'projectId': number;
    /**
     * BookletID
     * @type {number}
     * @memberof CreatePageDto
     */
    'bookletId': number;
    /**
     * ページレイアウトのアルファベット
     * @type {string}
     * @memberof CreatePageDto
     */
    'layoutAlphabet': string;
    /**
     * ページ番号
     * @type {number}
     * @memberof CreatePageDto
     */
    'pageNumber': number;
    /**
     * 欄外下画像ID
     * @type {number}
     * @memberof CreatePageDto
     */
    'mountId': number;
    /**
     * つめ見出し画像id
     * @type {string}
     * @memberof CreatePageDto
     */
    'thumbIndexImageGroupId'?: string;
    /**
     * ページ種別
     * @type {string}
     * @memberof CreatePageDto
     */
    'pageTypeCode': CreatePageDtoPageTypeCodeEnum;
}

export const CreatePageDtoPageTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    ChapterTitlePage: 'CHAPTER_TITLE_PAGE',
    Advertisement: 'ADVERTISEMENT',
    Information: 'INFORMATION'
} as const;

export type CreatePageDtoPageTypeCodeEnum = typeof CreatePageDtoPageTypeCodeEnum[keyof typeof CreatePageDtoPageTypeCodeEnum];

/**
 * 
 * @export
 * @interface CreateProjectWithEditionCodeDto
 */
export interface CreateProjectWithEditionCodeDto {
    /**
     * 
     * @type {string}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'mediaTypeCode': CreateProjectWithEditionCodeDtoMediaTypeCodeEnum;
    /**
     * 月号-年
     * @type {number}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'issueYear': number;
    /**
     * 月号-月
     * @type {number}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'issueMonth': number;
    /**
     * 販売開始日
     * @type {string}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'salesEndDate': string;
    /**
     * 口コミ評価開始日
     * @type {string}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'reviewRatingStartDate': string;
    /**
     * 口コミ評価終了日
     * @type {string}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'reviewRatingEndDate': string;
    /**
     * 
     * @type {string}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'consumptionTax'?: CreateProjectWithEditionCodeDtoConsumptionTaxEnum;
    /**
     * 
     * @type {number}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'tax'?: number;
    /**
     * editionCodeの配列
     * @type {Array<string>}
     * @memberof CreateProjectWithEditionCodeDto
     */
    'editionCodes'?: Array<CreateProjectWithEditionCodeDtoEditionCodesEnum>;
}

export const CreateProjectWithEditionCodeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type CreateProjectWithEditionCodeDtoMediaTypeCodeEnum = typeof CreateProjectWithEditionCodeDtoMediaTypeCodeEnum[keyof typeof CreateProjectWithEditionCodeDtoMediaTypeCodeEnum];
export const CreateProjectWithEditionCodeDtoConsumptionTaxEnum = {
    Excluded: 'TAX_EXCLUDED',
    Included: 'TAX_INCLUDED'
} as const;

export type CreateProjectWithEditionCodeDtoConsumptionTaxEnum = typeof CreateProjectWithEditionCodeDtoConsumptionTaxEnum[keyof typeof CreateProjectWithEditionCodeDtoConsumptionTaxEnum];
export const CreateProjectWithEditionCodeDtoEditionCodesEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type CreateProjectWithEditionCodeDtoEditionCodesEnum = typeof CreateProjectWithEditionCodeDtoEditionCodesEnum[keyof typeof CreateProjectWithEditionCodeDtoEditionCodesEnum];

/**
 * 
 * @export
 * @interface CreateWorkspaceAppealLayoutRequestDto
 */
export interface CreateWorkspaceAppealLayoutRequestDto {
    /**
     * 編集ID
     * @type {string}
     * @memberof CreateWorkspaceAppealLayoutRequestDto
     */
    'editId': string;
    /**
     * 訴求エリアレイアウト種別
     * @type {string}
     * @memberof CreateWorkspaceAppealLayoutRequestDto
     */
    'appealType': string;
}
/**
 * 
 * @export
 * @interface CreateWorkspaceFeetableHeaderRequestDto
 */
export interface CreateWorkspaceFeetableHeaderRequestDto {
    /**
     * 編集ID
     * @type {string}
     * @memberof CreateWorkspaceFeetableHeaderRequestDto
     */
    'editId': string;
    /**
     * upsert
     * @type {boolean}
     * @memberof CreateWorkspaceFeetableHeaderRequestDto
     */
    'upsert'?: boolean;
}
/**
 * 
 * @export
 * @interface CreateWorkspacePartsLayoutRequestDto
 */
export interface CreateWorkspacePartsLayoutRequestDto {
    /**
     * 編集ID
     * @type {string}
     * @memberof CreateWorkspacePartsLayoutRequestDto
     */
    'editId': string;
    /**
     * パッケージID
     * @type {string}
     * @memberof CreateWorkspacePartsLayoutRequestDto
     */
    'packageId': string;
    /**
     * タグID
     * @type {string}
     * @memberof CreateWorkspacePartsLayoutRequestDto
     */
    'tagId': string;
    /**
     * パーツ表示レイアウトパターン種別
     * @type {string}
     * @memberof CreateWorkspacePartsLayoutRequestDto
     */
    'patternType': string;
}
/**
 * 
 * @export
 * @interface CreateWorkspacePartsRequestDto
 */
export interface CreateWorkspacePartsRequestDto {
    /**
     * 編集ID
     * @type {string}
     * @memberof CreateWorkspacePartsRequestDto
     */
    'editId': string;
    /**
     * パッケージID
     * @type {string}
     * @memberof CreateWorkspacePartsRequestDto
     */
    'packageId': string;
    /**
     * タグID
     * @type {string}
     * @memberof CreateWorkspacePartsRequestDto
     */
    'tagId': string;
    /**
     * パーツID
     * @type {number}
     * @memberof CreateWorkspacePartsRequestDto
     */
    'partsId': number;
}
/**
 * 
 * @export
 * @interface DeleteDocumentMyStockDto
 */
export interface DeleteDocumentMyStockDto {
    /**
     * documentId
     * @type {number}
     * @memberof DeleteDocumentMyStockDto
     */
    'documentId': number;
    /**
     * 
     * @type {string}
     * @memberof DeleteDocumentMyStockDto
     */
    'createPersonCognito': string;
}
/**
 * 
 * @export
 * @interface DeleteDocumentPartsContentDto
 */
export interface DeleteDocumentPartsContentDto {
    /**
     * Parts Content id
     * @type {number}
     * @memberof DeleteDocumentPartsContentDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface DocumentAliasSearchDto
 */
export interface DocumentAliasSearchDto {
    /**
     * 
     * @type {number}
     * @memberof DocumentAliasSearchDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DocumentAliasSearchDto
     */
    'documentId': number;
    /**
     * 
     * @type {DocumentResponseDto}
     * @memberof DocumentAliasSearchDto
     */
    'document': DocumentResponseDto;
    /**
     * 
     * @type {BookletPublicDto}
     * @memberof DocumentAliasSearchDto
     */
    'booklet': BookletPublicDto;
}
/**
 * 
 * @export
 * @interface DocumentBoastStampMediaTypeDto
 */
export interface DocumentBoastStampMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof DocumentBoastStampMediaTypeDto
     */
    'mediaTypeCode': DocumentBoastStampMediaTypeDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof DocumentBoastStampMediaTypeDto
     */
    'masterMediaType': Array<MasterMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentBoastStampMediaTypeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentBoastStampMediaTypeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentBoastStampMediaTypeDto
     */
    'deletedAt'?: string;
    /**
     * 自慢スタンプid
     * @type {number}
     * @memberof DocumentBoastStampMediaTypeDto
     */
    'documentBoastStampId': number;
}

export const DocumentBoastStampMediaTypeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type DocumentBoastStampMediaTypeDtoMediaTypeCodeEnum = typeof DocumentBoastStampMediaTypeDtoMediaTypeCodeEnum[keyof typeof DocumentBoastStampMediaTypeDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentBoastStampResponseDto
 */
export interface DocumentBoastStampResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof DocumentBoastStampResponseDto
     */
    'id': number;
    /**
     * 自慢スタンプコード
     * @type {number}
     * @memberof DocumentBoastStampResponseDto
     */
    'code': number;
    /**
     * 自慢スタンプ属性
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'attributeCode': string;
    /**
     * 
     * @type {MasterBoastStampAttributeResponseDto}
     * @memberof DocumentBoastStampResponseDto
     */
    'attribute': MasterBoastStampAttributeResponseDto;
    /**
     * 自慢スタンプ名称
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'name': string;
    /**
     * 自慢スタンプ備考
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'comment'?: string;
    /**
     * 自慢スタンプ画像
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'image'?: string;
    /**
     * 自慢スタンプ変換画像
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'imageConvert'?: string;
    /**
     * 媒体タイプの配列
     * @type {Array<DocumentBoastStampMediaTypeDto>}
     * @memberof DocumentBoastStampResponseDto
     */
    'mediaTypes'?: Array<DocumentBoastStampMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentBoastStampResponseDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface DocumentBoastStampWithCountDto
 */
export interface DocumentBoastStampWithCountDto {
    /**
     * 
     * @type {Array<DocumentBoastStampResponseDto>}
     * @memberof DocumentBoastStampWithCountDto
     */
    'data': Array<DocumentBoastStampResponseDto>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof DocumentBoastStampWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentContentResponseDto
 */
export interface DocumentContentResponseDto {
    /**
     * document content id
     * @type {number}
     * @memberof DocumentContentResponseDto
     */
    'id': number;
    /**
     * document id
     * @type {number}
     * @memberof DocumentContentResponseDto
     */
    'documentId': number;
    /**
     * パターン1段目
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'row1Pattern'?: DocumentContentResponseDtoRow1PatternEnum;
    /**
     * パターン2段目
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'row2Pattern'?: DocumentContentResponseDtoRow2PatternEnum;
    /**
     * パターン3段目
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'row3Pattern'?: DocumentContentResponseDtoRow3PatternEnum;
    /**
     * パターン4段目
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'row4Pattern'?: DocumentContentResponseDtoRow4PatternEnum;
    /**
     * パターン料金表上
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'priceTableTopPattern'?: DocumentContentResponseDtoPriceTableTopPatternEnum;
    /**
     * 風呂評価対象外
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'bathExclusiveFlag'?: boolean;
    /**
     * ふりがな小
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'furiganaSmall'?: string;
    /**
     * ふりがな大
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'furiganaLarge'?: string;
    /**
     * 宿名小
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'hotelNameSmall'?: string;
    /**
     * 宿名大
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'hotelNameLarge'?: string;
    /**
     * 都道府県
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'prefectureName'?: string;
    /**
     * 温泉地名
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'spaName'?: string;
    /**
     * 宿のキャッチテキスト
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'hotelCatchCopy'?: string;
    /**
     * 宿外観写真
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'exteriorPhoto'?: string;
    /**
     * アクセス情報テキスト
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'accessInfoText'?: string;
    /**
     * 客室数
     * @type {number}
     * @memberof DocumentContentResponseDto
     */
    'numberOfGuestRooms'?: number;
    /**
     * 朝食場所
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'breakfastPlace'?: DocumentContentResponseDtoBreakfastPlaceEnum;
    /**
     * 夕食場所
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'dinnerPlace'?: DocumentContentResponseDtoDinnerPlaceEnum;
    /**
     * 販売開始日
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'salesEndDate': string;
    /**
     * メインプランコード
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'mainPlanCode'?: string;
    /**
     * 旅行プランコード
     * @type {Array<string>}
     * @memberof DocumentContentResponseDto
     */
    'travelPlanCode'?: Array<string>;
    /**
     * 料金表ID
     * @type {number}
     * @memberof DocumentContentResponseDto
     */
    'priceTableId'?: number;
    /**
     * 旅行プラン名上書きテキスト
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'travelPlanNameOverwriteText'?: string;
    /**
     * 旅行プラン名を上書きするか？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'travelPlanNameOverwriteVisibility'?: boolean;
    /**
     * 入湯税・子供
     * @type {number}
     * @memberof DocumentContentResponseDto
     */
    'bathTaxChildren'?: number;
    /**
     * 入湯税・幼児
     * @type {number}
     * @memberof DocumentContentResponseDto
     */
    'bathTaxToddler'?: number;
    /**
     * 入湯税・大人
     * @type {number}
     * @memberof DocumentContentResponseDto
     */
    'bathTax'?: number;
    /**
     * 入湯税を表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'bathTaxVisibility'?: boolean;
    /**
     * 入湯税を改行？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'bathTaxBreakLine'?: boolean;
    /**
     * 子供料金を表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'childrenFareVisibility'?: boolean;
    /**
     * 子供料金を改行？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'childrenFareBreakLine'?: boolean;
    /**
     * クレジット支払可能フラグ
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'isPayCredit'?: boolean;
    /**
     * 支払方法を表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'payMethodVisibility'?: boolean;
    /**
     * 支払方法を改行？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'payMethodBreakLine'?: boolean;
    /**
     * 当日予約上書きテキスト
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'sameDayReservationText'?: string;
    /**
     * 当日予約を表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'sameDayReservationVisibility'?: boolean;
    /**
     * 当日予約を改行？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'sameDayReservationBreakLine'?: boolean;
    /**
     * チェックイン時間
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'checkInStartTime'?: string;
    /**
     * チェックアウト時間
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'checkoutTime'?: string;
    /**
     * チェックイン・アウトを表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'checkInOutVisibility'?: boolean;
    /**
     * チェックイン・アウトを改行？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'checkInOutBreakLine'?: boolean;
    /**
     * メインプラン部屋テキスト
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'planRoomText'?: string;
    /**
     * メインプラン部屋を表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'planRoomVisibility'?: boolean;
    /**
     * メインプラン部屋を改行？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'planRoomBreakLine'?: boolean;
    /**
     * 風呂テキスト
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'bathText'?: string;
    /**
     * お風呂を表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'bathVisibility'?: boolean;
    /**
     * 風呂を改行？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'bathBreakLine'?: boolean;
    /**
     * 泉質テキスト
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'hotSpringQualityText'?: string;
    /**
     * 泉質を表示？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hotSpringQualityVisibility'?: boolean;
    /**
     * バイキング？
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'bikingDinnerStatus'?: DocumentContentResponseDtoBikingDinnerStatusEnum;
    /**
     * ペット可？
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'petAllowedStatus'?: DocumentContentResponseDtoPetAllowedStatusEnum;
    /**
     * ベッド？
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'bedStatus'?: DocumentContentResponseDtoBedStatusEnum;
    /**
     * 部屋食？
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'roomDinnerStatus'?: DocumentContentResponseDtoRoomDinnerStatusEnum;
    /**
     * ウォシュレット？
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'washletStatus'?: DocumentContentResponseDtoWashletStatusEnum;
    /**
     * 禁煙？
     * @type {string}
     * @memberof DocumentContentResponseDto
     */
    'smokingStatus'?: DocumentContentResponseDtoSmokingStatusEnum;
    /**
     * 露天風呂？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hasOpenAirBath'?: boolean;
    /**
     * かけ流し？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hasKakenagashi'?: boolean;
    /**
     * エレベーター？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hasElevator'?: boolean;
    /**
     * 当日予約可？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hasSameDayReservation'?: boolean;
    /**
     * 送迎あり？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hasDropOffService'?: boolean;
    /**
     * 貸切風呂？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hasReservedBath'?: boolean;
    /**
     * 一人泊？
     * @type {boolean}
     * @memberof DocumentContentResponseDto
     */
    'hasSingleGuest'?: boolean;
    /**
     * feeTable
     * @type {Array<PriceTableResponseDto>}
     * @memberof DocumentContentResponseDto
     */
    'priceTables'?: Array<PriceTableResponseDto>;
}

export const DocumentContentResponseDtoRow1PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentContentResponseDtoRow1PatternEnum = typeof DocumentContentResponseDtoRow1PatternEnum[keyof typeof DocumentContentResponseDtoRow1PatternEnum];
export const DocumentContentResponseDtoRow2PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentContentResponseDtoRow2PatternEnum = typeof DocumentContentResponseDtoRow2PatternEnum[keyof typeof DocumentContentResponseDtoRow2PatternEnum];
export const DocumentContentResponseDtoRow3PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentContentResponseDtoRow3PatternEnum = typeof DocumentContentResponseDtoRow3PatternEnum[keyof typeof DocumentContentResponseDtoRow3PatternEnum];
export const DocumentContentResponseDtoRow4PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentContentResponseDtoRow4PatternEnum = typeof DocumentContentResponseDtoRow4PatternEnum[keyof typeof DocumentContentResponseDtoRow4PatternEnum];
export const DocumentContentResponseDtoPriceTableTopPatternEnum = {
    A: 'TABLE_A',
    B: 'TABLE_B',
    C: 'TABLE_C'
} as const;

export type DocumentContentResponseDtoPriceTableTopPatternEnum = typeof DocumentContentResponseDtoPriceTableTopPatternEnum[keyof typeof DocumentContentResponseDtoPriceTableTopPatternEnum];
export const DocumentContentResponseDtoBreakfastPlaceEnum = {
    None: 'NONE',
    Restaurant: 'RESTAURANT',
    PrivateRestaurant: 'PRIVATE_RESTAURANT',
    Guestroom: 'GUESTROOM',
    RestaurantAndPrivateRestaurant: 'RESTAURANT_AND_PRIVATE_RESTAURANT',
    RestaurantAndGuestroom: 'RESTAURANT_AND_GUESTROOM',
    GuestroomAndPrivateRestaurant: 'GUESTROOM_AND_PRIVATE_RESTAURANT'
} as const;

export type DocumentContentResponseDtoBreakfastPlaceEnum = typeof DocumentContentResponseDtoBreakfastPlaceEnum[keyof typeof DocumentContentResponseDtoBreakfastPlaceEnum];
export const DocumentContentResponseDtoDinnerPlaceEnum = {
    None: 'NONE',
    Restaurant: 'RESTAURANT',
    PrivateRestaurant: 'PRIVATE_RESTAURANT',
    Guestroom: 'GUESTROOM',
    RestaurantAndPrivateRestaurant: 'RESTAURANT_AND_PRIVATE_RESTAURANT',
    RestaurantAndGuestroom: 'RESTAURANT_AND_GUESTROOM',
    GuestroomAndPrivateRestaurant: 'GUESTROOM_AND_PRIVATE_RESTAURANT'
} as const;

export type DocumentContentResponseDtoDinnerPlaceEnum = typeof DocumentContentResponseDtoDinnerPlaceEnum[keyof typeof DocumentContentResponseDtoDinnerPlaceEnum];
export const DocumentContentResponseDtoBikingDinnerStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentContentResponseDtoBikingDinnerStatusEnum = typeof DocumentContentResponseDtoBikingDinnerStatusEnum[keyof typeof DocumentContentResponseDtoBikingDinnerStatusEnum];
export const DocumentContentResponseDtoPetAllowedStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentContentResponseDtoPetAllowedStatusEnum = typeof DocumentContentResponseDtoPetAllowedStatusEnum[keyof typeof DocumentContentResponseDtoPetAllowedStatusEnum];
export const DocumentContentResponseDtoBedStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentContentResponseDtoBedStatusEnum = typeof DocumentContentResponseDtoBedStatusEnum[keyof typeof DocumentContentResponseDtoBedStatusEnum];
export const DocumentContentResponseDtoRoomDinnerStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentContentResponseDtoRoomDinnerStatusEnum = typeof DocumentContentResponseDtoRoomDinnerStatusEnum[keyof typeof DocumentContentResponseDtoRoomDinnerStatusEnum];
export const DocumentContentResponseDtoWashletStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentContentResponseDtoWashletStatusEnum = typeof DocumentContentResponseDtoWashletStatusEnum[keyof typeof DocumentContentResponseDtoWashletStatusEnum];
export const DocumentContentResponseDtoSmokingStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentContentResponseDtoSmokingStatusEnum = typeof DocumentContentResponseDtoSmokingStatusEnum[keyof typeof DocumentContentResponseDtoSmokingStatusEnum];

/**
 * 
 * @export
 * @interface DocumentDiversionSearchDto
 */
export interface DocumentDiversionSearchDto {
    /**
     * 
     * @type {number}
     * @memberof DocumentDiversionSearchDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentDiversionSearchDto
     */
    'hotelCode': string;
    /**
     * 
     * @type {ProjectListInBookletInProjectDto}
     * @memberof DocumentDiversionSearchDto
     */
    'project': ProjectListInBookletInProjectDto;
    /**
     * 
     * @type {BookletPublicDto}
     * @memberof DocumentDiversionSearchDto
     */
    'booklet': BookletPublicDto;
    /**
     * 
     * @type {string}
     * @memberof DocumentDiversionSearchDto
     */
    'documentCode': string;
    /**
     * 
     * @type {Array<DocumentMyStockResponseDto>}
     * @memberof DocumentDiversionSearchDto
     */
    'documentMyStocks': Array<DocumentMyStockResponseDto>;
    /**
     * 
     * @type {MasterDocumentStatusDto}
     * @memberof DocumentDiversionSearchDto
     */
    'status': MasterDocumentStatusDto;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentDiversionSearchDto
     */
    'manuscriptPerson': PersonDto;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentDiversionSearchDto
     */
    'modifiedAt': string;
}
/**
 * 
 * @export
 * @interface DocumentEvaluationMediaTypeDto
 */
export interface DocumentEvaluationMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof DocumentEvaluationMediaTypeDto
     */
    'mediaTypeCode': DocumentEvaluationMediaTypeDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof DocumentEvaluationMediaTypeDto
     */
    'masterMediaType': Array<MasterMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentEvaluationMediaTypeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentEvaluationMediaTypeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentEvaluationMediaTypeDto
     */
    'deletedAt'?: string;
    /**
     * 評価パーツID
     * @type {number}
     * @memberof DocumentEvaluationMediaTypeDto
     */
    'documentEvaluationId': number;
}

export const DocumentEvaluationMediaTypeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type DocumentEvaluationMediaTypeDtoMediaTypeCodeEnum = typeof DocumentEvaluationMediaTypeDtoMediaTypeCodeEnum[keyof typeof DocumentEvaluationMediaTypeDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentEvaluationResponseDto
 */
export interface DocumentEvaluationResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof DocumentEvaluationResponseDto
     */
    'id': number;
    /**
     * 評価パーツコード(必須) 
     * @type {number}
     * @memberof DocumentEvaluationResponseDto
     */
    'code': number;
    /**
     * 評価パーツ名称(必須)
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'name': string;
    /**
     * 評価パーツ備考
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'comment'?: string;
    /**
     * 評価パーツ今月初登場
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'imageFirst'?: string;
    /**
     * 評価パーツ前号初登場
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'imagePrevious': string;
    /**
     * 評価パーツ前々号初登場
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'imagePreviousTwo': string;
    /**
     * 評価パーツ募集中
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'imageWanted': string;
    /**
     * 星画像（全）
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'imageStarFillAll': string;
    /**
     * 星画像（半）
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'imageStarFillHalf': string;
    /**
     * 星画像（無）
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'imageStarFillNone': string;
    /**
     * 口コミ台紙 INDD
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'inDesign': string;
    /**
     * 原稿サイズコード
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'documentSizeCode': DocumentEvaluationResponseDtoDocumentSizeCodeEnum;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentEvaluationResponseDto
     */
    'documentSize': MasterDocumentSizeDto;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentEvaluationResponseDto
     */
    'deletedAt'?: string;
    /**
     * 媒体情報の配列
     * @type {Array<DocumentEvaluationMediaTypeDto>}
     * @memberof DocumentEvaluationResponseDto
     */
    'mediaTypes'?: Array<DocumentEvaluationMediaTypeDto>;
}

export const DocumentEvaluationResponseDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentEvaluationResponseDtoDocumentSizeCodeEnum = typeof DocumentEvaluationResponseDtoDocumentSizeCodeEnum[keyof typeof DocumentEvaluationResponseDtoDocumentSizeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentEvaluationWithCountDto
 */
export interface DocumentEvaluationWithCountDto {
    /**
     * 
     * @type {Array<DocumentEvaluationResponseDto>}
     * @memberof DocumentEvaluationWithCountDto
     */
    'data': Array<DocumentEvaluationResponseDto>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof DocumentEvaluationWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentFillerDto
 */
export interface DocumentFillerDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentFillerDto
     */
    'id': number;
    /**
     * congnitoId
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'code': string;
    /**
     * 埋め草名称
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'name': string;
    /**
     * イメージパス
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'image': string;
    /**
     * 変換済みイメージパス
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'imageConvert': string;
    /**
     * 内容欄
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'freeWord': string;
    /**
     * 備考欄
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'comment'?: string;
    /**
     * 原稿サイズ
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'documentSizeCode': DocumentFillerDtoDocumentSizeCodeEnum;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentFillerDto
     */
    'deletedAt'?: string;
}

export const DocumentFillerDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentFillerDtoDocumentSizeCodeEnum = typeof DocumentFillerDtoDocumentSizeCodeEnum[keyof typeof DocumentFillerDtoDocumentSizeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentFillerMediaTypeDto
 */
export interface DocumentFillerMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof DocumentFillerMediaTypeDto
     */
    'mediaTypeCode': DocumentFillerMediaTypeDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof DocumentFillerMediaTypeDto
     */
    'masterMediaType': Array<MasterMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentFillerMediaTypeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentFillerMediaTypeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentFillerMediaTypeDto
     */
    'deletedAt'?: string;
    /**
     * 埋め草id
     * @type {number}
     * @memberof DocumentFillerMediaTypeDto
     */
    'documentFillerId': number;
}

export const DocumentFillerMediaTypeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type DocumentFillerMediaTypeDtoMediaTypeCodeEnum = typeof DocumentFillerMediaTypeDtoMediaTypeCodeEnum[keyof typeof DocumentFillerMediaTypeDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentFillerWithCountDto
 */
export interface DocumentFillerWithCountDto {
    /**
     * 
     * @type {Array<DocumentFillerWithSizeMediaType>}
     * @memberof DocumentFillerWithCountDto
     */
    'data': Array<DocumentFillerWithSizeMediaType>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof DocumentFillerWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentFillerWithSizeMediaType
 */
export interface DocumentFillerWithSizeMediaType {
    /**
     * id
     * @type {number}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'id': number;
    /**
     * congnitoId
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'code': string;
    /**
     * 埋め草名称
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'name': string;
    /**
     * イメージパス
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'image': string;
    /**
     * 変換済みイメージパス
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'imageConvert': string;
    /**
     * 内容欄
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'freeWord': string;
    /**
     * 備考欄
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'comment'?: string;
    /**
     * 原稿サイズ
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'documentSizeCode': DocumentFillerWithSizeMediaTypeDocumentSizeCodeEnum;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'documentSize': MasterDocumentSizeDto;
    /**
     * 媒体タイプの配列
     * @type {Array<DocumentFillerMediaTypeDto>}
     * @memberof DocumentFillerWithSizeMediaType
     */
    'mediaTypes': Array<DocumentFillerMediaTypeDto>;
}

export const DocumentFillerWithSizeMediaTypeDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentFillerWithSizeMediaTypeDocumentSizeCodeEnum = typeof DocumentFillerWithSizeMediaTypeDocumentSizeCodeEnum[keyof typeof DocumentFillerWithSizeMediaTypeDocumentSizeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentHeadLineByEditionCodeDto
 */
export interface DocumentHeadLineByEditionCodeDto {
    /**
     * ID
     * @type {number}
     * @memberof DocumentHeadLineByEditionCodeDto
     */
    'id': number;
    /**
     * 見出しID
     * @type {number}
     * @memberof DocumentHeadLineByEditionCodeDto
     */
    'documentHeadLineId': number;
    /**
     * 版コード
     * @type {string}
     * @memberof DocumentHeadLineByEditionCodeDto
     */
    'editionCode': DocumentHeadLineByEditionCodeDtoEditionCodeEnum;
    /**
     * 版毎のイメージ
     * @type {Array<DocumentHeadLineImageResponseDto>}
     * @memberof DocumentHeadLineByEditionCodeDto
     */
    'documentHeadLineImages'?: Array<DocumentHeadLineImageResponseDto>;
}

export const DocumentHeadLineByEditionCodeDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type DocumentHeadLineByEditionCodeDtoEditionCodeEnum = typeof DocumentHeadLineByEditionCodeDtoEditionCodeEnum[keyof typeof DocumentHeadLineByEditionCodeDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface DocumentHeadLineDto
 */
export interface DocumentHeadLineDto {
    /**
     * ID
     * @type {number}
     * @memberof DocumentHeadLineDto
     */
    'id': number;
    /**
     * 見出し名
     * @type {string}
     * @memberof DocumentHeadLineDto
     */
    'name': string;
    /**
     * 見出しコード
     * @type {number}
     * @memberof DocumentHeadLineDto
     */
    'code': number;
    /**
     * 見出し自由入力
     * @type {string}
     * @memberof DocumentHeadLineDto
     */
    'freeWord': string;
    /**
     * 原稿サイズ
     * @type {string}
     * @memberof DocumentHeadLineDto
     */
    'documentSizeCode': DocumentHeadLineDtoDocumentSizeCodeEnum;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentHeadLineDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentHeadLineDto
     */
    'modifiedAt': string;
    /**
     * 削除日(表示されない)
     * @type {string}
     * @memberof DocumentHeadLineDto
     */
    'deletedAt'?: string;
}

export const DocumentHeadLineDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentHeadLineDtoDocumentSizeCodeEnum = typeof DocumentHeadLineDtoDocumentSizeCodeEnum[keyof typeof DocumentHeadLineDtoDocumentSizeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentHeadLineImageResponseDto
 */
export interface DocumentHeadLineImageResponseDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'id': number;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'image': string;
    /**
     * 変換画像パス
     * @type {string}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'imageConvert': string;
    /**
     * 画像コード
     * @type {string}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'code': string;
    /**
     * 版毎のid
     * @type {number}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'headLineByEditionId': number;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentHeadLineImageResponseDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface DocumentHeadLineMediaTypeDto
 */
export interface DocumentHeadLineMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof DocumentHeadLineMediaTypeDto
     */
    'mediaTypeCode': DocumentHeadLineMediaTypeDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof DocumentHeadLineMediaTypeDto
     */
    'masterMediaType': Array<MasterMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentHeadLineMediaTypeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentHeadLineMediaTypeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentHeadLineMediaTypeDto
     */
    'deletedAt'?: string;
    /**
     * 見出しID
     * @type {number}
     * @memberof DocumentHeadLineMediaTypeDto
     */
    'documentHeadLineId': number;
}

export const DocumentHeadLineMediaTypeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type DocumentHeadLineMediaTypeDtoMediaTypeCodeEnum = typeof DocumentHeadLineMediaTypeDtoMediaTypeCodeEnum[keyof typeof DocumentHeadLineMediaTypeDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentHeadLineResponseDto
 */
export interface DocumentHeadLineResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof DocumentHeadLineResponseDto
     */
    'id': number;
    /**
     * 見出しコード
     * @type {number}
     * @memberof DocumentHeadLineResponseDto
     */
    'code': number;
    /**
     * 見出し名称
     * @type {string}
     * @memberof DocumentHeadLineResponseDto
     */
    'name': string;
    /**
     * 版の配列
     * @type {Array<DocumentHeadLineByEditionCodeDto>}
     * @memberof DocumentHeadLineResponseDto
     */
    'headLineByEditionCodes'?: Array<DocumentHeadLineByEditionCodeDto>;
    /**
     * 媒体情報の配列
     * @type {Array<DocumentHeadLineMediaTypeDto>}
     * @memberof DocumentHeadLineResponseDto
     */
    'documentHeadLineMediaTypes'?: Array<DocumentHeadLineMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentHeadLineResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentHeadLineResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentHeadLineResponseDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface DocumentHeadLineWithCountDto
 */
export interface DocumentHeadLineWithCountDto {
    /**
     * 
     * @type {Array<DocumentHeadLineResponseDto>}
     * @memberof DocumentHeadLineWithCountDto
     */
    'data': Array<DocumentHeadLineResponseDto>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof DocumentHeadLineWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentInMyStockWithAliasDto
 */
export interface DocumentInMyStockWithAliasDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'id': number;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'modifiedAt': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'hotelCode': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'documentCode': string;
    /**
     * 
     * @type {MasterDocumentStatusDto}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'status': MasterDocumentStatusDto;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'documentSize': MasterDocumentSizeDto;
    /**
     * 
     * @type {DocumentContentResponseDto}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'documentContent': DocumentContentResponseDto;
    /**
     * id
     * @type {number}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'pageId': number;
    /**
     * 
     * @type {DocumentResponseDto}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'alias': DocumentResponseDto;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof DocumentInMyStockWithAliasDto
     */
    'sharingAliasTo': Array<DocumentResponseDto>;
}
/**
 * 
 * @export
 * @interface DocumentMyStockDto
 */
export interface DocumentMyStockDto {
    /**
     * documentId
     * @type {number}
     * @memberof DocumentMyStockDto
     */
    'documentId': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentMyStockDto
     */
    'createPersonCognito': string;
}
/**
 * 
 * @export
 * @interface DocumentMyStockPublicDto
 */
export interface DocumentMyStockPublicDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentMyStockPublicDto
     */
    'id': number;
    /**
     * 
     * @type {DocumentInMyStockWithAliasDto}
     * @memberof DocumentMyStockPublicDto
     */
    'document'?: DocumentInMyStockWithAliasDto;
    /**
     * 
     * @type {BookletInMyStockDto}
     * @memberof DocumentMyStockPublicDto
     */
    'booklet'?: BookletInMyStockDto;
    /**
     * 
     * @type {PageInMyStockDto}
     * @memberof DocumentMyStockPublicDto
     */
    'page'?: PageInMyStockDto;
    /**
     * 
     * @type {string}
     * @memberof DocumentMyStockPublicDto
     */
    'createPersonCognito': string;
}
/**
 * 
 * @export
 * @interface DocumentMyStockResponseDto
 */
export interface DocumentMyStockResponseDto {
    /**
     * 
     * @type {number}
     * @memberof DocumentMyStockResponseDto
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof DocumentMyStockResponseDto
     */
    'projectId': number;
    /**
     * 
     * @type {ProjectResponseDto}
     * @memberof DocumentMyStockResponseDto
     */
    'project'?: ProjectResponseDto;
    /**
     * 
     * @type {number}
     * @memberof DocumentMyStockResponseDto
     */
    'bookletId': number;
    /**
     * 
     * @type {BookletResponseDto}
     * @memberof DocumentMyStockResponseDto
     */
    'booklet'?: BookletResponseDto;
    /**
     * 
     * @type {number}
     * @memberof DocumentMyStockResponseDto
     */
    'pageId': number;
    /**
     * 
     * @type {PageResponseDto}
     * @memberof DocumentMyStockResponseDto
     */
    'page'?: PageResponseDto;
    /**
     * 
     * @type {number}
     * @memberof DocumentMyStockResponseDto
     */
    'documentId': number;
    /**
     * 
     * @type {DocumentResponseDto}
     * @memberof DocumentMyStockResponseDto
     */
    'document'?: DocumentResponseDto;
    /**
     * 
     * @type {string}
     * @memberof DocumentMyStockResponseDto
     */
    'createPersonCognito': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentMyStockResponseDto
     */
    'createPerson': PersonDto;
}
/**
 * 
 * @export
 * @interface DocumentMyStockResponseWithCountDto
 */
export interface DocumentMyStockResponseWithCountDto {
    /**
     * 
     * @type {Array<SearchDocumentMyStockDto>}
     * @memberof DocumentMyStockResponseWithCountDto
     */
    'data': Array<SearchDocumentMyStockDto>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof DocumentMyStockResponseWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentPartsCategoryDto
 */
export interface DocumentPartsCategoryDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentPartsCategoryDto
     */
    'id': number;
    /**
     * カテゴリのコード
     * @type {string}
     * @memberof DocumentPartsCategoryDto
     */
    'documentPartsClass': DocumentPartsCategoryDtoDocumentPartsClassEnum;
    /**
     * 名前
     * @type {string}
     * @memberof DocumentPartsCategoryDto
     */
    'name': string;
    /**
     * 表示順
     * @type {number}
     * @memberof DocumentPartsCategoryDto
     */
    'order': number;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentPartsCategoryDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentPartsCategoryDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentPartsCategoryDto
     */
    'deletedAt'?: string;
}

export const DocumentPartsCategoryDtoDocumentPartsClassEnum = {
    Normal: 'NORMAL',
    Common: 'COMMON',
    Selection: 'SELECTION',
    Photo: 'PHOTO'
} as const;

export type DocumentPartsCategoryDtoDocumentPartsClassEnum = typeof DocumentPartsCategoryDtoDocumentPartsClassEnum[keyof typeof DocumentPartsCategoryDtoDocumentPartsClassEnum];

/**
 * 
 * @export
 * @interface DocumentPartsContentResponseDto
 */
export interface DocumentPartsContentResponseDto {
    /**
     * パーツid
     * @type {number}
     * @memberof DocumentPartsContentResponseDto
     */
    'documentPartsId': number;
    /**
     * 原稿id
     * @type {number}
     * @memberof DocumentPartsContentResponseDto
     */
    'documentId': number;
    /**
     * テンプレートによって分けられた区画の何番目かを表すインデックス
     * @type {number}
     * @memberof DocumentPartsContentResponseDto
     */
    'templateIndex': number;
    /**
     * パターンによって分けられた区画の何番目かを表すインデックス
     * @type {number}
     * @memberof DocumentPartsContentResponseDto
     */
    'patternIndex': number;
    /**
     * パーツプランコード
     * @type {string}
     * @memberof DocumentPartsContentResponseDto
     */
    'planCode'?: string;
    /**
     * 文章
     * @type {string}
     * @memberof DocumentPartsContentResponseDto
     */
    'text'?: string;
    /**
     * 脚注
     * @type {string}
     * @memberof DocumentPartsContentResponseDto
     */
    'caption'?: string;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentPartsContentResponseDto
     */
    'imagePath'?: string;
    /**
     * 自慢スタンプ
     * @type {number}
     * @memberof DocumentPartsContentResponseDto
     */
    'boastStampId': number;
    /**
     * 
     * @type {DocumentPartsResponseDto}
     * @memberof DocumentPartsContentResponseDto
     */
    'documentParts': DocumentPartsResponseDto;
}
/**
 * 
 * @export
 * @interface DocumentPartsMediaTypeDto
 */
export interface DocumentPartsMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof DocumentPartsMediaTypeDto
     */
    'mediaTypeCode': DocumentPartsMediaTypeDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof DocumentPartsMediaTypeDto
     */
    'masterMediaType': Array<MasterMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentPartsMediaTypeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentPartsMediaTypeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentPartsMediaTypeDto
     */
    'deletedAt'?: string;
    /**
     * 評価パーツID
     * @type {number}
     * @memberof DocumentPartsMediaTypeDto
     */
    'documentPartsId': number;
}

export const DocumentPartsMediaTypeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type DocumentPartsMediaTypeDtoMediaTypeCodeEnum = typeof DocumentPartsMediaTypeDtoMediaTypeCodeEnum[keyof typeof DocumentPartsMediaTypeDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentPartsResponseDto
 */
export interface DocumentPartsResponseDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentPartsResponseDto
     */
    'id': number;
    /**
     * パーツ名
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'name': string;
    /**
     * サムネイルパス
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'imageThumbnail': string;
    /**
     * インデザイン画像パス
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'inDesignFile': string;
    /**
     * パーツの内容
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'comment': string;
    /**
     * パーツの備考欄
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'freeWord': string;
    /**
     * パーツの備考欄
     * @type {Array<DocumentPartsMediaTypeDto>}
     * @memberof DocumentPartsResponseDto
     */
    'mediaTypes': Array<DocumentPartsMediaTypeDto>;
    /**
     * パーツカテゴリ
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'documentPartsClass': DocumentPartsResponseDtoDocumentPartsClassEnum;
    /**
     * パーツカテゴリID
     * @type {number}
     * @memberof DocumentPartsResponseDto
     */
    'documentPartsCategoryId': number;
    /**
     * 
     * @type {DocumentPartsCategoryDto}
     * @memberof DocumentPartsResponseDto
     */
    'documentPartsCategory': DocumentPartsCategoryDto;
    /**
     * 原稿サイズコード
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'documentSizeCode': DocumentPartsResponseDtoDocumentSizeCodeEnum;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentPartsResponseDto
     */
    'documentSize': MasterDocumentSizeDto;
    /**
     * 使用可否 false => 不可
     * @type {boolean}
     * @memberof DocumentPartsResponseDto
     */
    'canUse': boolean;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentPartsResponseDto
     */
    'deletedAt'?: string;
}

export const DocumentPartsResponseDtoDocumentPartsClassEnum = {
    Normal: 'NORMAL',
    Common: 'COMMON',
    Selection: 'SELECTION',
    Photo: 'PHOTO'
} as const;

export type DocumentPartsResponseDtoDocumentPartsClassEnum = typeof DocumentPartsResponseDtoDocumentPartsClassEnum[keyof typeof DocumentPartsResponseDtoDocumentPartsClassEnum];
export const DocumentPartsResponseDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentPartsResponseDtoDocumentSizeCodeEnum = typeof DocumentPartsResponseDtoDocumentSizeCodeEnum[keyof typeof DocumentPartsResponseDtoDocumentSizeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentPartsWithCountDto
 */
export interface DocumentPartsWithCountDto {
    /**
     * 
     * @type {Array<DocumentPartsResponseDto>}
     * @memberof DocumentPartsWithCountDto
     */
    'data': Array<DocumentPartsResponseDto>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof DocumentPartsWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentResponseDto
 */
export interface DocumentResponseDto {
    /**
     * 
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'id': number;
    /**
     * 原稿ID
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'documentCode': string;
    /**
     * 
     * @type {ProjectResponseDto}
     * @memberof DocumentResponseDto
     */
    'project'?: ProjectResponseDto;
    /**
     * 
     * @type {BookletResponseDto}
     * @memberof DocumentResponseDto
     */
    'booklet'?: BookletResponseDto;
    /**
     * 
     * @type {PageResponseDto}
     * @memberof DocumentResponseDto
     */
    'page'?: PageResponseDto;
    /**
     * プロジェクトID
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'projectId': number;
    /**
     * 冊子ID
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'bookletId': number;
    /**
     * ページID
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'pageId': number;
    /**
     * 原稿種別
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'documentTypeCode': DocumentResponseDtoDocumentTypeCodeEnum;
    /**
     * 
     * @type {MasterDocumentTypeDto}
     * @memberof DocumentResponseDto
     */
    'documentType'?: MasterDocumentTypeDto;
    /**
     * 原稿サイズコード
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'documentSizeCode': DocumentResponseDtoDocumentSizeCodeEnum;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentResponseDto
     */
    'documentSize'?: MasterDocumentSizeDto;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof DocumentResponseDto
     */
    'sharingAliasTo'?: Array<DocumentResponseDto>;
    /**
     * 相乗り先原稿ID
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'aliasId'?: number;
    /**
     * 
     * @type {DocumentResponseDto}
     * @memberof DocumentResponseDto
     */
    'alias'?: DocumentResponseDto;
    /**
     * ページ番号
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'pageNumber': number;
    /**
     * テンプレートID
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'templateId'?: number;
    /**
     * 
     * @type {DocumentTemplateDto}
     * @memberof DocumentResponseDto
     */
    'template'?: DocumentTemplateDto;
    /**
     * 埋め草ID
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'fillerId'?: number;
    /**
     * 
     * @type {DocumentFillerDto}
     * @memberof DocumentResponseDto
     */
    'filler'?: DocumentFillerDto;
    /**
     * ヘッドラインID
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'headLineId'?: number;
    /**
     * 
     * @type {DocumentHeadLineDto}
     * @memberof DocumentResponseDto
     */
    'headLine'?: DocumentHeadLineDto;
    /**
     * ホテルコード
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'hotelCode': string;
    /**
     * じゃらんコード
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'jalanCode': string;
    /**
     * 原稿担当者コード
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'manuscriptPersonCognito': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseDto
     */
    'manuscriptPerson': PersonDto;
    /**
     * 原稿編集者コード
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'modifierPersonCognito': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseDto
     */
    'modifierPerson'?: PersonDto;
    /**
     * 営業担当コード
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'salesPersonCognito'?: string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseDto
     */
    'salesPerson'?: PersonDto;
    /**
     * 原稿ステータスコード
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'statusCode': DocumentResponseDtoStatusCodeEnum;
    /**
     * 
     * @type {MasterDocumentStatusDto}
     * @memberof DocumentResponseDto
     */
    'status'?: MasterDocumentStatusDto;
    /**
     * エントリーからか
     * @type {boolean}
     * @memberof DocumentResponseDto
     */
    'fromEntry'?: boolean;
    /**
     * 表示順
     * @type {number}
     * @memberof DocumentResponseDto
     */
    'order': number;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'createdAt': string;
    /**
     * 
     * @type {DocumentResponseDtoDocumentContent}
     * @memberof DocumentResponseDto
     */
    'documentContent': DocumentResponseDtoDocumentContent;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentResponseDto
     */
    'deletedAt'?: string;
}

export const DocumentResponseDtoDocumentTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    HeadLine: 'HEAD_LINE',
    Filler: 'FILLER'
} as const;

export type DocumentResponseDtoDocumentTypeCodeEnum = typeof DocumentResponseDtoDocumentTypeCodeEnum[keyof typeof DocumentResponseDtoDocumentTypeCodeEnum];
export const DocumentResponseDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentResponseDtoDocumentSizeCodeEnum = typeof DocumentResponseDtoDocumentSizeCodeEnum[keyof typeof DocumentResponseDtoDocumentSizeCodeEnum];
export const DocumentResponseDtoStatusCodeEnum = {
    Making: 'MAKING',
    NotStart: 'NOT_START',
    Checking: 'CHECKING',
    SendBack: 'SEND_BACK',
    Proofreading: 'PROOFREADING'
} as const;

export type DocumentResponseDtoStatusCodeEnum = typeof DocumentResponseDtoStatusCodeEnum[keyof typeof DocumentResponseDtoStatusCodeEnum];

/**
 * 原稿コンテンツ
 * @export
 * @interface DocumentResponseDtoDocumentContent
 */
export interface DocumentResponseDtoDocumentContent {
    /**
     * document content id
     * @type {number}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'id': number;
    /**
     * document id
     * @type {number}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'documentId': number;
    /**
     * パターン1段目
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'row1Pattern'?: DocumentResponseDtoDocumentContentRow1PatternEnum;
    /**
     * パターン2段目
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'row2Pattern'?: DocumentResponseDtoDocumentContentRow2PatternEnum;
    /**
     * パターン3段目
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'row3Pattern'?: DocumentResponseDtoDocumentContentRow3PatternEnum;
    /**
     * パターン4段目
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'row4Pattern'?: DocumentResponseDtoDocumentContentRow4PatternEnum;
    /**
     * パターン料金表上
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'priceTableTopPattern'?: DocumentResponseDtoDocumentContentPriceTableTopPatternEnum;
    /**
     * 風呂評価対象外
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathExclusiveFlag'?: boolean;
    /**
     * ふりがな小
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'furiganaSmall'?: string;
    /**
     * ふりがな大
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'furiganaLarge'?: string;
    /**
     * 宿名小
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hotelNameSmall'?: string;
    /**
     * 宿名大
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hotelNameLarge'?: string;
    /**
     * 都道府県
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'prefectureName'?: string;
    /**
     * 温泉地名
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'spaName'?: string;
    /**
     * 宿のキャッチテキスト
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hotelCatchCopy'?: string;
    /**
     * 宿外観写真
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'exteriorPhoto'?: string;
    /**
     * アクセス情報テキスト
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'accessInfoText'?: string;
    /**
     * 客室数
     * @type {number}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'numberOfGuestRooms'?: number;
    /**
     * 朝食場所
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'breakfastPlace'?: DocumentResponseDtoDocumentContentBreakfastPlaceEnum;
    /**
     * 夕食場所
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'dinnerPlace'?: DocumentResponseDtoDocumentContentDinnerPlaceEnum;
    /**
     * 販売開始日
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'salesEndDate': string;
    /**
     * メインプランコード
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'mainPlanCode'?: string;
    /**
     * 旅行プランコード
     * @type {Array<string>}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'travelPlanCode'?: Array<string>;
    /**
     * 料金表ID
     * @type {number}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'priceTableId'?: number;
    /**
     * 旅行プラン名上書きテキスト
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'travelPlanNameOverwriteText'?: string;
    /**
     * 旅行プラン名を上書きするか？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'travelPlanNameOverwriteVisibility'?: boolean;
    /**
     * 入湯税・子供
     * @type {number}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathTaxChildren'?: number;
    /**
     * 入湯税・幼児
     * @type {number}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathTaxToddler'?: number;
    /**
     * 入湯税・大人
     * @type {number}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathTax'?: number;
    /**
     * 入湯税を表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathTaxVisibility'?: boolean;
    /**
     * 入湯税を改行？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathTaxBreakLine'?: boolean;
    /**
     * 子供料金を表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'childrenFareVisibility'?: boolean;
    /**
     * 子供料金を改行？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'childrenFareBreakLine'?: boolean;
    /**
     * クレジット支払可能フラグ
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'isPayCredit'?: boolean;
    /**
     * 支払方法を表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'payMethodVisibility'?: boolean;
    /**
     * 支払方法を改行？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'payMethodBreakLine'?: boolean;
    /**
     * 当日予約上書きテキスト
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'sameDayReservationText'?: string;
    /**
     * 当日予約を表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'sameDayReservationVisibility'?: boolean;
    /**
     * 当日予約を改行？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'sameDayReservationBreakLine'?: boolean;
    /**
     * チェックイン時間
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'checkInStartTime'?: string;
    /**
     * チェックアウト時間
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'checkoutTime'?: string;
    /**
     * チェックイン・アウトを表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'checkInOutVisibility'?: boolean;
    /**
     * チェックイン・アウトを改行？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'checkInOutBreakLine'?: boolean;
    /**
     * メインプラン部屋テキスト
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'planRoomText'?: string;
    /**
     * メインプラン部屋を表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'planRoomVisibility'?: boolean;
    /**
     * メインプラン部屋を改行？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'planRoomBreakLine'?: boolean;
    /**
     * 風呂テキスト
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathText'?: string;
    /**
     * お風呂を表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathVisibility'?: boolean;
    /**
     * 風呂を改行？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bathBreakLine'?: boolean;
    /**
     * 泉質テキスト
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hotSpringQualityText'?: string;
    /**
     * 泉質を表示？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hotSpringQualityVisibility'?: boolean;
    /**
     * バイキング？
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bikingDinnerStatus'?: DocumentResponseDtoDocumentContentBikingDinnerStatusEnum;
    /**
     * ペット可？
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'petAllowedStatus'?: DocumentResponseDtoDocumentContentPetAllowedStatusEnum;
    /**
     * ベッド？
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'bedStatus'?: DocumentResponseDtoDocumentContentBedStatusEnum;
    /**
     * 部屋食？
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'roomDinnerStatus'?: DocumentResponseDtoDocumentContentRoomDinnerStatusEnum;
    /**
     * ウォシュレット？
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'washletStatus'?: DocumentResponseDtoDocumentContentWashletStatusEnum;
    /**
     * 禁煙？
     * @type {string}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'smokingStatus'?: DocumentResponseDtoDocumentContentSmokingStatusEnum;
    /**
     * 露天風呂？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hasOpenAirBath'?: boolean;
    /**
     * かけ流し？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hasKakenagashi'?: boolean;
    /**
     * エレベーター？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hasElevator'?: boolean;
    /**
     * 当日予約可？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hasSameDayReservation'?: boolean;
    /**
     * 送迎あり？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hasDropOffService'?: boolean;
    /**
     * 貸切風呂？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hasReservedBath'?: boolean;
    /**
     * 一人泊？
     * @type {boolean}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'hasSingleGuest'?: boolean;
    /**
     * feeTable
     * @type {Array<PriceTableResponseDto>}
     * @memberof DocumentResponseDtoDocumentContent
     */
    'priceTables'?: Array<PriceTableResponseDto>;
}

export const DocumentResponseDtoDocumentContentRow1PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentResponseDtoDocumentContentRow1PatternEnum = typeof DocumentResponseDtoDocumentContentRow1PatternEnum[keyof typeof DocumentResponseDtoDocumentContentRow1PatternEnum];
export const DocumentResponseDtoDocumentContentRow2PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentResponseDtoDocumentContentRow2PatternEnum = typeof DocumentResponseDtoDocumentContentRow2PatternEnum[keyof typeof DocumentResponseDtoDocumentContentRow2PatternEnum];
export const DocumentResponseDtoDocumentContentRow3PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentResponseDtoDocumentContentRow3PatternEnum = typeof DocumentResponseDtoDocumentContentRow3PatternEnum[keyof typeof DocumentResponseDtoDocumentContentRow3PatternEnum];
export const DocumentResponseDtoDocumentContentRow4PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type DocumentResponseDtoDocumentContentRow4PatternEnum = typeof DocumentResponseDtoDocumentContentRow4PatternEnum[keyof typeof DocumentResponseDtoDocumentContentRow4PatternEnum];
export const DocumentResponseDtoDocumentContentPriceTableTopPatternEnum = {
    A: 'TABLE_A',
    B: 'TABLE_B',
    C: 'TABLE_C'
} as const;

export type DocumentResponseDtoDocumentContentPriceTableTopPatternEnum = typeof DocumentResponseDtoDocumentContentPriceTableTopPatternEnum[keyof typeof DocumentResponseDtoDocumentContentPriceTableTopPatternEnum];
export const DocumentResponseDtoDocumentContentBreakfastPlaceEnum = {
    None: 'NONE',
    Restaurant: 'RESTAURANT',
    PrivateRestaurant: 'PRIVATE_RESTAURANT',
    Guestroom: 'GUESTROOM',
    RestaurantAndPrivateRestaurant: 'RESTAURANT_AND_PRIVATE_RESTAURANT',
    RestaurantAndGuestroom: 'RESTAURANT_AND_GUESTROOM',
    GuestroomAndPrivateRestaurant: 'GUESTROOM_AND_PRIVATE_RESTAURANT'
} as const;

export type DocumentResponseDtoDocumentContentBreakfastPlaceEnum = typeof DocumentResponseDtoDocumentContentBreakfastPlaceEnum[keyof typeof DocumentResponseDtoDocumentContentBreakfastPlaceEnum];
export const DocumentResponseDtoDocumentContentDinnerPlaceEnum = {
    None: 'NONE',
    Restaurant: 'RESTAURANT',
    PrivateRestaurant: 'PRIVATE_RESTAURANT',
    Guestroom: 'GUESTROOM',
    RestaurantAndPrivateRestaurant: 'RESTAURANT_AND_PRIVATE_RESTAURANT',
    RestaurantAndGuestroom: 'RESTAURANT_AND_GUESTROOM',
    GuestroomAndPrivateRestaurant: 'GUESTROOM_AND_PRIVATE_RESTAURANT'
} as const;

export type DocumentResponseDtoDocumentContentDinnerPlaceEnum = typeof DocumentResponseDtoDocumentContentDinnerPlaceEnum[keyof typeof DocumentResponseDtoDocumentContentDinnerPlaceEnum];
export const DocumentResponseDtoDocumentContentBikingDinnerStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentResponseDtoDocumentContentBikingDinnerStatusEnum = typeof DocumentResponseDtoDocumentContentBikingDinnerStatusEnum[keyof typeof DocumentResponseDtoDocumentContentBikingDinnerStatusEnum];
export const DocumentResponseDtoDocumentContentPetAllowedStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentResponseDtoDocumentContentPetAllowedStatusEnum = typeof DocumentResponseDtoDocumentContentPetAllowedStatusEnum[keyof typeof DocumentResponseDtoDocumentContentPetAllowedStatusEnum];
export const DocumentResponseDtoDocumentContentBedStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentResponseDtoDocumentContentBedStatusEnum = typeof DocumentResponseDtoDocumentContentBedStatusEnum[keyof typeof DocumentResponseDtoDocumentContentBedStatusEnum];
export const DocumentResponseDtoDocumentContentRoomDinnerStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentResponseDtoDocumentContentRoomDinnerStatusEnum = typeof DocumentResponseDtoDocumentContentRoomDinnerStatusEnum[keyof typeof DocumentResponseDtoDocumentContentRoomDinnerStatusEnum];
export const DocumentResponseDtoDocumentContentWashletStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentResponseDtoDocumentContentWashletStatusEnum = typeof DocumentResponseDtoDocumentContentWashletStatusEnum[keyof typeof DocumentResponseDtoDocumentContentWashletStatusEnum];
export const DocumentResponseDtoDocumentContentSmokingStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type DocumentResponseDtoDocumentContentSmokingStatusEnum = typeof DocumentResponseDtoDocumentContentSmokingStatusEnum[keyof typeof DocumentResponseDtoDocumentContentSmokingStatusEnum];

/**
 * 
 * @export
 * @interface DocumentResponseWithContentDto
 */
export interface DocumentResponseWithContentDto {
    /**
     * 
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'id': number;
    /**
     * 原稿ID
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'documentCode': string;
    /**
     * 
     * @type {ProjectResponseDto}
     * @memberof DocumentResponseWithContentDto
     */
    'project'?: ProjectResponseDto;
    /**
     * 
     * @type {BookletResponseDto}
     * @memberof DocumentResponseWithContentDto
     */
    'booklet'?: BookletResponseDto;
    /**
     * 
     * @type {PageResponseDto}
     * @memberof DocumentResponseWithContentDto
     */
    'page'?: PageResponseDto;
    /**
     * プロジェクトID
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'projectId': number;
    /**
     * 冊子ID
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'bookletId': number;
    /**
     * ページID
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'pageId': number;
    /**
     * 原稿種別
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'documentTypeCode': DocumentResponseWithContentDtoDocumentTypeCodeEnum;
    /**
     * 
     * @type {MasterDocumentTypeDto}
     * @memberof DocumentResponseWithContentDto
     */
    'documentType'?: MasterDocumentTypeDto;
    /**
     * 原稿サイズコード
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'documentSizeCode': DocumentResponseWithContentDtoDocumentSizeCodeEnum;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentResponseWithContentDto
     */
    'documentSize'?: MasterDocumentSizeDto;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof DocumentResponseWithContentDto
     */
    'sharingAliasTo'?: Array<DocumentResponseDto>;
    /**
     * 相乗り先原稿ID
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'aliasId'?: number;
    /**
     * 
     * @type {DocumentResponseDto}
     * @memberof DocumentResponseWithContentDto
     */
    'alias'?: DocumentResponseDto;
    /**
     * ページ番号
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'pageNumber': number;
    /**
     * テンプレートID
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'templateId'?: number;
    /**
     * 
     * @type {DocumentTemplateDto}
     * @memberof DocumentResponseWithContentDto
     */
    'template'?: DocumentTemplateDto;
    /**
     * 埋め草ID
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'fillerId'?: number;
    /**
     * 
     * @type {DocumentFillerDto}
     * @memberof DocumentResponseWithContentDto
     */
    'filler'?: DocumentFillerDto;
    /**
     * ヘッドラインID
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'headLineId'?: number;
    /**
     * 
     * @type {DocumentHeadLineDto}
     * @memberof DocumentResponseWithContentDto
     */
    'headLine'?: DocumentHeadLineDto;
    /**
     * ホテルコード
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'hotelCode': string;
    /**
     * じゃらんコード
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'jalanCode': string;
    /**
     * 原稿担当者コード
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'manuscriptPersonCognito': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseWithContentDto
     */
    'manuscriptPerson': PersonDto;
    /**
     * 原稿編集者コード
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'modifierPersonCognito': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseWithContentDto
     */
    'modifierPerson'?: PersonDto;
    /**
     * 営業担当コード
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'salesPersonCognito'?: string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseWithContentDto
     */
    'salesPerson'?: PersonDto;
    /**
     * 原稿ステータスコード
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'statusCode': DocumentResponseWithContentDtoStatusCodeEnum;
    /**
     * 
     * @type {MasterDocumentStatusDto}
     * @memberof DocumentResponseWithContentDto
     */
    'status'?: MasterDocumentStatusDto;
    /**
     * エントリーからか
     * @type {boolean}
     * @memberof DocumentResponseWithContentDto
     */
    'fromEntry'?: boolean;
    /**
     * 表示順
     * @type {number}
     * @memberof DocumentResponseWithContentDto
     */
    'order': number;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'createdAt': string;
    /**
     * 
     * @type {DocumentResponseDtoDocumentContent}
     * @memberof DocumentResponseWithContentDto
     */
    'documentContent': DocumentResponseDtoDocumentContent;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentResponseWithContentDto
     */
    'deletedAt'?: string;
    /**
     * 
     * @type {Array<DocumentMyStockResponseDto>}
     * @memberof DocumentResponseWithContentDto
     */
    'documentMyStocks'?: Array<DocumentMyStockResponseDto>;
}

export const DocumentResponseWithContentDtoDocumentTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    HeadLine: 'HEAD_LINE',
    Filler: 'FILLER'
} as const;

export type DocumentResponseWithContentDtoDocumentTypeCodeEnum = typeof DocumentResponseWithContentDtoDocumentTypeCodeEnum[keyof typeof DocumentResponseWithContentDtoDocumentTypeCodeEnum];
export const DocumentResponseWithContentDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentResponseWithContentDtoDocumentSizeCodeEnum = typeof DocumentResponseWithContentDtoDocumentSizeCodeEnum[keyof typeof DocumentResponseWithContentDtoDocumentSizeCodeEnum];
export const DocumentResponseWithContentDtoStatusCodeEnum = {
    Making: 'MAKING',
    NotStart: 'NOT_START',
    Checking: 'CHECKING',
    SendBack: 'SEND_BACK',
    Proofreading: 'PROOFREADING'
} as const;

export type DocumentResponseWithContentDtoStatusCodeEnum = typeof DocumentResponseWithContentDtoStatusCodeEnum[keyof typeof DocumentResponseWithContentDtoStatusCodeEnum];

/**
 * 
 * @export
 * @interface DocumentResponseWithProject
 */
export interface DocumentResponseWithProject {
    /**
     * 
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'id': number;
    /**
     * 原稿ID
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'documentCode': string;
    /**
     * 
     * @type {ProjectResponseDto}
     * @memberof DocumentResponseWithProject
     */
    'project'?: ProjectResponseDto;
    /**
     * 
     * @type {BookletResponseDto}
     * @memberof DocumentResponseWithProject
     */
    'booklet'?: BookletResponseDto;
    /**
     * 
     * @type {PageResponseDto}
     * @memberof DocumentResponseWithProject
     */
    'page'?: PageResponseDto;
    /**
     * プロジェクトID
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'projectId': number;
    /**
     * 冊子ID
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'bookletId': number;
    /**
     * ページID
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'pageId': number;
    /**
     * 原稿種別
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'documentTypeCode': DocumentResponseWithProjectDocumentTypeCodeEnum;
    /**
     * 
     * @type {MasterDocumentTypeDto}
     * @memberof DocumentResponseWithProject
     */
    'documentType'?: MasterDocumentTypeDto;
    /**
     * 原稿サイズコード
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'documentSizeCode': DocumentResponseWithProjectDocumentSizeCodeEnum;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentResponseWithProject
     */
    'documentSize'?: MasterDocumentSizeDto;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof DocumentResponseWithProject
     */
    'sharingAliasTo'?: Array<DocumentResponseDto>;
    /**
     * 相乗り先原稿ID
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'aliasId'?: number;
    /**
     * 
     * @type {DocumentResponseDto}
     * @memberof DocumentResponseWithProject
     */
    'alias'?: DocumentResponseDto;
    /**
     * ページ番号
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'pageNumber': number;
    /**
     * テンプレートID
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'templateId'?: number;
    /**
     * 
     * @type {DocumentTemplateDto}
     * @memberof DocumentResponseWithProject
     */
    'template'?: DocumentTemplateDto;
    /**
     * 埋め草ID
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'fillerId'?: number;
    /**
     * 
     * @type {DocumentFillerDto}
     * @memberof DocumentResponseWithProject
     */
    'filler'?: DocumentFillerDto;
    /**
     * ヘッドラインID
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'headLineId'?: number;
    /**
     * 
     * @type {DocumentHeadLineDto}
     * @memberof DocumentResponseWithProject
     */
    'headLine'?: DocumentHeadLineDto;
    /**
     * ホテルコード
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'hotelCode': string;
    /**
     * じゃらんコード
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'jalanCode': string;
    /**
     * 原稿担当者コード
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'manuscriptPersonCognito': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseWithProject
     */
    'manuscriptPerson': PersonDto;
    /**
     * 原稿編集者コード
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'modifierPersonCognito': string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseWithProject
     */
    'modifierPerson'?: PersonDto;
    /**
     * 営業担当コード
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'salesPersonCognito'?: string;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentResponseWithProject
     */
    'salesPerson'?: PersonDto;
    /**
     * 原稿ステータスコード
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'statusCode': DocumentResponseWithProjectStatusCodeEnum;
    /**
     * 
     * @type {MasterDocumentStatusDto}
     * @memberof DocumentResponseWithProject
     */
    'status'?: MasterDocumentStatusDto;
    /**
     * エントリーからか
     * @type {boolean}
     * @memberof DocumentResponseWithProject
     */
    'fromEntry'?: boolean;
    /**
     * 表示順
     * @type {number}
     * @memberof DocumentResponseWithProject
     */
    'order': number;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'createdAt': string;
    /**
     * 
     * @type {DocumentResponseDtoDocumentContent}
     * @memberof DocumentResponseWithProject
     */
    'documentContent': DocumentResponseDtoDocumentContent;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof DocumentResponseWithProject
     */
    'deletedAt'?: string;
}

export const DocumentResponseWithProjectDocumentTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    HeadLine: 'HEAD_LINE',
    Filler: 'FILLER'
} as const;

export type DocumentResponseWithProjectDocumentTypeCodeEnum = typeof DocumentResponseWithProjectDocumentTypeCodeEnum[keyof typeof DocumentResponseWithProjectDocumentTypeCodeEnum];
export const DocumentResponseWithProjectDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentResponseWithProjectDocumentSizeCodeEnum = typeof DocumentResponseWithProjectDocumentSizeCodeEnum[keyof typeof DocumentResponseWithProjectDocumentSizeCodeEnum];
export const DocumentResponseWithProjectStatusCodeEnum = {
    Making: 'MAKING',
    NotStart: 'NOT_START',
    Checking: 'CHECKING',
    SendBack: 'SEND_BACK',
    Proofreading: 'PROOFREADING'
} as const;

export type DocumentResponseWithProjectStatusCodeEnum = typeof DocumentResponseWithProjectStatusCodeEnum[keyof typeof DocumentResponseWithProjectStatusCodeEnum];

/**
 * 
 * @export
 * @interface DocumentSearchDto
 */
export interface DocumentSearchDto {
    /**
     * 
     * @type {number}
     * @memberof DocumentSearchDto
     */
    'id': number;
    /**
     * 宿コード
     * @type {string}
     * @memberof DocumentSearchDto
     */
    'hotelCode': string;
    /**
     * 
     * @type {ProjectResponseDto}
     * @memberof DocumentSearchDto
     */
    'project': ProjectResponseDto;
    /**
     * 
     * @type {BookletResponseDto}
     * @memberof DocumentSearchDto
     */
    'booklet': BookletResponseDto;
    /**
     * 
     * @type {PageResponseDto}
     * @memberof DocumentSearchDto
     */
    'page': PageResponseDto;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentSearchDto
     */
    'documentSize': MasterDocumentSizeDto;
    /**
     * 
     * @type {MasterDocumentStatusDto}
     * @memberof DocumentSearchDto
     */
    'status': MasterDocumentStatusDto;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentSearchDto
     */
    'manuscriptPerson': PersonDto;
    /**
     * 
     * @type {PersonDto}
     * @memberof DocumentSearchDto
     */
    'salesPerson': PersonDto;
    /**
     * 
     * @type {DocumentContentResponseDto}
     * @memberof DocumentSearchDto
     */
    'documentContent': DocumentContentResponseDto;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentSearchDto
     */
    'modifiedAt': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentSearchDto
     */
    'documentCode': string;
}
/**
 * 
 * @export
 * @interface DocumentSearchWithCountDto
 */
export interface DocumentSearchWithCountDto {
    /**
     * 
     * @type {Array<DocumentSearchDto>}
     * @memberof DocumentSearchWithCountDto
     */
    'data': Array<DocumentSearchDto>;
    /**
     * 総count
     * @type {number}
     * @memberof DocumentSearchWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentSettingsDto
 */
export interface DocumentSettingsDto {
    /**
     * 
     * @type {Array<MasterDocumentStatusDto>}
     * @memberof DocumentSettingsDto
     */
    'masterDocumentStatuses': Array<MasterDocumentStatusDto>;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof DocumentSettingsDto
     */
    'masterMediaTypes': Array<MasterMediaTypeDto>;
    /**
     * 
     * @type {Array<DocumentTemplateDto>}
     * @memberof DocumentSettingsDto
     */
    'documentTemplates': Array<DocumentTemplateDto>;
    /**
     * 
     * @type {Array<DocumentHeadLineDto>}
     * @memberof DocumentSettingsDto
     */
    'documentHeadLines': Array<DocumentHeadLineDto>;
    /**
     * 
     * @type {Array<DocumentFillerDto>}
     * @memberof DocumentSettingsDto
     */
    'documentFillers': Array<DocumentFillerDto>;
    /**
     * 
     * @type {Array<PersonDto>}
     * @memberof DocumentSettingsDto
     */
    'salesPersons': Array<PersonDto>;
    /**
     * 
     * @type {Array<PersonDto>}
     * @memberof DocumentSettingsDto
     */
    'manuscriptPersons': Array<PersonDto>;
}
/**
 * 
 * @export
 * @interface DocumentTemplateDto
 */
export interface DocumentTemplateDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentTemplateDto
     */
    'id': number;
    /**
     * テンプレート名
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'name': string;
    /**
     * バージョン
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'inDesignVersion': string;
    /**
     * PC
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'pcType': DocumentTemplateDtoPcTypeEnum;
    /**
     * テンプレートのコメント(自由入力以外に)
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'comment': string;
    /**
     * テンプレートの変更履歴
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'history': string;
    /**
     * 原稿サイズ
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'documentSizeCode': DocumentTemplateDtoDocumentSizeCodeEnum;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'inDesignFile': string;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'imageXml': string;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'imageThumbnail': string;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'modifiedAt': string;
    /**
     * 削除日(表示されない)
     * @type {string}
     * @memberof DocumentTemplateDto
     */
    'deletedAt'?: string;
    /**
     * Document Evaluation Id
     * @type {number}
     * @memberof DocumentTemplateDto
     */
    'documentEvaluationId'?: number;
}

export const DocumentTemplateDtoPcTypeEnum = {
    Win: 'WIN',
    Mac: 'MAC'
} as const;

export type DocumentTemplateDtoPcTypeEnum = typeof DocumentTemplateDtoPcTypeEnum[keyof typeof DocumentTemplateDtoPcTypeEnum];
export const DocumentTemplateDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentTemplateDtoDocumentSizeCodeEnum = typeof DocumentTemplateDtoDocumentSizeCodeEnum[keyof typeof DocumentTemplateDtoDocumentSizeCodeEnum];

/**
 * 
 * @export
 * @interface DocumentTemplateWithCountDto
 */
export interface DocumentTemplateWithCountDto {
    /**
     * 
     * @type {Array<DocumentTemplateWithDocumentSizeDto>}
     * @memberof DocumentTemplateWithCountDto
     */
    'data': Array<DocumentTemplateWithDocumentSizeDto>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof DocumentTemplateWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface DocumentTemplateWithDocumentSizeDto
 */
export interface DocumentTemplateWithDocumentSizeDto {
    /**
     * id
     * @type {number}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'id': number;
    /**
     * テンプレート名
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'name': string;
    /**
     * バージョン
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'inDesignVersion': string;
    /**
     * PC
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'pcType': DocumentTemplateWithDocumentSizeDtoPcTypeEnum;
    /**
     * テンプレートのコメント(自由入力以外に)
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'comment': string;
    /**
     * テンプレートの変更履歴
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'history': string;
    /**
     * 原稿サイズ
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'documentSizeCode': DocumentTemplateWithDocumentSizeDtoDocumentSizeCodeEnum;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'inDesignFile': string;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'imageXml': string;
    /**
     * 画像パス
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'imageThumbnail': string;
    /**
     * 作成日
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'modifiedAt': string;
    /**
     * 削除日(表示されない)
     * @type {string}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'deletedAt'?: string;
    /**
     * Document Evaluation Id
     * @type {number}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'documentEvaluationId'?: number;
    /**
     * 
     * @type {MasterDocumentSizeDto}
     * @memberof DocumentTemplateWithDocumentSizeDto
     */
    'documentSize': MasterDocumentSizeDto;
}

export const DocumentTemplateWithDocumentSizeDtoPcTypeEnum = {
    Win: 'WIN',
    Mac: 'MAC'
} as const;

export type DocumentTemplateWithDocumentSizeDtoPcTypeEnum = typeof DocumentTemplateWithDocumentSizeDtoPcTypeEnum[keyof typeof DocumentTemplateWithDocumentSizeDtoPcTypeEnum];
export const DocumentTemplateWithDocumentSizeDtoDocumentSizeCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type DocumentTemplateWithDocumentSizeDtoDocumentSizeCodeEnum = typeof DocumentTemplateWithDocumentSizeDtoDocumentSizeCodeEnum[keyof typeof DocumentTemplateWithDocumentSizeDtoDocumentSizeCodeEnum];

/**
 * 
 * @export
 * @interface DuplicateProjectDto
 */
export interface DuplicateProjectDto {
    /**
     * id
     * @type {number}
     * @memberof DuplicateProjectDto
     */
    'id': number;
    /**
     * project id
     * @type {number}
     * @memberof DuplicateProjectDto
     */
    'destinationId': number;
}
/**
 * 
 * @export
 * @interface EntryPlanReponseDto
 */
export interface EntryPlanReponseDto {
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'entry_plan_id': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'entry_plan_number': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'entry_id': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'entry_name': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'travel_plan_id': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'plan_name': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'applicable_room_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'room_name': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntryPlanReponseDto
     */
    'is_deleted': boolean;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDto
     */
    'media_yearmonth': string;
    /**
     * 
     * @type {EntryPlanReponseDtoTravelPlans}
     * @memberof EntryPlanReponseDto
     */
    'travel_plans': EntryPlanReponseDtoTravelPlans;
    /**
     * 
     * @type {boolean}
     * @memberof EntryPlanReponseDto
     */
    'is_valid': boolean;
    /**
     * 
     * @type {ApplicableRoomTypeResponseDto}
     * @memberof EntryPlanReponseDto
     */
    'applicable_room_type'?: ApplicableRoomTypeResponseDto;
}
/**
 * 
 * @export
 * @interface EntryPlanReponseDtoTravelPlans
 */
export interface EntryPlanReponseDtoTravelPlans {
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'travel_plan_id': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'travel_plan_code': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'travel_plan_name': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'travel_plan_kana_name': string;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'hotel_id': string;
    /**
     * 
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'reservation_stop_days': number;
    /**
     * 
     * @type {string}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'reservation_stop_hour': string;
    /**
     * 
     * @type {boolean}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'delete_flag': boolean;
    /**
     * number_of_adult
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'number_of_adult': number;
    /**
     * 
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'child_price_upper_grade_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'child_price_underclassman_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'baby_price_dinner_bedding_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'baby_price_dinner_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'baby_price_bedding_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof EntryPlanReponseDtoTravelPlans
     */
    'baby_price_no_dinner_bedding_setting_type'?: number;
}
/**
 * 
 * @export
 * @interface ExclusionDateDraftDto
 */
export interface ExclusionDateDraftDto {
    /**
     * 
     * @type {string}
     * @memberof ExclusionDateDraftDto
     */
    'saleStartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExclusionDateDraftDto
     */
    'saleEndDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExclusionDateDraftDto
     */
    'entryPlanIds': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExclusionDateDraftDto
     */
    'numberOfGuest': Array<string>;
}
/**
 * 
 * @export
 * @interface HotelAgeChargeDto
 */
export interface HotelAgeChargeDto {
    /**
     * 
     * @type {number}
     * @memberof HotelAgeChargeDto
     */
    'age_group_class_type': number;
    /**
     * 
     * @type {number}
     * @memberof HotelAgeChargeDto
     */
    'charge_price': number;
    /**
     * 
     * @type {boolean}
     * @memberof HotelAgeChargeDto
     */
    'delete_flag': boolean;
    /**
     * 
     * @type {string}
     * @memberof HotelAgeChargeDto
     */
    'hotel_charge_id': string;
}
/**
 * 
 * @export
 * @interface HotelChargeResponseDto
 */
export interface HotelChargeResponseDto {
    /**
     * 
     * @type {boolean}
     * @memberof HotelChargeResponseDto
     */
    'success': boolean;
    /**
     * 
     * @type {object}
     * @memberof HotelChargeResponseDto
     */
    'hotels': object;
}
/**
 * 
 * @export
 * @interface HotelInfoResponse
 */
export interface HotelInfoResponse {
    /**
     * 処理結果
     * @type {boolean}
     * @memberof HotelInfoResponse
     */
    'result': boolean;
    /**
     * 宿ID
     * @type {string}
     * @memberof HotelInfoResponse
     */
    'hotelId': string;
    /**
     * 宿コード
     * @type {string}
     * @memberof HotelInfoResponse
     */
    'hotelCode': string;
    /**
     * 宿名称
     * @type {string}
     * @memberof HotelInfoResponse
     */
    'hotelName': string;
    /**
     * 宿かな名称
     * @type {string}
     * @memberof HotelInfoResponse
     */
    'hotelKanaName': string;
    /**
     * 都道府県
     * @type {string}
     * @memberof HotelInfoResponse
     */
    'prefectures': string;
    /**
     * 温泉地名称
     * @type {string}
     * @memberof HotelInfoResponse
     */
    'spaName': string;
    /**
     * 
     * @type {string}
     * @memberof HotelInfoResponse
     */
    'jaran_code': string;
}
/**
 * 
 * @export
 * @interface IdTokenDto
 */
export interface IdTokenDto {
    /**
     * token
     * @type {string}
     * @memberof IdTokenDto
     */
    'jwtToken': string;
    /**
     * 
     * @type {IdTokenDtoPayload}
     * @memberof IdTokenDto
     */
    'payload': IdTokenDtoPayload;
}
/**
 * Payload
 * @export
 * @interface IdTokenDtoPayload
 */
export interface IdTokenDtoPayload {
    /**
     * sub
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'sub': string;
    /**
     * email_verified
     * @type {boolean}
     * @memberof IdTokenDtoPayload
     */
    'email_verified': boolean;
    /**
     * iss
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'iss': string;
    /**
     * origin_jti
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'origin_jti': string;
    /**
     * aud
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'aud': string;
    /**
     * event_id
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'event_id': string;
    /**
     * token_use
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'token_use': string;
    /**
     * auth_time
     * @type {number}
     * @memberof IdTokenDtoPayload
     */
    'auth_time': number;
    /**
     * name
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'name': string;
    /**
     * exp
     * @type {number}
     * @memberof IdTokenDtoPayload
     */
    'exp': number;
    /**
     * iat
     * @type {number}
     * @memberof IdTokenDtoPayload
     */
    'iat': number;
    /**
     * jti
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'jti': string;
    /**
     * email
     * @type {string}
     * @memberof IdTokenDtoPayload
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface IdmlHtmlTestItemDto
 */
export interface IdmlHtmlTestItemDto {
    /**
     * 種別
     * @type {string}
     * @memberof IdmlHtmlTestItemDto
     */
    'type': string;
    /**
     * SelfID
     * @type {string}
     * @memberof IdmlHtmlTestItemDto
     */
    'self': string;
    /**
     * HTML
     * @type {string}
     * @memberof IdmlHtmlTestItemDto
     */
    'html': string;
    /**
     * 表示X座標
     * @type {number}
     * @memberof IdmlHtmlTestItemDto
     */
    'x': number;
    /**
     * 表示Y座標
     * @type {number}
     * @memberof IdmlHtmlTestItemDto
     */
    'y': number;
    /**
     * 表示長さ
     * @type {number}
     * @memberof IdmlHtmlTestItemDto
     */
    'width': number;
    /**
     * 表示高さ
     * @type {number}
     * @memberof IdmlHtmlTestItemDto
     */
    'height': number;
    /**
     * 編集可能フラグ
     * @type {boolean}
     * @memberof IdmlHtmlTestItemDto
     */
    'editable': boolean;
    /**
     * 親タグID
     * @type {string}
     * @memberof IdmlHtmlTestItemDto
     */
    'parentTagId': string;
}
/**
 * 
 * @export
 * @interface IdmlImagePageItemDto
 */
export interface IdmlImagePageItemDto {
    /**
     * 種別
     * @type {string}
     * @memberof IdmlImagePageItemDto
     */
    'type': string;
    /**
     * SelfID
     * @type {string}
     * @memberof IdmlImagePageItemDto
     */
    'self': string;
    /**
     * 表示X座標
     * @type {number}
     * @memberof IdmlImagePageItemDto
     */
    'x': number;
    /**
     * 表示Y座標
     * @type {number}
     * @memberof IdmlImagePageItemDto
     */
    'y': number;
    /**
     * 表示長さ
     * @type {number}
     * @memberof IdmlImagePageItemDto
     */
    'width': number;
    /**
     * 表示高さ
     * @type {number}
     * @memberof IdmlImagePageItemDto
     */
    'height': number;
    /**
     * 編集可能フラグ
     * @type {boolean}
     * @memberof IdmlImagePageItemDto
     */
    'editable': boolean;
    /**
     * 親タグID
     * @type {string}
     * @memberof IdmlImagePageItemDto
     */
    'parentTagId': string;
    /**
     * イメージ情報
     * @type {Array<IdmlImagePageSubItemDto>}
     * @memberof IdmlImagePageItemDto
     */
    'images': Array<IdmlImagePageSubItemDto>;
}
/**
 * 
 * @export
 * @interface IdmlImagePageSubItemDto
 */
export interface IdmlImagePageSubItemDto {
    /**
     * 種別
     * @type {string}
     * @memberof IdmlImagePageSubItemDto
     */
    'type': string;
    /**
     * タグID
     * @type {string}
     * @memberof IdmlImagePageSubItemDto
     */
    'tag': string;
    /**
     * SelfID
     * @type {string}
     * @memberof IdmlImagePageSubItemDto
     */
    'self': string;
    /**
     * 表示X座標
     * @type {number}
     * @memberof IdmlImagePageSubItemDto
     */
    'x': number;
    /**
     * 表示Y座標
     * @type {number}
     * @memberof IdmlImagePageSubItemDto
     */
    'y': number;
    /**
     * 表示長さ
     * @type {number}
     * @memberof IdmlImagePageSubItemDto
     */
    'width': number;
    /**
     * 表示高さ
     * @type {number}
     * @memberof IdmlImagePageSubItemDto
     */
    'height': number;
    /**
     * ScaleX
     * @type {number}
     * @memberof IdmlImagePageSubItemDto
     */
    'scaleX': number;
    /**
     * ScaleY
     * @type {number}
     * @memberof IdmlImagePageSubItemDto
     */
    'scaleY': number;
    /**
     * LinkResourceModified
     * @type {number}
     * @memberof IdmlImagePageSubItemDto
     */
    'linkResourceModified': number;
    /**
     * LinkedResource
     * @type {boolean}
     * @memberof IdmlImagePageSubItemDto
     */
    'linkedResource': boolean;
    /**
     * ImageFileName
     * @type {string}
     * @memberof IdmlImagePageSubItemDto
     */
    'imageFileName': string;
    /**
     * 編集可能フラグ
     * @type {boolean}
     * @memberof IdmlImagePageSubItemDto
     */
    'editable': boolean;
}
/**
 * 
 * @export
 * @interface IdmlItemsResponseDto
 */
export interface IdmlItemsResponseDto {
    /**
     * 項目一覧
     * @type {Array<IdmlItemsResponseDtoItemsInner>}
     * @memberof IdmlItemsResponseDto
     */
    'items': Array<IdmlItemsResponseDtoItemsInner>;
    /**
     * 
     * @type {IdmlItemsResponseDtoPage}
     * @memberof IdmlItemsResponseDto
     */
    'page'?: IdmlItemsResponseDtoPage;
    /**
     * パッケージID情報
     * @type {Array<string>}
     * @memberof IdmlItemsResponseDto
     */
    'packages'?: Array<string>;
    /**
     * Error Message
     * @type {string}
     * @memberof IdmlItemsResponseDto
     */
    'error'?: string;
}
/**
 * @type IdmlItemsResponseDtoItemsInner
 * @export
 */
export type IdmlItemsResponseDtoItemsInner = IdmlHtmlTestItemDto | IdmlImagePageItemDto | IdmlRectanglePageItemDto | IdmlTextFramePageItemDto;

/**
 * ページ情報
 * @export
 * @interface IdmlItemsResponseDtoPage
 */
export interface IdmlItemsResponseDtoPage {
    /**
     * 
     * @type {IdmlPageSizeDtoSize}
     * @memberof IdmlItemsResponseDtoPage
     */
    'size': IdmlPageSizeDtoSize;
}
/**
 * 
 * @export
 * @interface IdmlPageSizeDto
 */
export interface IdmlPageSizeDto {
    /**
     * 
     * @type {IdmlPageSizeDtoSize}
     * @memberof IdmlPageSizeDto
     */
    'size': IdmlPageSizeDtoSize;
}
/**
 * 原稿サイズ
 * @export
 * @interface IdmlPageSizeDtoSize
 */
export interface IdmlPageSizeDtoSize {
    /**
     * 原稿長さ
     * @type {number}
     * @memberof IdmlPageSizeDtoSize
     */
    'width': number;
    /**
     * 原稿高さ
     * @type {number}
     * @memberof IdmlPageSizeDtoSize
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface IdmlPageSizeINfoDto
 */
export interface IdmlPageSizeINfoDto {
    /**
     * 原稿長さ
     * @type {number}
     * @memberof IdmlPageSizeINfoDto
     */
    'width': number;
    /**
     * 原稿高さ
     * @type {number}
     * @memberof IdmlPageSizeINfoDto
     */
    'height': number;
}
/**
 * 
 * @export
 * @interface IdmlRectanglePageItemDto
 */
export interface IdmlRectanglePageItemDto {
    /**
     * 種別
     * @type {string}
     * @memberof IdmlRectanglePageItemDto
     */
    'type': string;
    /**
     * SelfID
     * @type {string}
     * @memberof IdmlRectanglePageItemDto
     */
    'self': string;
    /**
     * ストーリーID
     * @type {string}
     * @memberof IdmlRectanglePageItemDto
     */
    'parentStory': string;
    /**
     * 表示X座標
     * @type {number}
     * @memberof IdmlRectanglePageItemDto
     */
    'x': number;
    /**
     * 表示Y座標
     * @type {number}
     * @memberof IdmlRectanglePageItemDto
     */
    'y': number;
    /**
     * 表示長さ
     * @type {number}
     * @memberof IdmlRectanglePageItemDto
     */
    'width': number;
    /**
     * 表示高さ
     * @type {number}
     * @memberof IdmlRectanglePageItemDto
     */
    'height': number;
    /**
     * 背景色
     * @type {object}
     * @memberof IdmlRectanglePageItemDto
     */
    'fillColor': object;
    /**
     * 枠線色
     * @type {object}
     * @memberof IdmlRectanglePageItemDto
     */
    'strokeColor': object;
    /**
     * 枠線Weight
     * @type {string}
     * @memberof IdmlRectanglePageItemDto
     */
    'strokeWeight': string;
    /**
     * 編集可能フラグ
     * @type {boolean}
     * @memberof IdmlRectanglePageItemDto
     */
    'editable': boolean;
    /**
     * 親タグID
     * @type {string}
     * @memberof IdmlRectanglePageItemDto
     */
    'parentTagId': string;
}
/**
 * 
 * @export
 * @interface IdmlTextFramePageItemDto
 */
export interface IdmlTextFramePageItemDto {
    /**
     * 種別
     * @type {string}
     * @memberof IdmlTextFramePageItemDto
     */
    'type': string;
    /**
     * SelfID
     * @type {string}
     * @memberof IdmlTextFramePageItemDto
     */
    'self': string;
    /**
     * ストーリーID
     * @type {string}
     * @memberof IdmlTextFramePageItemDto
     */
    'parentStory': string;
    /**
     * 表示X座標
     * @type {number}
     * @memberof IdmlTextFramePageItemDto
     */
    'x': number;
    /**
     * 表示Y座標
     * @type {number}
     * @memberof IdmlTextFramePageItemDto
     */
    'y': number;
    /**
     * 表示長さ
     * @type {number}
     * @memberof IdmlTextFramePageItemDto
     */
    'width': number;
    /**
     * 表示高さ
     * @type {number}
     * @memberof IdmlTextFramePageItemDto
     */
    'height': number;
    /**
     * コンテンツ
     * @type {Array<IdmlTextFramePageTextDto>}
     * @memberof IdmlTextFramePageItemDto
     */
    'texts': Array<IdmlTextFramePageTextDto>;
    /**
     * 親タグID
     * @type {string}
     * @memberof IdmlTextFramePageItemDto
     */
    'parentTagId': string;
}
/**
 * 
 * @export
 * @interface IdmlTextFramePageTextContentDto
 */
export interface IdmlTextFramePageTextContentDto {
    /**
     * コンテンツ
     * @type {string}
     * @memberof IdmlTextFramePageTextContentDto
     */
    'content': string;
    /**
     * コンテンツ色
     * @type {string}
     * @memberof IdmlTextFramePageTextContentDto
     */
    'color': string;
    /**
     * 
     * @type {boolean}
     * @memberof IdmlTextFramePageTextContentDto
     */
    'breakLine'?: boolean;
}
/**
 * 
 * @export
 * @interface IdmlTextFramePageTextDto
 */
export interface IdmlTextFramePageTextDto {
    /**
     * ストーリーID
     * @type {string}
     * @memberof IdmlTextFramePageTextDto
     */
    'parentStory': string;
    /**
     * SelfID
     * @type {string}
     * @memberof IdmlTextFramePageTextDto
     */
    'self': string;
    /**
     * タグID
     * @type {string}
     * @memberof IdmlTextFramePageTextDto
     */
    'tagId': string;
    /**
     * 文字サイズ
     * @type {number}
     * @memberof IdmlTextFramePageTextDto
     */
    'fontSize': number;
    /**
     * 文字スタイル
     * @type {string}
     * @memberof IdmlTextFramePageTextDto
     */
    'fontStyle': string;
    /**
     * 文字ファミリー
     * @type {string}
     * @memberof IdmlTextFramePageTextDto
     */
    'fontFamily': string;
    /**
     * Leading
     * @type {number}
     * @memberof IdmlTextFramePageTextDto
     */
    'leading': number;
    /**
     * Justification
     * @type {string}
     * @memberof IdmlTextFramePageTextDto
     */
    'justification': string;
    /**
     * RotateSingleByteCharacters
     * @type {boolean}
     * @memberof IdmlTextFramePageTextDto
     */
    'rotateSingleByteCharacters': boolean;
    /**
     * AutoTcy
     * @type {number}
     * @memberof IdmlTextFramePageTextDto
     */
    'autoTcy': number;
    /**
     * AutoTcyIncludeRoman
     * @type {boolean}
     * @memberof IdmlTextFramePageTextDto
     */
    'autoTcyIncludeRoman': boolean;
    /**
     * Tatechuyoko
     * @type {boolean}
     * @memberof IdmlTextFramePageTextDto
     */
    'tatechuyoko': boolean;
    /**
     * コンテンツ
     * @type {Array<IdmlTextFramePageTextContentDto>}
     * @memberof IdmlTextFramePageTextDto
     */
    'contents': Array<IdmlTextFramePageTextContentDto>;
}
/**
 * 
 * @export
 * @interface IdmlUpdateContentDetailDto
 */
export interface IdmlUpdateContentDetailDto {
    /**
     * コンテンツ内容
     * @type {string}
     * @memberof IdmlUpdateContentDetailDto
     */
    'content': string;
    /**
     * コンテンツ色
     * @type {string}
     * @memberof IdmlUpdateContentDetailDto
     */
    'color': string;
    /**
     * 
     * @type {boolean}
     * @memberof IdmlUpdateContentDetailDto
     */
    'breakLine'?: boolean;
}
/**
 * 
 * @export
 * @interface IdmlUpdateContentItemDto
 */
export interface IdmlUpdateContentItemDto {
    /**
     * タグID
     * @type {string}
     * @memberof IdmlUpdateContentItemDto
     */
    'tagId': string;
    /**
     * 編集後のテキスト詳細情報
     * @type {Array<IdmlUpdateContentDetailDto>}
     * @memberof IdmlUpdateContentItemDto
     */
    'contents': Array<IdmlUpdateContentDetailDto>;
}
/**
 * 
 * @export
 * @interface ImageCodePublicDto
 */
export interface ImageCodePublicDto {
    /**
     * アップデートする画像id
     * @type {number}
     * @memberof ImageCodePublicDto
     */
    'id': number;
    /**
     * アップデートする画像のcode
     * @type {string}
     * @memberof ImageCodePublicDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface ImportXlsDocumentDto
 */
export interface ImportXlsDocumentDto {
    /**
     * イメージパス
     * @type {string}
     * @memberof ImportXlsDocumentDto
     */
    'image': string;
    /**
     * インポート種別
     * @type {string}
     * @memberof ImportXlsDocumentDto
     */
    'importType': ImportXlsDocumentDtoImportTypeEnum;
}

export const ImportXlsDocumentDtoImportTypeEnum = {
    DraftPage: 'DRAFT_PAGE',
    Entry: 'ENTRY',
    DownloadDraftPage: 'DOWNLOAD_DRAFT_PAGE',
    DownloadDraftAssist: 'DOWNLOAD_DRAFT_ASSIST',
    DownloadDocProgress: 'DOWNLOAD_DOC_PROGRESS'
} as const;

export type ImportXlsDocumentDtoImportTypeEnum = typeof ImportXlsDocumentDtoImportTypeEnum[keyof typeof ImportXlsDocumentDtoImportTypeEnum];

/**
 * 
 * @export
 * @interface ImportXlsDocumentGroupDto
 */
export interface ImportXlsDocumentGroupDto {
    /**
     * 
     * @type {ImportXlsDocumentDto}
     * @memberof ImportXlsDocumentGroupDto
     */
    'entry': ImportXlsDocumentDto;
    /**
     * 
     * @type {ImportXlsDocumentDto}
     * @memberof ImportXlsDocumentGroupDto
     */
    'draft': ImportXlsDocumentDto;
    /**
     * 
     * @type {ImportXlsDocumentDto}
     * @memberof ImportXlsDocumentGroupDto
     */
    'download_draft_page': ImportXlsDocumentDto;
    /**
     * 
     * @type {ImportXlsDocumentDto}
     * @memberof ImportXlsDocumentGroupDto
     */
    'download_draft_assist': ImportXlsDocumentDto;
    /**
     * 
     * @type {ImportXlsDocumentDto}
     * @memberof ImportXlsDocumentGroupDto
     */
    'download_doc_progress': ImportXlsDocumentDto;
}
/**
 * 
 * @export
 * @interface ImportXlsDocumentProgressDto
 */
export interface ImportXlsDocumentProgressDto {
    /**
     * イメージパス
     * @type {string}
     * @memberof ImportXlsDocumentProgressDto
     */
    'image': string;
    /**
     * インポート種別
     * @type {string}
     * @memberof ImportXlsDocumentProgressDto
     */
    'importType': ImportXlsDocumentProgressDtoImportTypeEnum;
    /**
     * id
     * @type {number}
     * @memberof ImportXlsDocumentProgressDto
     */
    'id': number;
    /**
     * projectId
     * @type {number}
     * @memberof ImportXlsDocumentProgressDto
     */
    'projectId': number;
    /**
     * 進捗
     * @type {number}
     * @memberof ImportXlsDocumentProgressDto
     */
    'progress': number;
    /**
     * 進捗
     * @type {string}
     * @memberof ImportXlsDocumentProgressDto
     */
    'status': ImportXlsDocumentProgressDtoStatusEnum;
    /**
     * メッセージ
     * @type {string}
     * @memberof ImportXlsDocumentProgressDto
     */
    'message': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ImportXlsDocumentProgressDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ImportXlsDocumentProgressDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ImportXlsDocumentProgressDto
     */
    'deletedAt'?: string;
}

export const ImportXlsDocumentProgressDtoImportTypeEnum = {
    DraftPage: 'DRAFT_PAGE',
    Entry: 'ENTRY',
    DownloadDraftPage: 'DOWNLOAD_DRAFT_PAGE',
    DownloadDraftAssist: 'DOWNLOAD_DRAFT_ASSIST',
    DownloadDocProgress: 'DOWNLOAD_DOC_PROGRESS'
} as const;

export type ImportXlsDocumentProgressDtoImportTypeEnum = typeof ImportXlsDocumentProgressDtoImportTypeEnum[keyof typeof ImportXlsDocumentProgressDtoImportTypeEnum];
export const ImportXlsDocumentProgressDtoStatusEnum = {
    Progress: 'PROGRESS',
    Complete: 'COMPLETE',
    Error: 'ERROR',
    Cancel: 'CANCEL'
} as const;

export type ImportXlsDocumentProgressDtoStatusEnum = typeof ImportXlsDocumentProgressDtoStatusEnum[keyof typeof ImportXlsDocumentProgressDtoStatusEnum];

/**
 * 
 * @export
 * @interface ImportXlsDocumentProgressDtoWithCountDto
 */
export interface ImportXlsDocumentProgressDtoWithCountDto {
    /**
     * 
     * @type {Array<ImportXlsDocumentProgressDto>}
     * @memberof ImportXlsDocumentProgressDtoWithCountDto
     */
    'data': Array<ImportXlsDocumentProgressDto>;
    /**
     * 
     * @type {number}
     * @memberof ImportXlsDocumentProgressDtoWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ImportXlsDocumentProgressSSMDto
 */
export interface ImportXlsDocumentProgressSSMDto {
    /**
     * messageId(キャッシュ対策用)
     * @type {number}
     * @memberof ImportXlsDocumentProgressSSMDto
     */
    'id': number;
    /**
     * 
     * @type {ImportXlsDocumentProgressDto}
     * @memberof ImportXlsDocumentProgressSSMDto
     */
    'data': ImportXlsDocumentProgressDto;
}
/**
 * 
 * @export
 * @interface MainPlanRegister
 */
export interface MainPlanRegister {
    /**
     * Id Edit
     * @type {string}
     * @memberof MainPlanRegister
     */
    'idEdit': string;
    /**
     * Base64 code
     * @type {string}
     * @memberof MainPlanRegister
     */
    'saleStartDate': string;
    /**
     * Base64 code
     * @type {string}
     * @memberof MainPlanRegister
     */
    'saleEndDate': string;
    /**
     * Base64 code
     * @type {string}
     * @memberof MainPlanRegister
     */
    'mainPlanCode': string;
    /**
     * Base64 code
     * @type {string}
     * @memberof MainPlanRegister
     */
    'mainHotelCode': string;
    /**
     * 
     * @type {string}
     * @memberof MainPlanRegister
     */
    'mediaYearMonth'?: string;
}
/**
 * 
 * @export
 * @interface MasterBoastStampAttributeResponseDto
 */
export interface MasterBoastStampAttributeResponseDto {
    /**
     * 自慢スタンプコード
     * @type {string}
     * @memberof MasterBoastStampAttributeResponseDto
     */
    'code': MasterBoastStampAttributeResponseDtoCodeEnum;
    /**
     * 自慢スタンプ名称
     * @type {string}
     * @memberof MasterBoastStampAttributeResponseDto
     */
    'name': string;
    /**
     * 自慢スタンプ名称
     * @type {string}
     * @memberof MasterBoastStampAttributeResponseDto
     */
    'kana': string;
    /**
     * 自慢スタンプ表示順
     * @type {number}
     * @memberof MasterBoastStampAttributeResponseDto
     */
    'order': number;
}

export const MasterBoastStampAttributeResponseDtoCodeEnum = {
    Pride: 'PRIDE',
    Scores: 'SCORES'
} as const;

export type MasterBoastStampAttributeResponseDtoCodeEnum = typeof MasterBoastStampAttributeResponseDtoCodeEnum[keyof typeof MasterBoastStampAttributeResponseDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterDocumentSizeDto
 */
export interface MasterDocumentSizeDto {
    /**
     * 原稿サイズコード
     * @type {string}
     * @memberof MasterDocumentSizeDto
     */
    'code': MasterDocumentSizeDtoCodeEnum;
    /**
     * 原稿サイズ名
     * @type {string}
     * @memberof MasterDocumentSizeDto
     */
    'name': string;
    /**
     * 原稿サイズカナ
     * @type {string}
     * @memberof MasterDocumentSizeDto
     */
    'kana': string;
    /**
     * 原稿サイズ表示順
     * @type {number}
     * @memberof MasterDocumentSizeDto
     */
    'order': number;
}

export const MasterDocumentSizeDtoCodeEnum = {
    One: 'ONE_ONE',
    Two: 'ONE_TWO',
    Four: 'ONE_FOUR'
} as const;

export type MasterDocumentSizeDtoCodeEnum = typeof MasterDocumentSizeDtoCodeEnum[keyof typeof MasterDocumentSizeDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterDocumentStatusDto
 */
export interface MasterDocumentStatusDto {
    /**
     * 原稿ステータスコード
     * @type {string}
     * @memberof MasterDocumentStatusDto
     */
    'code': MasterDocumentStatusDtoCodeEnum;
    /**
     * 原稿ステータス名
     * @type {string}
     * @memberof MasterDocumentStatusDto
     */
    'name': string;
    /**
     * 原稿ステータスカナ
     * @type {string}
     * @memberof MasterDocumentStatusDto
     */
    'kana': string;
    /**
     * 表示順
     * @type {number}
     * @memberof MasterDocumentStatusDto
     */
    'order': number;
}

export const MasterDocumentStatusDtoCodeEnum = {
    Making: 'MAKING',
    NotStart: 'NOT_START',
    Checking: 'CHECKING',
    SendBack: 'SEND_BACK',
    Proofreading: 'PROOFREADING'
} as const;

export type MasterDocumentStatusDtoCodeEnum = typeof MasterDocumentStatusDtoCodeEnum[keyof typeof MasterDocumentStatusDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterDocumentTypeDto
 */
export interface MasterDocumentTypeDto {
    /**
     * 原稿タイプ
     * @type {string}
     * @memberof MasterDocumentTypeDto
     */
    'code': MasterDocumentTypeDtoCodeEnum;
    /**
     * 原稿タイプ名
     * @type {string}
     * @memberof MasterDocumentTypeDto
     */
    'name': string;
    /**
     * 原稿タイプカナ
     * @type {string}
     * @memberof MasterDocumentTypeDto
     */
    'kana': string;
    /**
     * 原稿タイプ表示順
     * @type {number}
     * @memberof MasterDocumentTypeDto
     */
    'order': number;
}

export const MasterDocumentTypeDtoCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    HeadLine: 'HEAD_LINE',
    Filler: 'FILLER'
} as const;

export type MasterDocumentTypeDtoCodeEnum = typeof MasterDocumentTypeDtoCodeEnum[keyof typeof MasterDocumentTypeDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterEditionCodeDto
 */
export interface MasterEditionCodeDto {
    /**
     * 版コード
     * @type {string}
     * @memberof MasterEditionCodeDto
     */
    'code': MasterEditionCodeDtoCodeEnum;
    /**
     * 版コード名
     * @type {string}
     * @memberof MasterEditionCodeDto
     */
    'name': string;
    /**
     * 版コード名
     * @type {string}
     * @memberof MasterEditionCodeDto
     */
    'kana': string;
    /**
     * 
     * @type {Array<ThumbIndexByEditionCodeDto>}
     * @memberof MasterEditionCodeDto
     */
    'thumbIndexByEditionCodes'?: Array<ThumbIndexByEditionCodeDto>;
    /**
     * 表示順
     * @type {number}
     * @memberof MasterEditionCodeDto
     */
    'order': number;
}

export const MasterEditionCodeDtoCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type MasterEditionCodeDtoCodeEnum = typeof MasterEditionCodeDtoCodeEnum[keyof typeof MasterEditionCodeDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterEditionCodePublicDto
 */
export interface MasterEditionCodePublicDto {
    /**
     * 版コード
     * @type {string}
     * @memberof MasterEditionCodePublicDto
     */
    'code': MasterEditionCodePublicDtoCodeEnum;
    /**
     * 版コード名
     * @type {string}
     * @memberof MasterEditionCodePublicDto
     */
    'name': string;
    /**
     * 版コード名
     * @type {string}
     * @memberof MasterEditionCodePublicDto
     */
    'kana': string;
    /**
     * 
     * @type {Array<ThumbIndexByEditionCodeDto>}
     * @memberof MasterEditionCodePublicDto
     */
    'thumbIndexByEditionCodes'?: Array<ThumbIndexByEditionCodeDto>;
}

export const MasterEditionCodePublicDtoCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type MasterEditionCodePublicDtoCodeEnum = typeof MasterEditionCodePublicDtoCodeEnum[keyof typeof MasterEditionCodePublicDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterMediaTypeDto
 */
export interface MasterMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof MasterMediaTypeDto
     */
    'code': MasterMediaTypeDtoCodeEnum;
    /**
     * 媒体種別名
     * @type {string}
     * @memberof MasterMediaTypeDto
     */
    'name': string;
    /**
     * 媒体種別カナ
     * @type {string}
     * @memberof MasterMediaTypeDto
     */
    'kana': string;
    /**
     * 媒体種別説明
     * @type {string}
     * @memberof MasterMediaTypeDto
     */
    'description': string;
    /**
     * 表示順
     * @type {number}
     * @memberof MasterMediaTypeDto
     */
    'order': number;
}

export const MasterMediaTypeDtoCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type MasterMediaTypeDtoCodeEnum = typeof MasterMediaTypeDtoCodeEnum[keyof typeof MasterMediaTypeDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterMediaTypePublicDto
 */
export interface MasterMediaTypePublicDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof MasterMediaTypePublicDto
     */
    'code': MasterMediaTypePublicDtoCodeEnum;
    /**
     * 媒体種別名
     * @type {string}
     * @memberof MasterMediaTypePublicDto
     */
    'name': string;
    /**
     * 媒体種別カナ
     * @type {string}
     * @memberof MasterMediaTypePublicDto
     */
    'kana': string;
    /**
     * 媒体種別説明
     * @type {string}
     * @memberof MasterMediaTypePublicDto
     */
    'description': string;
}

export const MasterMediaTypePublicDtoCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type MasterMediaTypePublicDtoCodeEnum = typeof MasterMediaTypePublicDtoCodeEnum[keyof typeof MasterMediaTypePublicDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterPageLayoutDto
 */
export interface MasterPageLayoutDto {
    /**
     * アルファベット
     * @type {string}
     * @memberof MasterPageLayoutDto
     */
    'alphabet': string;
    /**
     * レイアウト名
     * @type {string}
     * @memberof MasterPageLayoutDto
     */
    'name': string;
    /**
     * 画像パス
     * @type {string}
     * @memberof MasterPageLayoutDto
     */
    'image': string;
    /**
     * レイアウトの構成
     * @type {string}
     * @memberof MasterPageLayoutDto
     */
    'layout': string;
    /**
     * 表示順
     * @type {number}
     * @memberof MasterPageLayoutDto
     */
    'order': number;
}
/**
 * 
 * @export
 * @interface MasterPageTypeDto
 */
export interface MasterPageTypeDto {
    /**
     * ページ種別
     * @type {string}
     * @memberof MasterPageTypeDto
     */
    'code': MasterPageTypeDtoCodeEnum;
    /**
     * ページ種別名
     * @type {string}
     * @memberof MasterPageTypeDto
     */
    'name': string;
    /**
     * ページ種別名カナ
     * @type {string}
     * @memberof MasterPageTypeDto
     */
    'kana': string;
    /**
     * 表示順
     * @type {number}
     * @memberof MasterPageTypeDto
     */
    'order': number;
}

export const MasterPageTypeDtoCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    ChapterTitlePage: 'CHAPTER_TITLE_PAGE',
    Advertisement: 'ADVERTISEMENT',
    Information: 'INFORMATION'
} as const;

export type MasterPageTypeDtoCodeEnum = typeof MasterPageTypeDtoCodeEnum[keyof typeof MasterPageTypeDtoCodeEnum];

/**
 * 
 * @export
 * @interface MasterPartsClassDto
 */
export interface MasterPartsClassDto {
    /**
     * カテゴリのコード
     * @type {string}
     * @memberof MasterPartsClassDto
     */
    'code': MasterPartsClassDtoCodeEnum;
    /**
     * 名前
     * @type {string}
     * @memberof MasterPartsClassDto
     */
    'name': string;
    /**
     * カナ
     * @type {string}
     * @memberof MasterPartsClassDto
     */
    'kana': string;
    /**
     * 表示順
     * @type {number}
     * @memberof MasterPartsClassDto
     */
    'order': number;
    /**
     * 表示順
     * @type {Array<DocumentPartsCategoryDto>}
     * @memberof MasterPartsClassDto
     */
    'documentPartsCategories': Array<DocumentPartsCategoryDto>;
}

export const MasterPartsClassDtoCodeEnum = {
    Normal: 'NORMAL',
    Common: 'COMMON',
    Selection: 'SELECTION',
    Photo: 'PHOTO'
} as const;

export type MasterPartsClassDtoCodeEnum = typeof MasterPartsClassDtoCodeEnum[keyof typeof MasterPartsClassDtoCodeEnum];

/**
 * 
 * @export
 * @interface MoveDocumentDto
 */
export interface MoveDocumentDto {
    /**
     * document id
     * @type {number}
     * @memberof MoveDocumentDto
     */
    'id': number;
    /**
     * new order of document 
     * @type {number}
     * @memberof MoveDocumentDto
     */
    'order': number;
    /**
     * page id
     * @type {number}
     * @memberof MoveDocumentDto
     */
    'pageId': number;
}
/**
 * 
 * @export
 * @interface MovePageRequestDto
 */
export interface MovePageRequestDto {
    /**
     * PageId
     * @type {number}
     * @memberof MovePageRequestDto
     */
    'id': number;
    /**
     * moveToPageNumber
     * @type {number}
     * @memberof MovePageRequestDto
     */
    'moveToPageNumber': number;
}
/**
 * 
 * @export
 * @interface PageForBookletDto
 */
export interface PageForBookletDto {
    /**
     * id
     * @type {number}
     * @memberof PageForBookletDto
     */
    'id': number;
    /**
     * プロジェクトID
     * @type {number}
     * @memberof PageForBookletDto
     */
    'projectId': number;
    /**
     * 冊子ID
     * @type {number}
     * @memberof PageForBookletDto
     */
    'bookletId': number;
    /**
     * レイアウトのアルファベット
     * @type {string}
     * @memberof PageForBookletDto
     */
    'layoutAlphabet': string;
    /**
     * 
     * @type {MasterPageLayoutDto}
     * @memberof PageForBookletDto
     */
    'layout'?: MasterPageLayoutDto;
    /**
     * ページ番号
     * @type {number}
     * @memberof PageForBookletDto
     */
    'pageNumber': number;
    /**
     * 広告
     * @type {string}
     * @memberof PageForBookletDto
     */
    'pageTypeCode': PageForBookletDtoPageTypeCodeEnum;
    /**
     * 
     * @type {MasterPageTypeDto}
     * @memberof PageForBookletDto
     */
    'pageType'?: MasterPageTypeDto;
    /**
     * 欄外下画像ID
     * @type {number}
     * @memberof PageForBookletDto
     */
    'mountId': number;
    /**
     * 
     * @type {PageMountDto}
     * @memberof PageForBookletDto
     */
    'mount'?: PageMountDto;
    /**
     * つめ見出しグループID
     * @type {string}
     * @memberof PageForBookletDto
     */
    'thumbIndexImageGroupId': string;
    /**
     * イメージパス
     * @type {string}
     * @memberof PageForBookletDto
     */
    'image'?: string;
    /**
     * 作成日
     * @type {string}
     * @memberof PageForBookletDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PageForBookletDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof PageForBookletDto
     */
    'deletedAt': string;
    /**
     * 
     * @type {Array<DocumentResponseDto>}
     * @memberof PageForBookletDto
     */
    'documents': Array<DocumentResponseDto>;
}

export const PageForBookletDtoPageTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    ChapterTitlePage: 'CHAPTER_TITLE_PAGE',
    Advertisement: 'ADVERTISEMENT',
    Information: 'INFORMATION'
} as const;

export type PageForBookletDtoPageTypeCodeEnum = typeof PageForBookletDtoPageTypeCodeEnum[keyof typeof PageForBookletDtoPageTypeCodeEnum];

/**
 * 
 * @export
 * @interface PageInMyStockDto
 */
export interface PageInMyStockDto {
    /**
     * id
     * @type {number}
     * @memberof PageInMyStockDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PageInMyStockDto
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface PageMountByEditionCodeDto
 */
export interface PageMountByEditionCodeDto {
    /**
     * ID
     * @type {number}
     * @memberof PageMountByEditionCodeDto
     */
    'id': number;
    /**
     * 欄外下画像ID
     * @type {number}
     * @memberof PageMountByEditionCodeDto
     */
    'pageMountId': number;
    /**
     * 版コード
     * @type {string}
     * @memberof PageMountByEditionCodeDto
     */
    'editionCode': PageMountByEditionCodeDtoEditionCodeEnum;
    /**
     * 版毎のイメージ
     * @type {Array<PageMountImageResponseDto>}
     * @memberof PageMountByEditionCodeDto
     */
    'pageMountImages'?: Array<PageMountImageResponseDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof PageMountByEditionCodeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PageMountByEditionCodeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof PageMountByEditionCodeDto
     */
    'deletedAt'?: string;
}

export const PageMountByEditionCodeDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type PageMountByEditionCodeDtoEditionCodeEnum = typeof PageMountByEditionCodeDtoEditionCodeEnum[keyof typeof PageMountByEditionCodeDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface PageMountDto
 */
export interface PageMountDto {
    /**
     * 欄外下画像ID
     * @type {number}
     * @memberof PageMountDto
     */
    'id': number;
    /**
     * 欄外下画像名
     * @type {string}
     * @memberof PageMountDto
     */
    'name': string;
    /**
     * 作成日
     * @type {string}
     * @memberof PageMountDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PageMountDto
     */
    'modifiedAt': string;
    /**
     * 削除日(表示されない)
     * @type {string}
     * @memberof PageMountDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface PageMountImageResponseDto
 */
export interface PageMountImageResponseDto {
    /**
     * id
     * @type {number}
     * @memberof PageMountImageResponseDto
     */
    'id': number;
    /**
     * 画像パス
     * @type {string}
     * @memberof PageMountImageResponseDto
     */
    'image': string;
    /**
     * 変換画像パス
     * @type {string}
     * @memberof PageMountImageResponseDto
     */
    'imageConvert': string;
    /**
     * 画像コード
     * @type {number}
     * @memberof PageMountImageResponseDto
     */
    'code': number;
    /**
     * pageMountByEditionId
     * @type {number}
     * @memberof PageMountImageResponseDto
     */
    'pageMountByEditionId': number;
    /**
     * 作成日
     * @type {string}
     * @memberof PageMountImageResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PageMountImageResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof PageMountImageResponseDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface PageMountMediaTypeDto
 */
export interface PageMountMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof PageMountMediaTypeDto
     */
    'mediaTypeCode': PageMountMediaTypeDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof PageMountMediaTypeDto
     */
    'masterMediaType': Array<MasterMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof PageMountMediaTypeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PageMountMediaTypeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof PageMountMediaTypeDto
     */
    'deletedAt'?: string;
    /**
     * 欄外下画像ID
     * @type {number}
     * @memberof PageMountMediaTypeDto
     */
    'pageMountId': number;
}

export const PageMountMediaTypeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type PageMountMediaTypeDtoMediaTypeCodeEnum = typeof PageMountMediaTypeDtoMediaTypeCodeEnum[keyof typeof PageMountMediaTypeDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface PageMountResponseDto
 */
export interface PageMountResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof PageMountResponseDto
     */
    'id': number;
    /**
     * 欄外下画像名称
     * @type {string}
     * @memberof PageMountResponseDto
     */
    'name': string;
    /**
     * 版の配列
     * @type {Array<PageMountByEditionCodeDto>}
     * @memberof PageMountResponseDto
     */
    'pageMountByEditionCodes'?: Array<PageMountByEditionCodeDto>;
    /**
     * 欄外下画像媒体タイプの配列
     * @type {Array<PageMountMediaTypeDto>}
     * @memberof PageMountResponseDto
     */
    'pageMountMediaTypes'?: Array<PageMountMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof PageMountResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PageMountResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof PageMountResponseDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface PageMountWithCountDto
 */
export interface PageMountWithCountDto {
    /**
     * 
     * @type {Array<PageMountResponseDto>}
     * @memberof PageMountWithCountDto
     */
    'data': Array<PageMountResponseDto>;
    /**
     * そうドキュメント数
     * @type {number}
     * @memberof PageMountWithCountDto
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface PageResponseDto
 */
export interface PageResponseDto {
    /**
     * id
     * @type {number}
     * @memberof PageResponseDto
     */
    'id': number;
    /**
     * プロジェクトID
     * @type {number}
     * @memberof PageResponseDto
     */
    'projectId': number;
    /**
     * 冊子ID
     * @type {number}
     * @memberof PageResponseDto
     */
    'bookletId': number;
    /**
     * レイアウトのアルファベット
     * @type {string}
     * @memberof PageResponseDto
     */
    'layoutAlphabet': string;
    /**
     * 
     * @type {MasterPageLayoutDto}
     * @memberof PageResponseDto
     */
    'layout'?: MasterPageLayoutDto;
    /**
     * ページ番号
     * @type {number}
     * @memberof PageResponseDto
     */
    'pageNumber': number;
    /**
     * 広告
     * @type {string}
     * @memberof PageResponseDto
     */
    'pageTypeCode': PageResponseDtoPageTypeCodeEnum;
    /**
     * 
     * @type {MasterPageTypeDto}
     * @memberof PageResponseDto
     */
    'pageType'?: MasterPageTypeDto;
    /**
     * 欄外下画像ID
     * @type {number}
     * @memberof PageResponseDto
     */
    'mountId': number;
    /**
     * 
     * @type {PageMountDto}
     * @memberof PageResponseDto
     */
    'mount'?: PageMountDto;
    /**
     * つめ見出しグループID
     * @type {string}
     * @memberof PageResponseDto
     */
    'thumbIndexImageGroupId': string;
    /**
     * イメージパス
     * @type {string}
     * @memberof PageResponseDto
     */
    'image'?: string;
    /**
     * 作成日
     * @type {string}
     * @memberof PageResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PageResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof PageResponseDto
     */
    'deletedAt': string;
}

export const PageResponseDtoPageTypeCodeEnum = {
    HotelManuscript: 'HOTEL_MANUSCRIPT',
    ChapterTitlePage: 'CHAPTER_TITLE_PAGE',
    Advertisement: 'ADVERTISEMENT',
    Information: 'INFORMATION'
} as const;

export type PageResponseDtoPageTypeCodeEnum = typeof PageResponseDtoPageTypeCodeEnum[keyof typeof PageResponseDtoPageTypeCodeEnum];

/**
 * 
 * @export
 * @interface PageSettingsDto
 */
export interface PageSettingsDto {
    /**
     * 
     * @type {Array<MasterPageLayoutDto>}
     * @memberof PageSettingsDto
     */
    'layouts': Array<MasterPageLayoutDto>;
    /**
     * 
     * @type {Array<PageMountDto>}
     * @memberof PageSettingsDto
     */
    'mounts': Array<PageMountDto>;
    /**
     * 
     * @type {Array<MasterPageTypeDto>}
     * @memberof PageSettingsDto
     */
    'pageTypes': Array<MasterPageTypeDto>;
}
/**
 * 
 * @export
 * @interface Payload
 */
export interface Payload {
    /**
     * sub
     * @type {string}
     * @memberof Payload
     */
    'sub': string;
    /**
     * email_verified
     * @type {boolean}
     * @memberof Payload
     */
    'email_verified': boolean;
    /**
     * iss
     * @type {string}
     * @memberof Payload
     */
    'iss': string;
    /**
     * origin_jti
     * @type {string}
     * @memberof Payload
     */
    'origin_jti': string;
    /**
     * aud
     * @type {string}
     * @memberof Payload
     */
    'aud': string;
    /**
     * event_id
     * @type {string}
     * @memberof Payload
     */
    'event_id': string;
    /**
     * token_use
     * @type {string}
     * @memberof Payload
     */
    'token_use': string;
    /**
     * auth_time
     * @type {number}
     * @memberof Payload
     */
    'auth_time': number;
    /**
     * name
     * @type {string}
     * @memberof Payload
     */
    'name': string;
    /**
     * exp
     * @type {number}
     * @memberof Payload
     */
    'exp': number;
    /**
     * iat
     * @type {number}
     * @memberof Payload
     */
    'iat': number;
    /**
     * jti
     * @type {string}
     * @memberof Payload
     */
    'jti': string;
    /**
     * email
     * @type {string}
     * @memberof Payload
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PersonDto
 */
export interface PersonDto {
    /**
     * cognito一意のID
     * @type {string}
     * @memberof PersonDto
     */
    'personCognito': string;
    /**
     * 担当者名
     * @type {string}
     * @memberof PersonDto
     */
    'personName': string;
    /**
     * 営業担当か？
     * @type {boolean}
     * @memberof PersonDto
     */
    'isSales': boolean;
    /**
     * 編集担当か？
     * @type {boolean}
     * @memberof PersonDto
     */
    'isManuscript': boolean;
    /**
     * 権限レベル
     * @type {number}
     * @memberof PersonDto
     */
    'authorityLevel': number;
    /**
     * 退職済みか？
     * @type {boolean}
     * @memberof PersonDto
     */
    'isFired': boolean;
}
/**
 * 
 * @export
 * @interface PriceTableNeedEditId
 */
export interface PriceTableNeedEditId {
    /**
     * 
     * @type {number}
     * @memberof PriceTableNeedEditId
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof PriceTableNeedEditId
     */
    'needEditId': number;
}
/**
 * 
 * @export
 * @interface PriceTableResponseDto
 */
export interface PriceTableResponseDto {
    /**
     * id
     * @type {number}
     * @memberof PriceTableResponseDto
     */
    'id': number;
    /**
     * id
     * @type {number}
     * @memberof PriceTableResponseDto
     */
    'documentId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PriceTableResponseDto
     */
    'docId': number;
    /**
     * 
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'htmlMerge'?: string;
    /**
     * html
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'html': string;
    /**
     * hotelCode
     * @type {boolean}
     * @memberof PriceTableResponseDto
     */
    'exclusion': boolean;
    /**
     * hotelCode
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'exclusionString': string;
    /**
     * html
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'settings': string;
    /**
     * html
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'json': string;
    /**
     * 
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'jsonMerged'?: string;
    /**
     * html
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'query': string;
    /**
     * 作成日
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof PriceTableResponseDto
     */
    'deletedAt': string;
}
/**
 * 
 * @export
 * @interface PriceTableUpdateDocument
 */
export interface PriceTableUpdateDocument {
    /**
     * List of delete IDs
     * @type {Array<string>}
     * @memberof PriceTableUpdateDocument
     */
    'ids': Array<string>;
    /**
     * 
     * @type {Array<PriceTableNeedEditId>}
     * @memberof PriceTableUpdateDocument
     */
    'editIds': Array<PriceTableNeedEditId>;
    /**
     * 
     * @type {string}
     * @memberof PriceTableUpdateDocument
     */
    'documentId': string;
}
/**
 * 
 * @export
 * @interface ProjectCreatedResponseDto
 */
export interface ProjectCreatedResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof ProjectCreatedResponseDto
     */
    'id': number;
    /**
     * 媒体種別マスタ
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'mediaTypeCode': ProjectCreatedResponseDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {MasterMediaTypePublicDto}
     * @memberof ProjectCreatedResponseDto
     */
    'mediaType': MasterMediaTypePublicDto;
    /**
     * 月号 年
     * @type {number}
     * @memberof ProjectCreatedResponseDto
     */
    'issueYear': number;
    /**
     * 月号 月
     * @type {number}
     * @memberof ProjectCreatedResponseDto
     */
    'issueMonth': number;
    /**
     * 販売開始日
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'salesEndDate': string;
    /**
     * 口コミ評価開始日
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'reviewRatingStartDate': string;
    /**
     * 口コミ評価終了日
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'reviewRatingEndDate': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'deletedAt': string;
    /**
     * ツメ見出しid
     * @type {number}
     * @memberof ProjectCreatedResponseDto
     */
    'thumbIndexId': number;
    /**
     * 見出しid
     * @type {number}
     * @memberof ProjectCreatedResponseDto
     */
    'headLineId': number;
    /**
     * 露天アイコンOnパス
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'openAirIconOn': string;
    /**
     * 露天アイコンOffパス
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'openAirIconOff': string;
    /**
     * かけ流しアイコンOnパス
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'freeFlowingIconOn': string;
    /**
     * かけ流しアイコンOffパス
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'freeFlowingIconOff': string;
    /**
     * エレベーターアイコンOn
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'elevatorIconOn': string;
    /**
     * エレベーターアイコンOff
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'elevatorIconOff': string;
    /**
     * 当日予約アイコンOn
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'sameDayReservationIconOn': string;
    /**
     * 当日予約アイコンOff
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'sameDayReservationIconOff': string;
    /**
     * 送迎有アイコンOn
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'pickUpAvailableIconOn': string;
    /**
     * 送迎有アイコンOff
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'pickUpAvailableIconOff': string;
    /**
     * 禁煙アイコンOn
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'noSmokingIconOn': string;
    /**
     * 禁煙アイコンOff
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'noSmokingIconOff': string;
    /**
     * 夕食:会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'dinnerVenueMeal': string;
    /**
     * 夕食:個室会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'dinnerPrivateRoomDining': string;
    /**
     * 夕食:部屋食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'dinnerRoomMeal': string;
    /**
     * 夕食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'dinnerVenueMealOorPrivateDiningRoom': string;
    /**
     * 夕食:会場食または部屋食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'dinnerVenueMealOrRoomService': string;
    /**
     * 夕食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'dinnerRoomOrPrivateDiningRoom': string;
    /**
     * 夕食:なし
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'dinnerNone': string;
    /**
     * 朝食:会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'breakfastVenueMeal': string;
    /**
     * 朝食:個室会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'breakfastPrivateRoomDining': string;
    /**
     * 朝食:部屋食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'breakfastRoomMeal': string;
    /**
     * 朝食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'breakfastVenueMealOorPrivateDiningRoom': string;
    /**
     * 朝食:会場食または部屋食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'breakfastVenueMealOrRoomService': string;
    /**
     * 朝食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'breakfastRoomOrPrivateDiningRoom': string;
    /**
     * 朝食:なし
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'breakfastNone': string;
    /**
     * 月号データ
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'issueDataImage': string;
    /**
     * consumption tax
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'consumptionTax': ProjectCreatedResponseDtoConsumptionTaxEnum;
    /**
     * 税率
     * @type {number}
     * @memberof ProjectCreatedResponseDto
     */
    'tax': number;
    /**
     * 
     * @type {Array<BookletResponseDto>}
     * @memberof ProjectCreatedResponseDto
     */
    'booklets': Array<BookletResponseDto>;
    /**
     * 
     * @type {string}
     * @memberof ProjectCreatedResponseDto
     */
    'error': string;
}

export const ProjectCreatedResponseDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type ProjectCreatedResponseDtoMediaTypeCodeEnum = typeof ProjectCreatedResponseDtoMediaTypeCodeEnum[keyof typeof ProjectCreatedResponseDtoMediaTypeCodeEnum];
export const ProjectCreatedResponseDtoConsumptionTaxEnum = {
    Excluded: 'TAX_EXCLUDED',
    Included: 'TAX_INCLUDED'
} as const;

export type ProjectCreatedResponseDtoConsumptionTaxEnum = typeof ProjectCreatedResponseDtoConsumptionTaxEnum[keyof typeof ProjectCreatedResponseDtoConsumptionTaxEnum];

/**
 * 
 * @export
 * @interface ProjectIssueDto
 */
export interface ProjectIssueDto {
    /**
     * 月号-年
     * @type {number}
     * @memberof ProjectIssueDto
     */
    'issueYear': number;
    /**
     * 月号-月
     * @type {number}
     * @memberof ProjectIssueDto
     */
    'issueMonth': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectIssueDto
     */
    'consumptionTax'?: ProjectIssueDtoConsumptionTaxEnum;
    /**
     * 
     * @type {number}
     * @memberof ProjectIssueDto
     */
    'tax'?: number;
    /**
     * id
     * @type {number}
     * @memberof ProjectIssueDto
     */
    'id': number;
}

export const ProjectIssueDtoConsumptionTaxEnum = {
    Excluded: 'TAX_EXCLUDED',
    Included: 'TAX_INCLUDED'
} as const;

export type ProjectIssueDtoConsumptionTaxEnum = typeof ProjectIssueDtoConsumptionTaxEnum[keyof typeof ProjectIssueDtoConsumptionTaxEnum];

/**
 * 
 * @export
 * @interface ProjectIssueYearMonth
 */
export interface ProjectIssueYearMonth {
    /**
     * 
     * @type {number}
     * @memberof ProjectIssueYearMonth
     */
    'issueMonth': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectIssueYearMonth
     */
    'issueYear': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectIssueYearMonth
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface ProjectListInBookletInProjectDto
 */
export interface ProjectListInBookletInProjectDto {
    /**
     * 
     * @type {MasterMediaTypePublicDto}
     * @memberof ProjectListInBookletInProjectDto
     */
    'mediaType': MasterMediaTypePublicDto;
    /**
     * 月号 年
     * @type {number}
     * @memberof ProjectListInBookletInProjectDto
     */
    'issueYear': number;
    /**
     * 月号 月
     * @type {number}
     * @memberof ProjectListInBookletInProjectDto
     */
    'issueMonth': number;
}
/**
 * 
 * @export
 * @interface ProjectListResponseDto
 */
export interface ProjectListResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof ProjectListResponseDto
     */
    'id': number;
    /**
     * 媒体種別マスタ
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'mediaTypeCode': ProjectListResponseDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {MasterMediaTypePublicDto}
     * @memberof ProjectListResponseDto
     */
    'mediaType': MasterMediaTypePublicDto;
    /**
     * 月号 年
     * @type {number}
     * @memberof ProjectListResponseDto
     */
    'issueYear': number;
    /**
     * 月号 月
     * @type {number}
     * @memberof ProjectListResponseDto
     */
    'issueMonth': number;
    /**
     * 販売開始日
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'salesEndDate': string;
    /**
     * 口コミ評価開始日
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'reviewRatingStartDate': string;
    /**
     * 口コミ評価終了日
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'reviewRatingEndDate': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ProjectListResponseDto
     */
    'deletedAt': string;
    /**
     * 
     * @type {Array<BookletForProjectListDto>}
     * @memberof ProjectListResponseDto
     */
    'booklets': Array<BookletForProjectListDto>;
}

export const ProjectListResponseDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type ProjectListResponseDtoMediaTypeCodeEnum = typeof ProjectListResponseDtoMediaTypeCodeEnum[keyof typeof ProjectListResponseDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface ProjectResponseDto
 */
export interface ProjectResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof ProjectResponseDto
     */
    'id': number;
    /**
     * 媒体種別マスタ
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'mediaTypeCode': ProjectResponseDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {MasterMediaTypePublicDto}
     * @memberof ProjectResponseDto
     */
    'mediaType': MasterMediaTypePublicDto;
    /**
     * 月号 年
     * @type {number}
     * @memberof ProjectResponseDto
     */
    'issueYear': number;
    /**
     * 月号 月
     * @type {number}
     * @memberof ProjectResponseDto
     */
    'issueMonth': number;
    /**
     * 販売開始日
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'salesEndDate': string;
    /**
     * 口コミ評価開始日
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'reviewRatingStartDate': string;
    /**
     * 口コミ評価終了日
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'reviewRatingEndDate': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'deletedAt': string;
    /**
     * ツメ見出しid
     * @type {number}
     * @memberof ProjectResponseDto
     */
    'thumbIndexId': number;
    /**
     * 見出しid
     * @type {number}
     * @memberof ProjectResponseDto
     */
    'headLineId': number;
    /**
     * 露天アイコンOnパス
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'openAirIconOn': string;
    /**
     * 露天アイコンOffパス
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'openAirIconOff': string;
    /**
     * かけ流しアイコンOnパス
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'freeFlowingIconOn': string;
    /**
     * かけ流しアイコンOffパス
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'freeFlowingIconOff': string;
    /**
     * エレベーターアイコンOn
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'elevatorIconOn': string;
    /**
     * エレベーターアイコンOff
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'elevatorIconOff': string;
    /**
     * 当日予約アイコンOn
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'sameDayReservationIconOn': string;
    /**
     * 当日予約アイコンOff
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'sameDayReservationIconOff': string;
    /**
     * 送迎有アイコンOn
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'pickUpAvailableIconOn': string;
    /**
     * 送迎有アイコンOff
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'pickUpAvailableIconOff': string;
    /**
     * 禁煙アイコンOn
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'noSmokingIconOn': string;
    /**
     * 禁煙アイコンOff
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'noSmokingIconOff': string;
    /**
     * 夕食:会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'dinnerVenueMeal': string;
    /**
     * 夕食:個室会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'dinnerPrivateRoomDining': string;
    /**
     * 夕食:部屋食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'dinnerRoomMeal': string;
    /**
     * 夕食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'dinnerVenueMealOorPrivateDiningRoom': string;
    /**
     * 夕食:会場食または部屋食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'dinnerVenueMealOrRoomService': string;
    /**
     * 夕食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'dinnerRoomOrPrivateDiningRoom': string;
    /**
     * 夕食:なし
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'dinnerNone': string;
    /**
     * 朝食:会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'breakfastVenueMeal': string;
    /**
     * 朝食:個室会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'breakfastPrivateRoomDining': string;
    /**
     * 朝食:部屋食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'breakfastRoomMeal': string;
    /**
     * 朝食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'breakfastVenueMealOorPrivateDiningRoom': string;
    /**
     * 朝食:会場食または部屋食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'breakfastVenueMealOrRoomService': string;
    /**
     * 朝食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'breakfastRoomOrPrivateDiningRoom': string;
    /**
     * 朝食:なし
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'breakfastNone': string;
    /**
     * 月号データ
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'issueDataImage': string;
    /**
     * consumption tax
     * @type {string}
     * @memberof ProjectResponseDto
     */
    'consumptionTax': ProjectResponseDtoConsumptionTaxEnum;
    /**
     * 税率
     * @type {number}
     * @memberof ProjectResponseDto
     */
    'tax': number;
}

export const ProjectResponseDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type ProjectResponseDtoMediaTypeCodeEnum = typeof ProjectResponseDtoMediaTypeCodeEnum[keyof typeof ProjectResponseDtoMediaTypeCodeEnum];
export const ProjectResponseDtoConsumptionTaxEnum = {
    Excluded: 'TAX_EXCLUDED',
    Included: 'TAX_INCLUDED'
} as const;

export type ProjectResponseDtoConsumptionTaxEnum = typeof ProjectResponseDtoConsumptionTaxEnum[keyof typeof ProjectResponseDtoConsumptionTaxEnum];

/**
 * 
 * @export
 * @interface ProjectWithCountResponse
 */
export interface ProjectWithCountResponse {
    /**
     * 
     * @type {Array<ProjectListResponseDto>}
     * @memberof ProjectWithCountResponse
     */
    'data': Array<ProjectListResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof ProjectWithCountResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ProjectWithXlsFilesResponseDto
 */
export interface ProjectWithXlsFilesResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'id': number;
    /**
     * 媒体種別マスタ
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'mediaTypeCode': ProjectWithXlsFilesResponseDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {MasterMediaTypePublicDto}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'mediaType': MasterMediaTypePublicDto;
    /**
     * 月号 年
     * @type {number}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'issueYear': number;
    /**
     * 月号 月
     * @type {number}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'issueMonth': number;
    /**
     * 販売開始日
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'salesEndDate': string;
    /**
     * 口コミ評価開始日
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'reviewRatingStartDate': string;
    /**
     * 口コミ評価終了日
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'reviewRatingEndDate': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'deletedAt': string;
    /**
     * ツメ見出しid
     * @type {number}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'thumbIndexId': number;
    /**
     * 見出しid
     * @type {number}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'headLineId': number;
    /**
     * 露天アイコンOnパス
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'openAirIconOn': string;
    /**
     * 露天アイコンOffパス
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'openAirIconOff': string;
    /**
     * かけ流しアイコンOnパス
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'freeFlowingIconOn': string;
    /**
     * かけ流しアイコンOffパス
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'freeFlowingIconOff': string;
    /**
     * エレベーターアイコンOn
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'elevatorIconOn': string;
    /**
     * エレベーターアイコンOff
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'elevatorIconOff': string;
    /**
     * 当日予約アイコンOn
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'sameDayReservationIconOn': string;
    /**
     * 当日予約アイコンOff
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'sameDayReservationIconOff': string;
    /**
     * 送迎有アイコンOn
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'pickUpAvailableIconOn': string;
    /**
     * 送迎有アイコンOff
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'pickUpAvailableIconOff': string;
    /**
     * 禁煙アイコンOn
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'noSmokingIconOn': string;
    /**
     * 禁煙アイコンOff
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'noSmokingIconOff': string;
    /**
     * 夕食:会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'dinnerVenueMeal': string;
    /**
     * 夕食:個室会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'dinnerPrivateRoomDining': string;
    /**
     * 夕食:部屋食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'dinnerRoomMeal': string;
    /**
     * 夕食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'dinnerVenueMealOorPrivateDiningRoom': string;
    /**
     * 夕食:会場食または部屋食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'dinnerVenueMealOrRoomService': string;
    /**
     * 夕食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'dinnerRoomOrPrivateDiningRoom': string;
    /**
     * 夕食:なし
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'dinnerNone': string;
    /**
     * 朝食:会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'breakfastVenueMeal': string;
    /**
     * 朝食:個室会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'breakfastPrivateRoomDining': string;
    /**
     * 朝食:部屋食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'breakfastRoomMeal': string;
    /**
     * 朝食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'breakfastVenueMealOorPrivateDiningRoom': string;
    /**
     * 朝食:会場食または部屋食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'breakfastVenueMealOrRoomService': string;
    /**
     * 朝食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'breakfastRoomOrPrivateDiningRoom': string;
    /**
     * 朝食:なし
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'breakfastNone': string;
    /**
     * 月号データ
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'issueDataImage': string;
    /**
     * consumption tax
     * @type {string}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'consumptionTax': ProjectWithXlsFilesResponseDtoConsumptionTaxEnum;
    /**
     * 税率
     * @type {number}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'tax': number;
    /**
     * 
     * @type {Array<BookletForProjectResponseDto>}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'booklets': Array<BookletForProjectResponseDto>;
    /**
     * 
     * @type {ImportXlsDocumentGroupDto}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'xlsDocuments': ImportXlsDocumentGroupDto;
    /**
     * 
     * @type {PageMountDto}
     * @memberof ProjectWithXlsFilesResponseDto
     */
    'pageMount': PageMountDto;
}

export const ProjectWithXlsFilesResponseDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type ProjectWithXlsFilesResponseDtoMediaTypeCodeEnum = typeof ProjectWithXlsFilesResponseDtoMediaTypeCodeEnum[keyof typeof ProjectWithXlsFilesResponseDtoMediaTypeCodeEnum];
export const ProjectWithXlsFilesResponseDtoConsumptionTaxEnum = {
    Excluded: 'TAX_EXCLUDED',
    Included: 'TAX_INCLUDED'
} as const;

export type ProjectWithXlsFilesResponseDtoConsumptionTaxEnum = typeof ProjectWithXlsFilesResponseDtoConsumptionTaxEnum[keyof typeof ProjectWithXlsFilesResponseDtoConsumptionTaxEnum];

/**
 * 
 * @export
 * @interface ProjectsWithImagesResponseDto
 */
export interface ProjectsWithImagesResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof ProjectsWithImagesResponseDto
     */
    'id': number;
    /**
     * 媒体種別マスタ
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'mediaTypeCode': ProjectsWithImagesResponseDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {MasterMediaTypePublicDto}
     * @memberof ProjectsWithImagesResponseDto
     */
    'mediaType': MasterMediaTypePublicDto;
    /**
     * 月号 年
     * @type {number}
     * @memberof ProjectsWithImagesResponseDto
     */
    'issueYear': number;
    /**
     * 月号 月
     * @type {number}
     * @memberof ProjectsWithImagesResponseDto
     */
    'issueMonth': number;
    /**
     * 販売開始日
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'salesStartDate': string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'salesEndDate': string;
    /**
     * 口コミ評価開始日
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'reviewRatingStartDate': string;
    /**
     * 口コミ評価終了日
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'reviewRatingEndDate': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'deletedAt': string;
    /**
     * ツメ見出しid
     * @type {number}
     * @memberof ProjectsWithImagesResponseDto
     */
    'thumbIndexId': number;
    /**
     * 見出しid
     * @type {number}
     * @memberof ProjectsWithImagesResponseDto
     */
    'headLineId': number;
    /**
     * 露天アイコンOnパス
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'openAirIconOn': string;
    /**
     * 露天アイコンOffパス
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'openAirIconOff': string;
    /**
     * かけ流しアイコンOnパス
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'freeFlowingIconOn': string;
    /**
     * かけ流しアイコンOffパス
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'freeFlowingIconOff': string;
    /**
     * エレベーターアイコンOn
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'elevatorIconOn': string;
    /**
     * エレベーターアイコンOff
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'elevatorIconOff': string;
    /**
     * 当日予約アイコンOn
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'sameDayReservationIconOn': string;
    /**
     * 当日予約アイコンOff
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'sameDayReservationIconOff': string;
    /**
     * 送迎有アイコンOn
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'pickUpAvailableIconOn': string;
    /**
     * 送迎有アイコンOff
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'pickUpAvailableIconOff': string;
    /**
     * 禁煙アイコンOn
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'noSmokingIconOn': string;
    /**
     * 禁煙アイコンOff
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'noSmokingIconOff': string;
    /**
     * 夕食:会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'dinnerVenueMeal': string;
    /**
     * 夕食:個室会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'dinnerPrivateRoomDining': string;
    /**
     * 夕食:部屋食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'dinnerRoomMeal': string;
    /**
     * 夕食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'dinnerVenueMealOorPrivateDiningRoom': string;
    /**
     * 夕食:会場食または部屋食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'dinnerVenueMealOrRoomService': string;
    /**
     * 夕食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'dinnerRoomOrPrivateDiningRoom': string;
    /**
     * 夕食:なし
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'dinnerNone': string;
    /**
     * 朝食:会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'breakfastVenueMeal': string;
    /**
     * 朝食:個室会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'breakfastPrivateRoomDining': string;
    /**
     * 朝食:部屋食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'breakfastRoomMeal': string;
    /**
     * 朝食:会場食または個室会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'breakfastVenueMealOorPrivateDiningRoom': string;
    /**
     * 朝食:会場食または部屋食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'breakfastVenueMealOrRoomService': string;
    /**
     * 朝食:部屋食または個室会場食
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'breakfastRoomOrPrivateDiningRoom': string;
    /**
     * 朝食:なし
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'breakfastNone': string;
    /**
     * 月号データ
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'issueDataImage': string;
    /**
     * consumption tax
     * @type {string}
     * @memberof ProjectsWithImagesResponseDto
     */
    'consumptionTax': ProjectsWithImagesResponseDtoConsumptionTaxEnum;
    /**
     * 税率
     * @type {number}
     * @memberof ProjectsWithImagesResponseDto
     */
    'tax': number;
    /**
     * 
     * @type {Array<BookletForProjectResponseDto>}
     * @memberof ProjectsWithImagesResponseDto
     */
    'booklets': Array<BookletForProjectResponseDto>;
    /**
     * 
     * @type {ImportXlsDocumentGroupDto}
     * @memberof ProjectsWithImagesResponseDto
     */
    'xlsDocuments': ImportXlsDocumentGroupDto;
    /**
     * 
     * @type {PageMountDto}
     * @memberof ProjectsWithImagesResponseDto
     */
    'pageMount': PageMountDto;
    /**
     * 見出し一覧
     * @type {Array<DocumentHeadLineDto>}
     * @memberof ProjectsWithImagesResponseDto
     */
    'headLines': Array<DocumentHeadLineDto>;
    /**
     * 自慢スタンプ一覧
     * @type {Array<DocumentBoastStampResponseDto>}
     * @memberof ProjectsWithImagesResponseDto
     */
    'documentBoastStamps': Array<DocumentBoastStampResponseDto>;
    /**
     * 爪見出し一覧
     * @type {Array<ThumbIndexDto>}
     * @memberof ProjectsWithImagesResponseDto
     */
    'thumbIndexes': Array<ThumbIndexDto>;
    /**
     * 欄外下画像一覧
     * @type {Array<PageMountDto>}
     * @memberof ProjectsWithImagesResponseDto
     */
    'marginBottoms': Array<PageMountDto>;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectsWithImagesResponseDto
     */
    'allDocumentProofreading'?: boolean;
}

export const ProjectsWithImagesResponseDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type ProjectsWithImagesResponseDtoMediaTypeCodeEnum = typeof ProjectsWithImagesResponseDtoMediaTypeCodeEnum[keyof typeof ProjectsWithImagesResponseDtoMediaTypeCodeEnum];
export const ProjectsWithImagesResponseDtoConsumptionTaxEnum = {
    Excluded: 'TAX_EXCLUDED',
    Included: 'TAX_INCLUDED'
} as const;

export type ProjectsWithImagesResponseDtoConsumptionTaxEnum = typeof ProjectsWithImagesResponseDtoConsumptionTaxEnum[keyof typeof ProjectsWithImagesResponseDtoConsumptionTaxEnum];

/**
 * 
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * token
     * @type {string}
     * @memberof RefreshToken
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface RegisterPriceTableDraftDto
 */
export interface RegisterPriceTableDraftDto {
    /**
     * Pattern
     * @type {string}
     * @memberof RegisterPriceTableDraftDto
     */
    'pattern': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterPriceTableDraftDto
     */
    'needEdit'?: number;
    /**
     * entry_plan_ids
     * @type {Array<string>}
     * @memberof RegisterPriceTableDraftDto
     */
    'entry_plan_ids': Array<string>;
    /**
     * MAIN entry_plan_id
     * @type {string}
     * @memberof RegisterPriceTableDraftDto
     */
    'mainEntryPlanId'?: string;
    /**
     * MAIN plan_name (with room name) 
     * @type {string}
     * @memberof RegisterPriceTableDraftDto
     */
    'mainEntryPlanName'?: string;
    /**
     * プラン名
     * @type {Array<string>}
     * @memberof RegisterPriceTableDraftDto
     */
    'travelPlanName'?: Array<string>;
    /**
     * number_of_guests_by_room
     * @type {Array<number>}
     * @memberof RegisterPriceTableDraftDto
     */
    'numberOfGuestsByRoom': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterPriceTableDraftDto
     */
    'customNames'?: Array<string>;
    /**
     * from date
     * @type {string}
     * @memberof RegisterPriceTableDraftDto
     */
    'fromDate'?: string;
    /**
     * to date
     * @type {string}
     * @memberof RegisterPriceTableDraftDto
     */
    'toDate'?: string;
    /**
     * set period time, null or undefined if not set
     * @type {Array<object>}
     * @memberof RegisterPriceTableDraftDto
     */
    'sessions'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterPriceTableDraftDto
     */
    'exclusionDate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterPriceTableDraftDto
     */
    'isMain'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RegisterPriceTableDraftDto
     */
    'idEdit': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterPriceTableDraftDto
     */
    'elementaryPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof RegisterPriceTableDraftDto
     */
    'infantPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof RegisterPriceTableDraftDto
     */
    'mediaYearMonth'?: string;
}
/**
 * 
 * @export
 * @interface RegisterRequestDto
 */
export interface RegisterRequestDto {
    /**
     * ユーザー名
     * @type {string}
     * @memberof RegisterRequestDto
     */
    'name': string;
    /**
     * パスワード
     * @type {string}
     * @memberof RegisterRequestDto
     */
    'password': string;
    /**
     * メールアドレス
     * @type {string}
     * @memberof RegisterRequestDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface RoomTypesDto
 */
export interface RoomTypesDto {
    /**
     * 
     * @type {Array<StockControlRoomTypes>}
     * @memberof RoomTypesDto
     */
    'stockControlRoomTypes': Array<StockControlRoomTypes>;
    /**
     * 
     * @type {Array<StockControlRoomTypeBreak>}
     * @memberof RoomTypesDto
     */
    'stockControlRoomTypeBreak': Array<StockControlRoomTypeBreak>;
}
/**
 * 
 * @export
 * @interface SaveToIdmlDto
 */
export interface SaveToIdmlDto {
    /**
     * List of JSON string
     * @type {Array<string>}
     * @memberof SaveToIdmlDto
     */
    'dataJsonList': Array<string>;
    /**
     * Id Edit
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'idEdit': string;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'saleStartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'saleEndDate'?: string;
    /**
     * mainPlanCode
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'mainPlanCode'?: string;
    /**
     * mainHotelCode
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'mainHotelCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'exclusion'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'exclusionHeader'?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'hotspringfee'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'hotspringfeeBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'childFare'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'childFareBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'methodOfPayment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'methodOfPaymentBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'sameDayReservation'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'sameDayReservationBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'checkInOut'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'checkInOutBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'planRoom'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'planRoomBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'bath'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'bathBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'hotSpringQuality'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'hotSpringQualityBreakLine'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveToIdmlDto
     */
    'childPrice'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveToIdmlDto
     */
    'childPriceBreakLine'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchDocumentMyStockDto
 */
export interface SearchDocumentMyStockDto {
    /**
     * id
     * @type {number}
     * @memberof SearchDocumentMyStockDto
     */
    'id': number;
    /**
     * 発行年
     * @type {number}
     * @memberof SearchDocumentMyStockDto
     */
    'issueYear': number;
    /**
     * 発行月
     * @type {number}
     * @memberof SearchDocumentMyStockDto
     */
    'issueMonth': number;
    /**
     * 修正日
     * @type {string}
     * @memberof SearchDocumentMyStockDto
     */
    'modifiedAt': string;
    /**
     * 作成日
     * @type {string}
     * @memberof SearchDocumentMyStockDto
     */
    'createdAt': string;
    /**
     * 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
     * @type {string}
     * @memberof SearchDocumentMyStockDto
     */
    'mediaType'?: SearchDocumentMyStockDtoMediaTypeEnum;
    /**
     * 
     * @type {Array<DocumentMyStockPublicDto>}
     * @memberof SearchDocumentMyStockDto
     */
    'documentMyStocks'?: Array<DocumentMyStockPublicDto>;
}

export const SearchDocumentMyStockDtoMediaTypeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type SearchDocumentMyStockDtoMediaTypeEnum = typeof SearchDocumentMyStockDtoMediaTypeEnum[keyof typeof SearchDocumentMyStockDtoMediaTypeEnum];

/**
 * 
 * @export
 * @interface SearchParamsDto
 */
export interface SearchParamsDto {
    /**
     * 
     * @type {Array<MasterDocumentStatusDto>}
     * @memberof SearchParamsDto
     */
    'masterDocumentStatuses': Array<MasterDocumentStatusDto>;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof SearchParamsDto
     */
    'masterMediaTypes': Array<MasterMediaTypeDto>;
    /**
     * 
     * @type {Array<MasterEditionCodeDto>}
     * @memberof SearchParamsDto
     */
    'masterEditionCodes': Array<MasterEditionCodeDto>;
    /**
     * 
     * @type {Array<ProjectIssueDto>}
     * @memberof SearchParamsDto
     */
    'issues': Array<ProjectIssueDto>;
    /**
     * 
     * @type {Array<MasterDocumentSizeDto>}
     * @memberof SearchParamsDto
     */
    'masterDocumentSizes': Array<MasterDocumentSizeDto>;
    /**
     * 
     * @type {Array<PersonDto>}
     * @memberof SearchParamsDto
     */
    'salesPersons': Array<PersonDto>;
    /**
     * 
     * @type {Array<PersonDto>}
     * @memberof SearchParamsDto
     */
    'manuscriptPersons': Array<PersonDto>;
}
/**
 * 
 * @export
 * @interface StockControlRoomTypeBreak
 */
export interface StockControlRoomTypeBreak {
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypeBreak
     */
    'stock_control_room_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypeBreak
     */
    'room_type_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof StockControlRoomTypeBreak
     */
    'smoking_flag': boolean;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypeBreak
     */
    'room_type_name': string;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypeBreak
     */
    'room_type_code': string;
    /**
     * 
     * @type {number}
     * @memberof StockControlRoomTypeBreak
     */
    'room_minimum_number_of_people': number;
    /**
     * 
     * @type {number}
     * @memberof StockControlRoomTypeBreak
     */
    'room_maximum_number_of_people': number;
    /**
     * 
     * @type {number}
     * @memberof StockControlRoomTypeBreak
     */
    'number_of_rooms': number;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypeBreak
     */
    'hotel_code': string;
}
/**
 * 
 * @export
 * @interface StockControlRoomTypes
 */
export interface StockControlRoomTypes {
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypes
     */
    'stock_control_room_type_id': string;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypes
     */
    'hotel_id': string;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypes
     */
    'stock_control_room_type_code': string;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypes
     */
    'hotel_code': string;
    /**
     * 
     * @type {string}
     * @memberof StockControlRoomTypes
     */
    'stock_room_type_name': string;
}
/**
 * 
 * @export
 * @interface ThumbIndexByEditionCodeDto
 */
export interface ThumbIndexByEditionCodeDto {
    /**
     * ID
     * @type {number}
     * @memberof ThumbIndexByEditionCodeDto
     */
    'id': number;
    /**
     * 見出しID
     * @type {number}
     * @memberof ThumbIndexByEditionCodeDto
     */
    'thumbIndexId': number;
    /**
     * 版コード
     * @type {string}
     * @memberof ThumbIndexByEditionCodeDto
     */
    'editionCode': ThumbIndexByEditionCodeDtoEditionCodeEnum;
    /**
     * 
     * @type {MasterEditionCodeDto}
     * @memberof ThumbIndexByEditionCodeDto
     */
    'masterEditionCode'?: MasterEditionCodeDto;
    /**
     * 
     * @type {Array<ThumbIndexImageResponseDto>}
     * @memberof ThumbIndexByEditionCodeDto
     */
    'thumbIndexImages'?: Array<ThumbIndexImageResponseDto>;
}

export const ThumbIndexByEditionCodeDtoEditionCodeEnum = {
    Hokkaido: 'HOKKAIDO',
    Touhoku: 'TOUHOKU',
    Joshinetsu: 'JOSHINETSU',
    KitaKanto: 'KITA_KANTO',
    Kanto: 'KANTO',
    Tokai: 'TOKAI',
    Kansai: 'KANSAI',
    Hokuriku: 'HOKURIKU',
    ChugokuShikoku: 'CHUGOKU_SHIKOKU',
    Kyushu: 'KYUSHU',
    KansaiHokuriku: 'KANSAI_HOKURIKU',
    ToukaiHokuriku: 'TOUKAI_HOKURIKU',
    Test: 'TEST'
} as const;

export type ThumbIndexByEditionCodeDtoEditionCodeEnum = typeof ThumbIndexByEditionCodeDtoEditionCodeEnum[keyof typeof ThumbIndexByEditionCodeDtoEditionCodeEnum];

/**
 * 
 * @export
 * @interface ThumbIndexDto
 */
export interface ThumbIndexDto {
    /**
     * ID
     * @type {number}
     * @memberof ThumbIndexDto
     */
    'id': number;
    /**
     * 見出し名
     * @type {string}
     * @memberof ThumbIndexDto
     */
    'name': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ThumbIndexDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ThumbIndexDto
     */
    'modifiedAt': string;
    /**
     * 削除日(表示されない)
     * @type {string}
     * @memberof ThumbIndexDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface ThumbIndexImageResponseDto
 */
export interface ThumbIndexImageResponseDto {
    /**
     * id
     * @type {number}
     * @memberof ThumbIndexImageResponseDto
     */
    'id': number;
    /**
     * 画像パス
     * @type {string}
     * @memberof ThumbIndexImageResponseDto
     */
    'image': string;
    /**
     * 変換画像パス
     * @type {string}
     * @memberof ThumbIndexImageResponseDto
     */
    'imageConvert': string;
    /**
     * コード
     * @type {string}
     * @memberof ThumbIndexImageResponseDto
     */
    'code': string;
    /**
     * 版毎のid
     * @type {number}
     * @memberof ThumbIndexImageResponseDto
     */
    'thumbIndexByEditionId': number;
    /**
     * 左右フラグ
     * @type {boolean}
     * @memberof ThumbIndexImageResponseDto
     */
    'isRight': boolean;
    /**
     * グループID
     * @type {string}
     * @memberof ThumbIndexImageResponseDto
     */
    'groupId': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ThumbIndexImageResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ThumbIndexImageResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ThumbIndexImageResponseDto
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface ThumbIndexMediaTypeDto
 */
export interface ThumbIndexMediaTypeDto {
    /**
     * 媒体種別コード
     * @type {string}
     * @memberof ThumbIndexMediaTypeDto
     */
    'mediaTypeCode': ThumbIndexMediaTypeDtoMediaTypeCodeEnum;
    /**
     * 
     * @type {Array<MasterMediaTypeDto>}
     * @memberof ThumbIndexMediaTypeDto
     */
    'masterMediaType': Array<MasterMediaTypeDto>;
    /**
     * 作成日
     * @type {string}
     * @memberof ThumbIndexMediaTypeDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ThumbIndexMediaTypeDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ThumbIndexMediaTypeDto
     */
    'deletedAt'?: string;
    /**
     * ID
     * @type {number}
     * @memberof ThumbIndexMediaTypeDto
     */
    'thumbIndexId': number;
}

export const ThumbIndexMediaTypeDtoMediaTypeCodeEnum = {
    Magazine: 'MAGAZINE',
    Test: 'TEST'
} as const;

export type ThumbIndexMediaTypeDtoMediaTypeCodeEnum = typeof ThumbIndexMediaTypeDtoMediaTypeCodeEnum[keyof typeof ThumbIndexMediaTypeDtoMediaTypeCodeEnum];

/**
 * 
 * @export
 * @interface ThumbIndexResponseDto
 */
export interface ThumbIndexResponseDto {
    /**
     * ID
     * @type {number}
     * @memberof ThumbIndexResponseDto
     */
    'id': number;
    /**
     * name
     * @type {string}
     * @memberof ThumbIndexResponseDto
     */
    'name': string;
    /**
     * 作成日
     * @type {string}
     * @memberof ThumbIndexResponseDto
     */
    'createdAt': string;
    /**
     * 修正日
     * @type {string}
     * @memberof ThumbIndexResponseDto
     */
    'modifiedAt': string;
    /**
     * 削除日
     * @type {string}
     * @memberof ThumbIndexResponseDto
     */
    'deletedAt': string;
    /**
     * 
     * @type {Array<ThumbIndexByEditionCodeDto>}
     * @memberof ThumbIndexResponseDto
     */
    'thumbIndexByEditionCodes'?: Array<ThumbIndexByEditionCodeDto>;
    /**
     * 
     * @type {Array<ThumbIndexMediaTypeDto>}
     * @memberof ThumbIndexResponseDto
     */
    'thumbIndexMediaTypes'?: Array<ThumbIndexMediaTypeDto>;
}
/**
 * 
 * @export
 * @interface ThumbIndexWithCountResponse
 */
export interface ThumbIndexWithCountResponse {
    /**
     * 
     * @type {Array<ThumbIndexResponseDto>}
     * @memberof ThumbIndexWithCountResponse
     */
    'data': Array<ThumbIndexResponseDto>;
    /**
     * 
     * @type {number}
     * @memberof ThumbIndexWithCountResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface TravelPlanDto
 */
export interface TravelPlanDto {
    /**
     * travel_plan_id
     * @type {string}
     * @memberof TravelPlanDto
     */
    'travel_plan_id': string;
    /**
     * hotel_id
     * @type {string}
     * @memberof TravelPlanDto
     */
    'hotel_id': string;
    /**
     * hotel_code
     * @type {string}
     * @memberof TravelPlanDto
     */
    'hotel_code': string;
    /**
     * travel_plan_name
     * @type {string}
     * @memberof TravelPlanDto
     */
    'travel_plan_name': string;
    /**
     * travel_plan_code
     * @type {string}
     * @memberof TravelPlanDto
     */
    'travel_plan_code': string;
    /**
     * numberOfGuestByRooms
     * @type {Array<string>}
     * @memberof TravelPlanDto
     */
    'number_of_guest_by_rooms': Array<string>;
}
/**
 * 
 * @export
 * @interface TravelPlanResponseDto
 */
export interface TravelPlanResponseDto {
    /**
     * 
     * @type {string}
     * @memberof TravelPlanResponseDto
     */
    'travel_plan_id': string;
    /**
     * 
     * @type {string}
     * @memberof TravelPlanResponseDto
     */
    'travel_plan_code': string;
    /**
     * 
     * @type {string}
     * @memberof TravelPlanResponseDto
     */
    'travel_plan_name': string;
    /**
     * 
     * @type {string}
     * @memberof TravelPlanResponseDto
     */
    'travel_plan_kana_name': string;
    /**
     * 
     * @type {string}
     * @memberof TravelPlanResponseDto
     */
    'hotel_id': string;
    /**
     * 
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'reservation_stop_days': number;
    /**
     * 
     * @type {string}
     * @memberof TravelPlanResponseDto
     */
    'reservation_stop_hour': string;
    /**
     * 
     * @type {boolean}
     * @memberof TravelPlanResponseDto
     */
    'delete_flag': boolean;
    /**
     * number_of_adult
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'number_of_adult': number;
    /**
     * 
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'child_price_upper_grade_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'child_price_underclassman_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'baby_price_dinner_bedding_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'baby_price_dinner_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'baby_price_bedding_setting_type'?: number;
    /**
     * 
     * @type {number}
     * @memberof TravelPlanResponseDto
     */
    'baby_price_no_dinner_bedding_setting_type'?: number;
}
/**
 * 
 * @export
 * @interface UpdateBookletDto
 */
export interface UpdateBookletDto {
    /**
     * id
     * @type {number}
     * @memberof UpdateBookletDto
     */
    'id': number;
    /**
     * ページ数
     * @type {number}
     * @memberof UpdateBookletDto
     */
    'numberOfPages'?: number;
}
/**
 * 
 * @export
 * @interface UpdateDocumentContentDto
 */
export interface UpdateDocumentContentDto {
    /**
     * Main Hotel Code
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'mainPlanCode'?: string;
    /**
     * パターン1段目
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'row1Pattern'?: UpdateDocumentContentDtoRow1PatternEnum;
    /**
     * パターン2段目
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'row2Pattern'?: UpdateDocumentContentDtoRow2PatternEnum;
    /**
     * パターン3段目
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'row3Pattern'?: UpdateDocumentContentDtoRow3PatternEnum;
    /**
     * パターン4段目
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'row4Pattern'?: UpdateDocumentContentDtoRow4PatternEnum;
    /**
     * パターン料金表上
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'priceTableTopPattern'?: UpdateDocumentContentDtoPriceTableTopPatternEnum;
    /**
     * 販売開始日
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'salesStartDate'?: string;
    /**
     * 販売終了日
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'salesEndDate'?: string;
    /**
     * 旅行プランコード
     * @type {Array<string>}
     * @memberof UpdateDocumentContentDto
     */
    'travelPlanCode'?: Array<string>;
    /**
     * 旅行プラン名上書きテキスト
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'travelPlanNameOverwriteText'?: string;
    /**
     * 旅行プラン名を上書きするか？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'travelPlanNameOverwriteVisibility'?: boolean;
    /**
     * 入湯税・子供
     * @type {number}
     * @memberof UpdateDocumentContentDto
     */
    'bathTaxElementary'?: number;
    /**
     * 入湯税・幼児
     * @type {number}
     * @memberof UpdateDocumentContentDto
     */
    'bathTaxInfant'?: number;
    /**
     * 入湯税・大人
     * @type {number}
     * @memberof UpdateDocumentContentDto
     */
    'bathTaxAdult'?: number;
    /**
     * 入湯税を表示？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'bathTaxVisibility'?: boolean;
    /**
     * 入湯税を改行？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'bathTaxBreakLine'?: boolean;
    /**
     * 子供料金を表示？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'childrenFareVisibility'?: boolean;
    /**
     * 子供料金を改行？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'childrenFareBreakLine'?: boolean;
    /**
     * 当日予約上書きテキスト
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'sameDayReservationText'?: string;
    /**
     * 当日予約を表示？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'sameDayReservationVisibility'?: boolean;
    /**
     * 当日予約を改行？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'sameDayReservationBreakLine'?: boolean;
    /**
     * チェックイン・アウトを表示？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'checkInOutVisibility'?: boolean;
    /**
     * チェックイン・アウトを改行？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'checkInOutBreakLine'?: boolean;
    /**
     * メインプラン部屋テキスト
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'planRoomText'?: string;
    /**
     * メインプラン部屋を表示？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'planRoomVisibility'?: boolean;
    /**
     * メインプラン部屋を改行？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'planRoomBreakLine'?: boolean;
    /**
     * 風呂テキスト
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'bathText'?: string;
    /**
     * お風呂を表示？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'bathVisibility'?: boolean;
    /**
     * 風呂を改行？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'bathBreakLine'?: boolean;
    /**
     * 泉質テキスト
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'hotSpringQualityText'?: string;
    /**
     * 泉質を表示？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'hotSpringQualityVisibility'?: boolean;
    /**
     * 評価対象外？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'excludeHotSpringEvaluation'?: boolean;
    /**
     * バイキング？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'hasBikingDinner'?: boolean;
    /**
     * ペット可？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'petAllowed'?: boolean;
    /**
     * エレベータ？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'hasElevator'?: boolean;
    /**
     * ベッド？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'hasBed'?: boolean;
    /**
     * 一人予約？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'singleGuestAllowed'?: boolean;
    /**
     * 部屋食？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'hasRoomDinner'?: boolean;
    /**
     * ウォシュレット？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'hasWashlet'?: boolean;
    /**
     * 禁煙？
     * @type {boolean}
     * @memberof UpdateDocumentContentDto
     */
    'noSmoking'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'bikingDinnerStatus'?: UpdateDocumentContentDtoBikingDinnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'petAllowedStatus'?: UpdateDocumentContentDtoPetAllowedStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'bedStatus'?: UpdateDocumentContentDtoBedStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'roomDinnerStatus'?: UpdateDocumentContentDtoRoomDinnerStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'washletStatus'?: UpdateDocumentContentDtoWashletStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateDocumentContentDto
     */
    'smokingStatus'?: UpdateDocumentContentDtoSmokingStatusEnum;
}

export const UpdateDocumentContentDtoRow1PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type UpdateDocumentContentDtoRow1PatternEnum = typeof UpdateDocumentContentDtoRow1PatternEnum[keyof typeof UpdateDocumentContentDtoRow1PatternEnum];
export const UpdateDocumentContentDtoRow2PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type UpdateDocumentContentDtoRow2PatternEnum = typeof UpdateDocumentContentDtoRow2PatternEnum[keyof typeof UpdateDocumentContentDtoRow2PatternEnum];
export const UpdateDocumentContentDtoRow3PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type UpdateDocumentContentDtoRow3PatternEnum = typeof UpdateDocumentContentDtoRow3PatternEnum[keyof typeof UpdateDocumentContentDtoRow3PatternEnum];
export const UpdateDocumentContentDtoRow4PatternEnum = {
    ColumnA: 'COLUMN_A',
    ColumnB: 'COLUMN_B',
    ColumnC: 'COLUMN_C',
    ColumnD: 'COLUMN_D',
    ColumnE: 'COLUMN_E',
    ColumnF: 'COLUMN_F',
    ColumnG: 'COLUMN_G',
    ColumnH: 'COLUMN_H',
    ColumnI: 'COLUMN_I',
    ColumnHalfA: 'COLUMN_HALF_A',
    ColumnHalfB: 'COLUMN_HALF_B',
    SquareA: 'SQUARE_A',
    SquareB: 'SQUARE_B'
} as const;

export type UpdateDocumentContentDtoRow4PatternEnum = typeof UpdateDocumentContentDtoRow4PatternEnum[keyof typeof UpdateDocumentContentDtoRow4PatternEnum];
export const UpdateDocumentContentDtoPriceTableTopPatternEnum = {
    A: 'TABLE_A',
    B: 'TABLE_B',
    C: 'TABLE_C'
} as const;

export type UpdateDocumentContentDtoPriceTableTopPatternEnum = typeof UpdateDocumentContentDtoPriceTableTopPatternEnum[keyof typeof UpdateDocumentContentDtoPriceTableTopPatternEnum];
export const UpdateDocumentContentDtoBikingDinnerStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type UpdateDocumentContentDtoBikingDinnerStatusEnum = typeof UpdateDocumentContentDtoBikingDinnerStatusEnum[keyof typeof UpdateDocumentContentDtoBikingDinnerStatusEnum];
export const UpdateDocumentContentDtoPetAllowedStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type UpdateDocumentContentDtoPetAllowedStatusEnum = typeof UpdateDocumentContentDtoPetAllowedStatusEnum[keyof typeof UpdateDocumentContentDtoPetAllowedStatusEnum];
export const UpdateDocumentContentDtoBedStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type UpdateDocumentContentDtoBedStatusEnum = typeof UpdateDocumentContentDtoBedStatusEnum[keyof typeof UpdateDocumentContentDtoBedStatusEnum];
export const UpdateDocumentContentDtoRoomDinnerStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type UpdateDocumentContentDtoRoomDinnerStatusEnum = typeof UpdateDocumentContentDtoRoomDinnerStatusEnum[keyof typeof UpdateDocumentContentDtoRoomDinnerStatusEnum];
export const UpdateDocumentContentDtoWashletStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type UpdateDocumentContentDtoWashletStatusEnum = typeof UpdateDocumentContentDtoWashletStatusEnum[keyof typeof UpdateDocumentContentDtoWashletStatusEnum];
export const UpdateDocumentContentDtoSmokingStatusEnum = {
    None: 'NONE',
    Partial: 'PARTIAL',
    Full: 'FULL'
} as const;

export type UpdateDocumentContentDtoSmokingStatusEnum = typeof UpdateDocumentContentDtoSmokingStatusEnum[keyof typeof UpdateDocumentContentDtoSmokingStatusEnum];

/**
 * 
 * @export
 * @interface UpdateDocumentDto
 */
export interface UpdateDocumentDto {
    /**
     * 宿泊コード
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'hotelCode'?: string;
    /**
     * 使用テンプレートid
     * @type {number}
     * @memberof UpdateDocumentDto
     */
    'templateId'?: number;
    /**
     * 営業担当者コード
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'salesPersonCognito': string;
    /**
     * 原稿担当者コード
     * @type {string}
     * @memberof UpdateDocumentDto
     */
    'manuscriptPersonCognito': string;
}
/**
 * 
 * @export
 * @interface UpdateDocumentPartsContentDto
 */
export interface UpdateDocumentPartsContentDto {
    /**
     * Parts Content id
     * @type {number}
     * @memberof UpdateDocumentPartsContentDto
     */
    'id': number;
    /**
     * Document Parts id
     * @type {number}
     * @memberof UpdateDocumentPartsContentDto
     */
    'documentPartsId': number;
    /**
     * テンプレートによって分けられた区画の何番目かを表すインデックス
     * @type {number}
     * @memberof UpdateDocumentPartsContentDto
     */
    'templateIndex': number;
    /**
     * パターンによって分けられた区画の何番目かを表すインデックス
     * @type {number}
     * @memberof UpdateDocumentPartsContentDto
     */
    'patternIndex': number;
    /**
     * 文章
     * @type {string}
     * @memberof UpdateDocumentPartsContentDto
     */
    'text'?: string;
    /**
     * 脚注
     * @type {string}
     * @memberof UpdateDocumentPartsContentDto
     */
    'caption'?: string;
    /**
     * 画像パス
     * @type {string}
     * @memberof UpdateDocumentPartsContentDto
     */
    'imagePath'?: string;
    /**
     * 自慢スタンプ
     * @type {number}
     * @memberof UpdateDocumentPartsContentDto
     */
    'boastStampId': number;
    /**
     * パーツプランコード
     * @type {string}
     * @memberof UpdateDocumentPartsContentDto
     */
    'planCode'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDocumentStatusDto
 */
export interface UpdateDocumentStatusDto {
    /**
     * ステータスコード
     * @type {string}
     * @memberof UpdateDocumentStatusDto
     */
    'statusCode': UpdateDocumentStatusDtoStatusCodeEnum;
    /**
     * document id
     * @type {number}
     * @memberof UpdateDocumentStatusDto
     */
    'id': number;
}

export const UpdateDocumentStatusDtoStatusCodeEnum = {
    Making: 'MAKING',
    NotStart: 'NOT_START',
    Checking: 'CHECKING',
    SendBack: 'SEND_BACK',
    Proofreading: 'PROOFREADING'
} as const;

export type UpdateDocumentStatusDtoStatusCodeEnum = typeof UpdateDocumentStatusDtoStatusCodeEnum[keyof typeof UpdateDocumentStatusDtoStatusCodeEnum];

/**
 * 
 * @export
 * @interface UpdateIconItemDto
 */
export interface UpdateIconItemDto {
    /**
     * タグID
     * @type {string}
     * @memberof UpdateIconItemDto
     */
    'tagId': string;
    /**
     * アイコン名称
     * @type {string}
     * @memberof UpdateIconItemDto
     */
    'icon': string;
}
/**
 * 
 * @export
 * @interface UpdateLockDto
 */
export interface UpdateLockDto {
    /**
     * id
     * @type {number}
     * @memberof UpdateLockDto
     */
    'id': number;
    /**
     * 版ロック
     * @type {boolean}
     * @memberof UpdateLockDto
     */
    'locked': boolean;
}
/**
 * 
 * @export
 * @interface UpdateManyDocumentStatusDto
 */
export interface UpdateManyDocumentStatusDto {
    /**
     * ステータスコード
     * @type {string}
     * @memberof UpdateManyDocumentStatusDto
     */
    'statusCode': UpdateManyDocumentStatusDtoStatusCodeEnum;
    /**
     * document id
     * @type {Array<number>}
     * @memberof UpdateManyDocumentStatusDto
     */
    'ids': Array<number>;
}

export const UpdateManyDocumentStatusDtoStatusCodeEnum = {
    Making: 'MAKING',
    NotStart: 'NOT_START',
    Checking: 'CHECKING',
    SendBack: 'SEND_BACK',
    Proofreading: 'PROOFREADING'
} as const;

export type UpdateManyDocumentStatusDtoStatusCodeEnum = typeof UpdateManyDocumentStatusDtoStatusCodeEnum[keyof typeof UpdateManyDocumentStatusDtoStatusCodeEnum];

/**
 * 
 * @export
 * @interface UpdateWorkspaceContentRequestDto
 */
export interface UpdateWorkspaceContentRequestDto {
    /**
     * 編集ID
     * @type {string}
     * @memberof UpdateWorkspaceContentRequestDto
     */
    'editId': string;
    /**
     * パッケージID
     * @type {string}
     * @memberof UpdateWorkspaceContentRequestDto
     */
    'packageId': string;
    /**
     * 編集後のテキスト情報
     * @type {Array<IdmlUpdateContentItemDto>}
     * @memberof UpdateWorkspaceContentRequestDto
     */
    'items': Array<IdmlUpdateContentItemDto>;
}
/**
 * 
 * @export
 * @interface UpdateWorkspaceIconsRequestDto
 */
export interface UpdateWorkspaceIconsRequestDto {
    /**
     * 編集ID
     * @type {string}
     * @memberof UpdateWorkspaceIconsRequestDto
     */
    'editId': string;
    /**
     * パッケージID
     * @type {string}
     * @memberof UpdateWorkspaceIconsRequestDto
     */
    'packageId': string;
    /**
     * 編集後のテキスト
     * @type {Array<UpdateIconItemDto>}
     * @memberof UpdateWorkspaceIconsRequestDto
     */
    'icons': Array<UpdateIconItemDto>;
}
/**
 * 
 * @export
 * @interface VerifyCodeRequestDto
 */
export interface VerifyCodeRequestDto {
    /**
     * ユーザー名
     * @type {string}
     * @memberof VerifyCodeRequestDto
     */
    'name': string;
    /**
     * 確認コード
     * @type {string}
     * @memberof VerifyCodeRequestDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface VerifyResponseDto
 */
export interface VerifyResponseDto {
    /**
     * message
     * @type {string}
     * @memberof VerifyResponseDto
     */
    'ok': string;
    /**
     * email
     * @type {string}
     * @memberof VerifyResponseDto
     */
    'email': string;
    /**
     * cognito:groups
     * @type {Array<string>}
     * @memberof VerifyResponseDto
     */
    'cognito:groups': Array<string>;
}
/**
 * 
 * @export
 * @interface WorkspaceCommonResponse
 */
export interface WorkspaceCommonResponse {
    /**
     * ステータス
     * @type {number}
     * @memberof WorkspaceCommonResponse
     */
    'status': number;
    /**
     * 応答メッセージ
     * @type {string}
     * @memberof WorkspaceCommonResponse
     */
    'message': string;
}

/**
 * AuthorizesApi - axios parameter creator
 * @export
 */
export const AuthorizesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary エクスルードロールチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerCheckForAdminRole: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/authorizes/check-role-ng`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ユーザー認証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerCheckForAuthorization: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/authorizes/check-auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary インクルードロールチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerCheckForLimitedRole: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/authorizes/check-role-ok`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT-auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ログイン処理
         * @param {AuthenticateRequestDto} authenticateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerLogin: async (authenticateRequestDto: AuthenticateRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticateRequestDto' is not null or undefined
            assertParamExists('authorizeControllerLogin', 'authenticateRequestDto', authenticateRequestDto)
            const localVarPath = `/v1/authorizes/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ユーザー登録
         * @param {RegisterRequestDto} registerRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerRegister: async (registerRequestDto: RegisterRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequestDto' is not null or undefined
            assertParamExists('authorizeControllerRegister', 'registerRequestDto', registerRequestDto)
            const localVarPath = `/v1/authorizes/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ユーザー確認
         * @param {VerifyCodeRequestDto} verifyCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerVerify: async (verifyCodeRequestDto: VerifyCodeRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyCodeRequestDto' is not null or undefined
            assertParamExists('authorizeControllerVerify', 'verifyCodeRequestDto', verifyCodeRequestDto)
            const localVarPath = `/v1/authorizes/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizesApi - functional programming interface
 * @export
 */
export const AuthorizesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary エクスルードロールチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeControllerCheckForAdminRole(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeControllerCheckForAdminRole(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ユーザー認証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeControllerCheckForAuthorization(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerifyResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeControllerCheckForAuthorization(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary インクルードロールチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeControllerCheckForLimitedRole(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeControllerCheckForLimitedRole(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ログイン処理
         * @param {AuthenticateRequestDto} authenticateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeControllerLogin(authenticateRequestDto: AuthenticateRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeControllerLogin(authenticateRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ユーザー登録
         * @param {RegisterRequestDto} registerRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeControllerRegister(registerRequestDto: RegisterRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeControllerRegister(registerRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ユーザー確認
         * @param {VerifyCodeRequestDto} verifyCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeControllerVerify(verifyCodeRequestDto: VerifyCodeRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeControllerVerify(verifyCodeRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorizesApi - factory interface
 * @export
 */
export const AuthorizesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizesApiFp(configuration)
    return {
        /**
         * 
         * @summary エクスルードロールチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerCheckForAdminRole(options?: any): AxiosPromise<string> {
            return localVarFp.authorizeControllerCheckForAdminRole(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ユーザー認証
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerCheckForAuthorization(options?: any): AxiosPromise<VerifyResponseDto> {
            return localVarFp.authorizeControllerCheckForAuthorization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary インクルードロールチェック
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerCheckForLimitedRole(options?: any): AxiosPromise<string> {
            return localVarFp.authorizeControllerCheckForLimitedRole(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ログイン処理
         * @param {AuthenticateRequestDto} authenticateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerLogin(authenticateRequestDto: AuthenticateRequestDto, options?: any): AxiosPromise<AuthorizeResponseDto> {
            return localVarFp.authorizeControllerLogin(authenticateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ユーザー登録
         * @param {RegisterRequestDto} registerRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerRegister(registerRequestDto: RegisterRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.authorizeControllerRegister(registerRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ユーザー確認
         * @param {VerifyCodeRequestDto} verifyCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeControllerVerify(verifyCodeRequestDto: VerifyCodeRequestDto, options?: any): AxiosPromise<string> {
            return localVarFp.authorizeControllerVerify(verifyCodeRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizesApi - object-oriented interface
 * @export
 * @class AuthorizesApi
 * @extends {BaseAPI}
 */
export class AuthorizesApi extends BaseAPI {
    /**
     * 
     * @summary エクスルードロールチェック
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizesApi
     */
    public authorizeControllerCheckForAdminRole(options?: AxiosRequestConfig) {
        return AuthorizesApiFp(this.configuration).authorizeControllerCheckForAdminRole(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ユーザー認証
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizesApi
     */
    public authorizeControllerCheckForAuthorization(options?: AxiosRequestConfig) {
        return AuthorizesApiFp(this.configuration).authorizeControllerCheckForAuthorization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary インクルードロールチェック
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizesApi
     */
    public authorizeControllerCheckForLimitedRole(options?: AxiosRequestConfig) {
        return AuthorizesApiFp(this.configuration).authorizeControllerCheckForLimitedRole(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ログイン処理
     * @param {AuthenticateRequestDto} authenticateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizesApi
     */
    public authorizeControllerLogin(authenticateRequestDto: AuthenticateRequestDto, options?: AxiosRequestConfig) {
        return AuthorizesApiFp(this.configuration).authorizeControllerLogin(authenticateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ユーザー登録
     * @param {RegisterRequestDto} registerRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizesApi
     */
    public authorizeControllerRegister(registerRequestDto: RegisterRequestDto, options?: AxiosRequestConfig) {
        return AuthorizesApiFp(this.configuration).authorizeControllerRegister(registerRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ユーザー確認
     * @param {VerifyCodeRequestDto} verifyCodeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizesApi
     */
    public authorizeControllerVerify(verifyCodeRequestDto: VerifyCodeRequestDto, options?: AxiosRequestConfig) {
        return AuthorizesApiFp(this.configuration).authorizeControllerVerify(verifyCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BookletsApi - axios parameter creator
 * @export
 */
export const BookletsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 冊子コピー
         * @param {CopyBookletDto} copyBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerCopyBooklet: async (copyBookletDto: CopyBookletDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'copyBookletDto' is not null or undefined
            assertParamExists('bookletControllerCopyBooklet', 'copyBookletDto', copyBookletDto)
            const localVarPath = `/v1/booklets/copy-booklet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(copyBookletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerCountDocumentByStatus: async (projectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('bookletControllerCountDocumentByStatus', 'projectId', projectId)
            const localVarPath = `/v1/booklets/test-count-by-status/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 冊子作成
         * @param {CreateBookletDto} createBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerCreate: async (createBookletDto: CreateBookletDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBookletDto' is not null or undefined
            assertParamExists('bookletControllerCreate', 'createBookletDto', createBookletDto)
            const localVarPath = `/v1/booklets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBookletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 冊子削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookletControllerDelete', 'id', id)
            const localVarPath = `/v1/booklets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 冊子取得(ページと原稿も含んで)
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bookletControllerGet', 'id', id)
            const localVarPath = `/v1/booklets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 冊子進捗状況
         * @param {number} projectId 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerProgressAggregation: async (projectId: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('bookletControllerProgressAggregation', 'projectId', projectId)
            const localVarPath = `/v1/booklets/progress-aggregation/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 冊子検索
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] 版コード
         * @param {Array<'MAGAZINE' | 'TEST'>} [mediaTypeCodes] 媒体種別
         * @param {Array<string>} [issueYearMonth] 月号年月&#x3D;&gt;バックエンド側でパースする(2022-01or2022/01)
         * @param {string} [bookletModifiedAtFrom] 冊子最終更新日From
         * @param {string} [bookletModifiedAtTo] 冊子最終更新日To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerSearch: async (editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, mediaTypeCodes?: Array<'MAGAZINE' | 'TEST'>, issueYearMonth?: Array<string>, bookletModifiedAtFrom?: string, bookletModifiedAtTo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/booklets/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (editionCodes) {
                localVarQueryParameter['editionCodes'] = editionCodes;
            }

            if (mediaTypeCodes) {
                localVarQueryParameter['mediaTypeCodes'] = mediaTypeCodes;
            }

            if (issueYearMonth) {
                localVarQueryParameter['issueYearMonth'] = issueYearMonth;
            }

            if (bookletModifiedAtFrom !== undefined) {
                localVarQueryParameter['bookletModifiedAtFrom'] = (bookletModifiedAtFrom as any instanceof Date) ?
                    (bookletModifiedAtFrom as any).toISOString() :
                    bookletModifiedAtFrom;
            }

            if (bookletModifiedAtTo !== undefined) {
                localVarQueryParameter['bookletModifiedAtTo'] = (bookletModifiedAtTo as any instanceof Date) ?
                    (bookletModifiedAtTo as any).toISOString() :
                    bookletModifiedAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 冊子更新
         * @param {UpdateBookletDto} updateBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerUpdate: async (updateBookletDto: UpdateBookletDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateBookletDto' is not null or undefined
            assertParamExists('bookletControllerUpdate', 'updateBookletDto', updateBookletDto)
            const localVarPath = `/v1/booklets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBookletDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 入稿ロック
         * @param {UpdateLockDto} updateLockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerUpdateLock: async (updateLockDto: UpdateLockDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateLockDto' is not null or undefined
            assertParamExists('bookletControllerUpdateLock', 'updateLockDto', updateLockDto)
            const localVarPath = `/v1/booklets/update-locked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLockDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookletsApi - functional programming interface
 * @export
 */
export const BookletsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookletsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 冊子コピー
         * @param {CopyBookletDto} copyBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerCopyBooklet(copyBookletDto: CopyBookletDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookletResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerCopyBooklet(copyBookletDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerCountDocumentByStatus(projectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerCountDocumentByStatus(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 冊子作成
         * @param {CreateBookletDto} createBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerCreate(createBookletDto: CreateBookletDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookletResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerCreate(createBookletDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 冊子削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookletResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 冊子取得(ページと原稿も含んで)
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookletDetailResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 冊子進捗状況
         * @param {number} projectId 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerProgressAggregation(projectId: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BookletProgressAggregationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerProgressAggregation(projectId, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 冊子検索
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] 版コード
         * @param {Array<'MAGAZINE' | 'TEST'>} [mediaTypeCodes] 媒体種別
         * @param {Array<string>} [issueYearMonth] 月号年月&#x3D;&gt;バックエンド側でパースする(2022-01or2022/01)
         * @param {string} [bookletModifiedAtFrom] 冊子最終更新日From
         * @param {string} [bookletModifiedAtTo] 冊子最終更新日To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerSearch(editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, mediaTypeCodes?: Array<'MAGAZINE' | 'TEST'>, issueYearMonth?: Array<string>, bookletModifiedAtFrom?: string, bookletModifiedAtTo?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookletSearchWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerSearch(editionCodes, mediaTypeCodes, issueYearMonth, bookletModifiedAtFrom, bookletModifiedAtTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 冊子更新
         * @param {UpdateBookletDto} updateBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerUpdate(updateBookletDto: UpdateBookletDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookletResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerUpdate(updateBookletDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 入稿ロック
         * @param {UpdateLockDto} updateLockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bookletControllerUpdateLock(updateLockDto: UpdateLockDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookletResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bookletControllerUpdateLock(updateLockDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookletsApi - factory interface
 * @export
 */
export const BookletsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookletsApiFp(configuration)
    return {
        /**
         * 
         * @summary 冊子コピー
         * @param {CopyBookletDto} copyBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerCopyBooklet(copyBookletDto: CopyBookletDto, options?: any): AxiosPromise<BookletResponseDto> {
            return localVarFp.bookletControllerCopyBooklet(copyBookletDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {number} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerCountDocumentByStatus(projectId: number, options?: any): AxiosPromise<void> {
            return localVarFp.bookletControllerCountDocumentByStatus(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 冊子作成
         * @param {CreateBookletDto} createBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerCreate(createBookletDto: CreateBookletDto, options?: any): AxiosPromise<BookletResponseDto> {
            return localVarFp.bookletControllerCreate(createBookletDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 冊子削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerDelete(id: number, options?: any): AxiosPromise<BookletResponseDto> {
            return localVarFp.bookletControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 冊子取得(ページと原稿も含んで)
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerGet(id: number, options?: any): AxiosPromise<BookletDetailResponseDto> {
            return localVarFp.bookletControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 冊子進捗状況
         * @param {number} projectId 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerProgressAggregation(projectId: number, take?: number, skip?: number, options?: any): AxiosPromise<Array<BookletProgressAggregationDto>> {
            return localVarFp.bookletControllerProgressAggregation(projectId, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 冊子検索
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] 版コード
         * @param {Array<'MAGAZINE' | 'TEST'>} [mediaTypeCodes] 媒体種別
         * @param {Array<string>} [issueYearMonth] 月号年月&#x3D;&gt;バックエンド側でパースする(2022-01or2022/01)
         * @param {string} [bookletModifiedAtFrom] 冊子最終更新日From
         * @param {string} [bookletModifiedAtTo] 冊子最終更新日To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerSearch(editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, mediaTypeCodes?: Array<'MAGAZINE' | 'TEST'>, issueYearMonth?: Array<string>, bookletModifiedAtFrom?: string, bookletModifiedAtTo?: string, options?: any): AxiosPromise<BookletSearchWithCountDto> {
            return localVarFp.bookletControllerSearch(editionCodes, mediaTypeCodes, issueYearMonth, bookletModifiedAtFrom, bookletModifiedAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 冊子更新
         * @param {UpdateBookletDto} updateBookletDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerUpdate(updateBookletDto: UpdateBookletDto, options?: any): AxiosPromise<BookletResponseDto> {
            return localVarFp.bookletControllerUpdate(updateBookletDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 入稿ロック
         * @param {UpdateLockDto} updateLockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookletControllerUpdateLock(updateLockDto: UpdateLockDto, options?: any): AxiosPromise<BookletResponseDto> {
            return localVarFp.bookletControllerUpdateLock(updateLockDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookletsApi - object-oriented interface
 * @export
 * @class BookletsApi
 * @extends {BaseAPI}
 */
export class BookletsApi extends BaseAPI {
    /**
     * 
     * @summary 冊子コピー
     * @param {CopyBookletDto} copyBookletDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerCopyBooklet(copyBookletDto: CopyBookletDto, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerCopyBooklet(copyBookletDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {number} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerCountDocumentByStatus(projectId: number, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerCountDocumentByStatus(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 冊子作成
     * @param {CreateBookletDto} createBookletDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerCreate(createBookletDto: CreateBookletDto, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerCreate(createBookletDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 冊子削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerDelete(id: number, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 冊子取得(ページと原稿も含んで)
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerGet(id: number, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 冊子進捗状況
     * @param {number} projectId 
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerProgressAggregation(projectId: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerProgressAggregation(projectId, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 冊子検索
     * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] 版コード
     * @param {Array<'MAGAZINE' | 'TEST'>} [mediaTypeCodes] 媒体種別
     * @param {Array<string>} [issueYearMonth] 月号年月&#x3D;&gt;バックエンド側でパースする(2022-01or2022/01)
     * @param {string} [bookletModifiedAtFrom] 冊子最終更新日From
     * @param {string} [bookletModifiedAtTo] 冊子最終更新日To
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerSearch(editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, mediaTypeCodes?: Array<'MAGAZINE' | 'TEST'>, issueYearMonth?: Array<string>, bookletModifiedAtFrom?: string, bookletModifiedAtTo?: string, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerSearch(editionCodes, mediaTypeCodes, issueYearMonth, bookletModifiedAtFrom, bookletModifiedAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 冊子更新
     * @param {UpdateBookletDto} updateBookletDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerUpdate(updateBookletDto: UpdateBookletDto, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerUpdate(updateBookletDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 入稿ロック
     * @param {UpdateLockDto} updateLockDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookletsApi
     */
    public bookletControllerUpdateLock(updateLockDto: UpdateLockDto, options?: AxiosRequestConfig) {
        return BookletsApiFp(this.configuration).bookletControllerUpdateLock(updateLockDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConvertsApi - axios parameter creator
 * @export
 */
export const ConvertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary EPS画像変換
         * @param {File} image EPS画像
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertControllerConvertEps: async (image: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('convertControllerConvertEps', 'image', image)
            const localVarPath = `/v1/converts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConvertsApi - functional programming interface
 * @export
 */
export const ConvertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConvertsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary EPS画像変換
         * @param {File} image EPS画像
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertControllerConvertEps(image: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConvertResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertControllerConvertEps(image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConvertsApi - factory interface
 * @export
 */
export const ConvertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConvertsApiFp(configuration)
    return {
        /**
         * 
         * @summary EPS画像変換
         * @param {File} image EPS画像
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertControllerConvertEps(image: File, options?: any): AxiosPromise<ConvertResponseDto> {
            return localVarFp.convertControllerConvertEps(image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConvertsApi - object-oriented interface
 * @export
 * @class ConvertsApi
 * @extends {BaseAPI}
 */
export class ConvertsApi extends BaseAPI {
    /**
     * 
     * @summary EPS画像変換
     * @param {File} image EPS画像
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConvertsApi
     */
    public convertControllerConvertEps(image: File, options?: AxiosRequestConfig) {
        return ConvertsApiFp(this.configuration).convertControllerConvertEps(image, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentBoastStampsApi - axios parameter creator
 * @export
 */
export const DocumentBoastStampsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 自慢スタンプ作成
         * @param {string} name 自慢スタンプ名称
         * @param {File} [image] 自慢スタンプ画像
         * @param {File} [imageConvert] 自慢スタンプEPS画像
         * @param {string} [comment] 自慢スタンプ備考欄
         * @param {string} [attributeCode] 自慢スタンプ属性
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerCreateDocumentBoastStamp: async (name: string, image?: File, imageConvert?: File, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('documentBoastStampControllerCreateDocumentBoastStamp', 'name', name)
            const localVarPath = `/v1/document-boast-stamps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageConvert !== undefined) { 
                localVarFormParams.append('imageConvert', imageConvert as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
    
            if (attributeCode !== undefined) { 
                localVarFormParams.append('attributeCode', attributeCode as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自慢スタンプ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerDeleteDocumentBoastStamp: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentBoastStampControllerDeleteDocumentBoastStamp', 'id', id)
            const localVarPath = `/v1/document-boast-stamps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自慢スタンプ詳細取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerGetDocumentBoastStamp: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentBoastStampControllerGetDocumentBoastStamp', 'id', id)
            const localVarPath = `/v1/document-boast-stamps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自慢スタンプ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 自慢スタンプ名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerList: async (take?: number, skip?: number, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/document-boast-stamps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 自慢スタンプ更新
         * @param {number} id 自慢スタンプid
         * @param {File} [image] 自慢スタンプ画像
         * @param {File} [imageConvert] 自慢スタンプEPS画像
         * @param {string} [name] 自慢スタンプ名称(必須)
         * @param {string} [comment] 自慢スタンプ備考
         * @param {string} [attributeCode] 自慢スタンプ属性
         * @param {Array<string>} [mediaTypes] 媒体コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerUpdateDocumentBoastStamp: async (id: number, image?: File, imageConvert?: File, name?: string, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentBoastStampControllerUpdateDocumentBoastStamp', 'id', id)
            const localVarPath = `/v1/document-boast-stamps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageConvert !== undefined) { 
                localVarFormParams.append('imageConvert', imageConvert as any);
            }
    
            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
    
            if (attributeCode !== undefined) { 
                localVarFormParams.append('attributeCode', attributeCode as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentBoastStampsApi - functional programming interface
 * @export
 */
export const DocumentBoastStampsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentBoastStampsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 自慢スタンプ作成
         * @param {string} name 自慢スタンプ名称
         * @param {File} [image] 自慢スタンプ画像
         * @param {File} [imageConvert] 自慢スタンプEPS画像
         * @param {string} [comment] 自慢スタンプ備考欄
         * @param {string} [attributeCode] 自慢スタンプ属性
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentBoastStampControllerCreateDocumentBoastStamp(name: string, image?: File, imageConvert?: File, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentBoastStampResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentBoastStampControllerCreateDocumentBoastStamp(name, image, imageConvert, comment, attributeCode, mediaTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 自慢スタンプ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentBoastStampControllerDeleteDocumentBoastStamp(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentBoastStampResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentBoastStampControllerDeleteDocumentBoastStamp(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 自慢スタンプ詳細取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentBoastStampControllerGetDocumentBoastStamp(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentBoastStampResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentBoastStampControllerGetDocumentBoastStamp(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 自慢スタンプ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 自慢スタンプ名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentBoastStampControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentBoastStampWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentBoastStampControllerList(take, skip, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 自慢スタンプ更新
         * @param {number} id 自慢スタンプid
         * @param {File} [image] 自慢スタンプ画像
         * @param {File} [imageConvert] 自慢スタンプEPS画像
         * @param {string} [name] 自慢スタンプ名称(必須)
         * @param {string} [comment] 自慢スタンプ備考
         * @param {string} [attributeCode] 自慢スタンプ属性
         * @param {Array<string>} [mediaTypes] 媒体コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentBoastStampControllerUpdateDocumentBoastStamp(id: number, image?: File, imageConvert?: File, name?: string, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentBoastStampResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentBoastStampControllerUpdateDocumentBoastStamp(id, image, imageConvert, name, comment, attributeCode, mediaTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentBoastStampsApi - factory interface
 * @export
 */
export const DocumentBoastStampsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentBoastStampsApiFp(configuration)
    return {
        /**
         * 
         * @summary 自慢スタンプ作成
         * @param {string} name 自慢スタンプ名称
         * @param {File} [image] 自慢スタンプ画像
         * @param {File} [imageConvert] 自慢スタンプEPS画像
         * @param {string} [comment] 自慢スタンプ備考欄
         * @param {string} [attributeCode] 自慢スタンプ属性
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerCreateDocumentBoastStamp(name: string, image?: File, imageConvert?: File, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options?: any): AxiosPromise<DocumentBoastStampResponseDto> {
            return localVarFp.documentBoastStampControllerCreateDocumentBoastStamp(name, image, imageConvert, comment, attributeCode, mediaTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自慢スタンプ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerDeleteDocumentBoastStamp(id: number, options?: any): AxiosPromise<DocumentBoastStampResponseDto> {
            return localVarFp.documentBoastStampControllerDeleteDocumentBoastStamp(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自慢スタンプ詳細取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerGetDocumentBoastStamp(id: number, options?: any): AxiosPromise<DocumentBoastStampResponseDto> {
            return localVarFp.documentBoastStampControllerGetDocumentBoastStamp(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自慢スタンプ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 自慢スタンプ名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerList(take?: number, skip?: number, name?: string, options?: any): AxiosPromise<DocumentBoastStampWithCountDto> {
            return localVarFp.documentBoastStampControllerList(take, skip, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 自慢スタンプ更新
         * @param {number} id 自慢スタンプid
         * @param {File} [image] 自慢スタンプ画像
         * @param {File} [imageConvert] 自慢スタンプEPS画像
         * @param {string} [name] 自慢スタンプ名称(必須)
         * @param {string} [comment] 自慢スタンプ備考
         * @param {string} [attributeCode] 自慢スタンプ属性
         * @param {Array<string>} [mediaTypes] 媒体コード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentBoastStampControllerUpdateDocumentBoastStamp(id: number, image?: File, imageConvert?: File, name?: string, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options?: any): AxiosPromise<DocumentBoastStampResponseDto> {
            return localVarFp.documentBoastStampControllerUpdateDocumentBoastStamp(id, image, imageConvert, name, comment, attributeCode, mediaTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentBoastStampsApi - object-oriented interface
 * @export
 * @class DocumentBoastStampsApi
 * @extends {BaseAPI}
 */
export class DocumentBoastStampsApi extends BaseAPI {
    /**
     * 
     * @summary 自慢スタンプ作成
     * @param {string} name 自慢スタンプ名称
     * @param {File} [image] 自慢スタンプ画像
     * @param {File} [imageConvert] 自慢スタンプEPS画像
     * @param {string} [comment] 自慢スタンプ備考欄
     * @param {string} [attributeCode] 自慢スタンプ属性
     * @param {Array<string>} [mediaTypes] 媒体
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentBoastStampsApi
     */
    public documentBoastStampControllerCreateDocumentBoastStamp(name: string, image?: File, imageConvert?: File, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentBoastStampsApiFp(this.configuration).documentBoastStampControllerCreateDocumentBoastStamp(name, image, imageConvert, comment, attributeCode, mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自慢スタンプ削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentBoastStampsApi
     */
    public documentBoastStampControllerDeleteDocumentBoastStamp(id: number, options?: AxiosRequestConfig) {
        return DocumentBoastStampsApiFp(this.configuration).documentBoastStampControllerDeleteDocumentBoastStamp(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自慢スタンプ詳細取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentBoastStampsApi
     */
    public documentBoastStampControllerGetDocumentBoastStamp(id: number, options?: AxiosRequestConfig) {
        return DocumentBoastStampsApiFp(this.configuration).documentBoastStampControllerGetDocumentBoastStamp(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自慢スタンプ一覧取得
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {string} [name] 自慢スタンプ名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentBoastStampsApi
     */
    public documentBoastStampControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig) {
        return DocumentBoastStampsApiFp(this.configuration).documentBoastStampControllerList(take, skip, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 自慢スタンプ更新
     * @param {number} id 自慢スタンプid
     * @param {File} [image] 自慢スタンプ画像
     * @param {File} [imageConvert] 自慢スタンプEPS画像
     * @param {string} [name] 自慢スタンプ名称(必須)
     * @param {string} [comment] 自慢スタンプ備考
     * @param {string} [attributeCode] 自慢スタンプ属性
     * @param {Array<string>} [mediaTypes] 媒体コード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentBoastStampsApi
     */
    public documentBoastStampControllerUpdateDocumentBoastStamp(id: number, image?: File, imageConvert?: File, name?: string, comment?: string, attributeCode?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentBoastStampsApiFp(this.configuration).documentBoastStampControllerUpdateDocumentBoastStamp(id, image, imageConvert, name, comment, attributeCode, mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentEvaluationsApi - axios parameter creator
 * @export
 */
export const DocumentEvaluationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 評価パーツ作成
         * @param {string} name 評価パーツ名称(必須)
         * @param {string} documentSizeCode 原稿サイズコード
         * @param {File} [imageFirst] 評価パーツ今月初登場
         * @param {File} [imagePrevious] 評価パーツ前号初登場
         * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
         * @param {File} [imageWanted] 評価パーツ募集中
         * @param {File} [imageStarFillAll] 星画像（全）
         * @param {File} [imageStarFillHalf] 星画像（半）
         * @param {File} [imageStarFillNone] 星画像（無）
         * @param {File} [inDesign]  口コミ台紙 INDD
         * @param {string} [comment] 評価パーツ備考
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerCreateDocumentEvaluation: async (name: string, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('documentEvaluationControllerCreateDocumentEvaluation', 'name', name)
            // verify required parameter 'documentSizeCode' is not null or undefined
            assertParamExists('documentEvaluationControllerCreateDocumentEvaluation', 'documentSizeCode', documentSizeCode)
            const localVarPath = `/v1/document-evaluations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (imageFirst !== undefined) { 
                localVarFormParams.append('imageFirst', imageFirst as any);
            }
    
            if (imagePrevious !== undefined) { 
                localVarFormParams.append('imagePrevious', imagePrevious as any);
            }
    
            if (imagePreviousTwo !== undefined) { 
                localVarFormParams.append('imagePreviousTwo', imagePreviousTwo as any);
            }
    
            if (imageWanted !== undefined) { 
                localVarFormParams.append('imageWanted', imageWanted as any);
            }
    
            if (imageStarFillAll !== undefined) { 
                localVarFormParams.append('imageStarFillAll', imageStarFillAll as any);
            }
    
            if (imageStarFillHalf !== undefined) { 
                localVarFormParams.append('imageStarFillHalf', imageStarFillHalf as any);
            }
    
            if (imageStarFillNone !== undefined) { 
                localVarFormParams.append('imageStarFillNone', imageStarFillNone as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (inDesign !== undefined) { 
                localVarFormParams.append('inDesign', inDesign as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
            if (documentSizeCode !== undefined) { 
                localVarFormParams.append('documentSizeCode', documentSizeCode as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 評価パーツ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerDeleteDocumentEvaluation: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentEvaluationControllerDeleteDocumentEvaluation', 'id', id)
            const localVarPath = `/v1/document-evaluations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 評価詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerGetDocumentEvaluation: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentEvaluationControllerGetDocumentEvaluation', 'id', id)
            const localVarPath = `/v1/document-evaluations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 評価パーツ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 評価パーツ名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerList: async (take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/document-evaluations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (documentSizeCode !== undefined) {
                localVarQueryParameter['documentSizeCode'] = documentSizeCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 評価パーツ更新
         * @param {number} id 
         * @param {string} documentSizeCode 原稿サイズ
         * @param {File} [imageFirst] 評価パーツ今月初登場
         * @param {File} [imagePrevious] 評価パーツ前号初登場
         * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
         * @param {File} [imageWanted] 評価パーツ募集中
         * @param {File} [imageStarFillAll] 星画像（全）
         * @param {File} [imageStarFillHalf] 星画像（半）
         * @param {File} [imageStarFillNone] 星画像（無）
         * @param {string} [name] 評価パーツ名称
         * @param {File} [inDesign]  口コミ台紙 INDD
         * @param {string} [comment] 評価パーツ備考
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerUpdateDocumentEvaluation: async (id: number, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, name?: string, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentEvaluationControllerUpdateDocumentEvaluation', 'id', id)
            // verify required parameter 'documentSizeCode' is not null or undefined
            assertParamExists('documentEvaluationControllerUpdateDocumentEvaluation', 'documentSizeCode', documentSizeCode)
            const localVarPath = `/v1/document-evaluations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (imageFirst !== undefined) { 
                localVarFormParams.append('imageFirst', imageFirst as any);
            }
    
            if (imagePrevious !== undefined) { 
                localVarFormParams.append('imagePrevious', imagePrevious as any);
            }
    
            if (imagePreviousTwo !== undefined) { 
                localVarFormParams.append('imagePreviousTwo', imagePreviousTwo as any);
            }
    
            if (imageWanted !== undefined) { 
                localVarFormParams.append('imageWanted', imageWanted as any);
            }
    
            if (imageStarFillAll !== undefined) { 
                localVarFormParams.append('imageStarFillAll', imageStarFillAll as any);
            }
    
            if (imageStarFillHalf !== undefined) { 
                localVarFormParams.append('imageStarFillHalf', imageStarFillHalf as any);
            }
    
            if (imageStarFillNone !== undefined) { 
                localVarFormParams.append('imageStarFillNone', imageStarFillNone as any);
            }
    
            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (inDesign !== undefined) { 
                localVarFormParams.append('inDesign', inDesign as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
            if (documentSizeCode !== undefined) { 
                localVarFormParams.append('documentSizeCode', documentSizeCode as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentEvaluationsApi - functional programming interface
 * @export
 */
export const DocumentEvaluationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentEvaluationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 評価パーツ作成
         * @param {string} name 評価パーツ名称(必須)
         * @param {string} documentSizeCode 原稿サイズコード
         * @param {File} [imageFirst] 評価パーツ今月初登場
         * @param {File} [imagePrevious] 評価パーツ前号初登場
         * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
         * @param {File} [imageWanted] 評価パーツ募集中
         * @param {File} [imageStarFillAll] 星画像（全）
         * @param {File} [imageStarFillHalf] 星画像（半）
         * @param {File} [imageStarFillNone] 星画像（無）
         * @param {File} [inDesign]  口コミ台紙 INDD
         * @param {string} [comment] 評価パーツ備考
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentEvaluationControllerCreateDocumentEvaluation(name: string, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentEvaluationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentEvaluationControllerCreateDocumentEvaluation(name, documentSizeCode, imageFirst, imagePrevious, imagePreviousTwo, imageWanted, imageStarFillAll, imageStarFillHalf, imageStarFillNone, inDesign, comment, mediaTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 評価パーツ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentEvaluationControllerDeleteDocumentEvaluation(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentEvaluationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentEvaluationControllerDeleteDocumentEvaluation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 評価詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentEvaluationControllerGetDocumentEvaluation(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentEvaluationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentEvaluationControllerGetDocumentEvaluation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 評価パーツ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 評価パーツ名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentEvaluationControllerList(take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentEvaluationWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentEvaluationControllerList(take, skip, name, documentSizeCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 評価パーツ更新
         * @param {number} id 
         * @param {string} documentSizeCode 原稿サイズ
         * @param {File} [imageFirst] 評価パーツ今月初登場
         * @param {File} [imagePrevious] 評価パーツ前号初登場
         * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
         * @param {File} [imageWanted] 評価パーツ募集中
         * @param {File} [imageStarFillAll] 星画像（全）
         * @param {File} [imageStarFillHalf] 星画像（半）
         * @param {File} [imageStarFillNone] 星画像（無）
         * @param {string} [name] 評価パーツ名称
         * @param {File} [inDesign]  口コミ台紙 INDD
         * @param {string} [comment] 評価パーツ備考
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentEvaluationControllerUpdateDocumentEvaluation(id: number, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, name?: string, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentEvaluationResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentEvaluationControllerUpdateDocumentEvaluation(id, documentSizeCode, imageFirst, imagePrevious, imagePreviousTwo, imageWanted, imageStarFillAll, imageStarFillHalf, imageStarFillNone, name, inDesign, comment, mediaTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentEvaluationsApi - factory interface
 * @export
 */
export const DocumentEvaluationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentEvaluationsApiFp(configuration)
    return {
        /**
         * 
         * @summary 評価パーツ作成
         * @param {string} name 評価パーツ名称(必須)
         * @param {string} documentSizeCode 原稿サイズコード
         * @param {File} [imageFirst] 評価パーツ今月初登場
         * @param {File} [imagePrevious] 評価パーツ前号初登場
         * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
         * @param {File} [imageWanted] 評価パーツ募集中
         * @param {File} [imageStarFillAll] 星画像（全）
         * @param {File} [imageStarFillHalf] 星画像（半）
         * @param {File} [imageStarFillNone] 星画像（無）
         * @param {File} [inDesign]  口コミ台紙 INDD
         * @param {string} [comment] 評価パーツ備考
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerCreateDocumentEvaluation(name: string, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options?: any): AxiosPromise<DocumentEvaluationResponseDto> {
            return localVarFp.documentEvaluationControllerCreateDocumentEvaluation(name, documentSizeCode, imageFirst, imagePrevious, imagePreviousTwo, imageWanted, imageStarFillAll, imageStarFillHalf, imageStarFillNone, inDesign, comment, mediaTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 評価パーツ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerDeleteDocumentEvaluation(id: number, options?: any): AxiosPromise<DocumentEvaluationResponseDto> {
            return localVarFp.documentEvaluationControllerDeleteDocumentEvaluation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 評価詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerGetDocumentEvaluation(id: number, options?: any): AxiosPromise<DocumentEvaluationResponseDto> {
            return localVarFp.documentEvaluationControllerGetDocumentEvaluation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 評価パーツ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 評価パーツ名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerList(take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options?: any): AxiosPromise<DocumentEvaluationWithCountDto> {
            return localVarFp.documentEvaluationControllerList(take, skip, name, documentSizeCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 評価パーツ更新
         * @param {number} id 
         * @param {string} documentSizeCode 原稿サイズ
         * @param {File} [imageFirst] 評価パーツ今月初登場
         * @param {File} [imagePrevious] 評価パーツ前号初登場
         * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
         * @param {File} [imageWanted] 評価パーツ募集中
         * @param {File} [imageStarFillAll] 星画像（全）
         * @param {File} [imageStarFillHalf] 星画像（半）
         * @param {File} [imageStarFillNone] 星画像（無）
         * @param {string} [name] 評価パーツ名称
         * @param {File} [inDesign]  口コミ台紙 INDD
         * @param {string} [comment] 評価パーツ備考
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentEvaluationControllerUpdateDocumentEvaluation(id: number, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, name?: string, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options?: any): AxiosPromise<DocumentEvaluationResponseDto> {
            return localVarFp.documentEvaluationControllerUpdateDocumentEvaluation(id, documentSizeCode, imageFirst, imagePrevious, imagePreviousTwo, imageWanted, imageStarFillAll, imageStarFillHalf, imageStarFillNone, name, inDesign, comment, mediaTypes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentEvaluationsApi - object-oriented interface
 * @export
 * @class DocumentEvaluationsApi
 * @extends {BaseAPI}
 */
export class DocumentEvaluationsApi extends BaseAPI {
    /**
     * 
     * @summary 評価パーツ作成
     * @param {string} name 評価パーツ名称(必須)
     * @param {string} documentSizeCode 原稿サイズコード
     * @param {File} [imageFirst] 評価パーツ今月初登場
     * @param {File} [imagePrevious] 評価パーツ前号初登場
     * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
     * @param {File} [imageWanted] 評価パーツ募集中
     * @param {File} [imageStarFillAll] 星画像（全）
     * @param {File} [imageStarFillHalf] 星画像（半）
     * @param {File} [imageStarFillNone] 星画像（無）
     * @param {File} [inDesign]  口コミ台紙 INDD
     * @param {string} [comment] 評価パーツ備考
     * @param {Array<string>} [mediaTypes] 媒体
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentEvaluationsApi
     */
    public documentEvaluationControllerCreateDocumentEvaluation(name: string, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentEvaluationsApiFp(this.configuration).documentEvaluationControllerCreateDocumentEvaluation(name, documentSizeCode, imageFirst, imagePrevious, imagePreviousTwo, imageWanted, imageStarFillAll, imageStarFillHalf, imageStarFillNone, inDesign, comment, mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 評価パーツ削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentEvaluationsApi
     */
    public documentEvaluationControllerDeleteDocumentEvaluation(id: number, options?: AxiosRequestConfig) {
        return DocumentEvaluationsApiFp(this.configuration).documentEvaluationControllerDeleteDocumentEvaluation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 評価詳細
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentEvaluationsApi
     */
    public documentEvaluationControllerGetDocumentEvaluation(id: number, options?: AxiosRequestConfig) {
        return DocumentEvaluationsApiFp(this.configuration).documentEvaluationControllerGetDocumentEvaluation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 評価パーツ一覧取得
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {string} [name] 評価パーツ名
     * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentEvaluationsApi
     */
    public documentEvaluationControllerList(take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options?: AxiosRequestConfig) {
        return DocumentEvaluationsApiFp(this.configuration).documentEvaluationControllerList(take, skip, name, documentSizeCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 評価パーツ更新
     * @param {number} id 
     * @param {string} documentSizeCode 原稿サイズ
     * @param {File} [imageFirst] 評価パーツ今月初登場
     * @param {File} [imagePrevious] 評価パーツ前号初登場
     * @param {File} [imagePreviousTwo] 評価パーツ前々号初登場
     * @param {File} [imageWanted] 評価パーツ募集中
     * @param {File} [imageStarFillAll] 星画像（全）
     * @param {File} [imageStarFillHalf] 星画像（半）
     * @param {File} [imageStarFillNone] 星画像（無）
     * @param {string} [name] 評価パーツ名称
     * @param {File} [inDesign]  口コミ台紙 INDD
     * @param {string} [comment] 評価パーツ備考
     * @param {Array<string>} [mediaTypes] 媒体
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentEvaluationsApi
     */
    public documentEvaluationControllerUpdateDocumentEvaluation(id: number, documentSizeCode: string, imageFirst?: File, imagePrevious?: File, imagePreviousTwo?: File, imageWanted?: File, imageStarFillAll?: File, imageStarFillHalf?: File, imageStarFillNone?: File, name?: string, inDesign?: File, comment?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentEvaluationsApiFp(this.configuration).documentEvaluationControllerUpdateDocumentEvaluation(id, documentSizeCode, imageFirst, imagePrevious, imagePreviousTwo, imageWanted, imageStarFillAll, imageStarFillHalf, imageStarFillNone, name, inDesign, comment, mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentFillersApi - axios parameter creator
 * @export
 */
export const DocumentFillersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 埋め草作成
         * @param {string} code コード
         * @param {string} name 名称
         * @param {string} documentSizeCode 原稿サイズ
         * @param {File} [image] 画像パス
         * @param {File} [imageConvert] 変換済み画像パス
         * @param {string} [freeWord] 自由入力欄
         * @param {string} [comment] 備考欄
         * @param {Array<string>} [mediaTypes] 媒体種別
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerCreate: async (code: string, name: string, documentSizeCode: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('documentFillerControllerCreate', 'code', code)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('documentFillerControllerCreate', 'name', name)
            // verify required parameter 'documentSizeCode' is not null or undefined
            assertParamExists('documentFillerControllerCreate', 'documentSizeCode', documentSizeCode)
            const localVarPath = `/v1/document-fillers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (code !== undefined) { 
                localVarFormParams.append('code', code as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageConvert !== undefined) { 
                localVarFormParams.append('imageConvert', imageConvert as any);
            }
    
            if (freeWord !== undefined) { 
                localVarFormParams.append('freeWord', freeWord as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
            if (documentSizeCode !== undefined) { 
                localVarFormParams.append('documentSizeCode', documentSizeCode as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 埋め草削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentFillerControllerDelete', 'id', id)
            const localVarPath = `/v1/document-fillers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 埋草詳細取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerDetail: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentFillerControllerDetail', 'id', id)
            const localVarPath = `/v1/document-fillers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 埋草一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 検索ワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerList: async (take?: number, skip?: number, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/document-fillers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 埋め草更新
         * @param {number} id id
         * @param {string} [code] 埋草コード
         * @param {string} [name] 埋め草名称
         * @param {File} [image] 画像パス
         * @param {File} [imageConvert] 変換済み画像パス
         * @param {string} [freeWord] 自由入力欄
         * @param {string} [comment] 備考欄
         * @param {Array<string>} [mediaTypes] 媒体種別
         * @param {string} [documentSizeCode] 原稿サイズ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerUpdate: async (id: number, code?: string, name?: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, documentSizeCode?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentFillerControllerUpdate', 'id', id)
            const localVarPath = `/v1/document-fillers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (code !== undefined) { 
                localVarFormParams.append('code', code as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageConvert !== undefined) { 
                localVarFormParams.append('imageConvert', imageConvert as any);
            }
    
            if (freeWord !== undefined) { 
                localVarFormParams.append('freeWord', freeWord as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
            if (documentSizeCode !== undefined) { 
                localVarFormParams.append('documentSizeCode', documentSizeCode as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentFillersApi - functional programming interface
 * @export
 */
export const DocumentFillersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentFillersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 埋め草作成
         * @param {string} code コード
         * @param {string} name 名称
         * @param {string} documentSizeCode 原稿サイズ
         * @param {File} [image] 画像パス
         * @param {File} [imageConvert] 変換済み画像パス
         * @param {string} [freeWord] 自由入力欄
         * @param {string} [comment] 備考欄
         * @param {Array<string>} [mediaTypes] 媒体種別
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentFillerControllerCreate(code: string, name: string, documentSizeCode: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFillerWithSizeMediaType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentFillerControllerCreate(code, name, documentSizeCode, image, imageConvert, freeWord, comment, mediaTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 埋め草削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentFillerControllerDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFillerWithSizeMediaType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentFillerControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 埋草詳細取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentFillerControllerDetail(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFillerWithSizeMediaType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentFillerControllerDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 埋草一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 検索ワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentFillerControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFillerWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentFillerControllerList(take, skip, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 埋め草更新
         * @param {number} id id
         * @param {string} [code] 埋草コード
         * @param {string} [name] 埋め草名称
         * @param {File} [image] 画像パス
         * @param {File} [imageConvert] 変換済み画像パス
         * @param {string} [freeWord] 自由入力欄
         * @param {string} [comment] 備考欄
         * @param {Array<string>} [mediaTypes] 媒体種別
         * @param {string} [documentSizeCode] 原稿サイズ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentFillerControllerUpdate(id: number, code?: string, name?: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, documentSizeCode?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentFillerWithSizeMediaType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentFillerControllerUpdate(id, code, name, image, imageConvert, freeWord, comment, mediaTypes, documentSizeCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentFillersApi - factory interface
 * @export
 */
export const DocumentFillersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentFillersApiFp(configuration)
    return {
        /**
         * 
         * @summary 埋め草作成
         * @param {string} code コード
         * @param {string} name 名称
         * @param {string} documentSizeCode 原稿サイズ
         * @param {File} [image] 画像パス
         * @param {File} [imageConvert] 変換済み画像パス
         * @param {string} [freeWord] 自由入力欄
         * @param {string} [comment] 備考欄
         * @param {Array<string>} [mediaTypes] 媒体種別
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerCreate(code: string, name: string, documentSizeCode: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, options?: any): AxiosPromise<DocumentFillerWithSizeMediaType> {
            return localVarFp.documentFillerControllerCreate(code, name, documentSizeCode, image, imageConvert, freeWord, comment, mediaTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 埋め草削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerDelete(id: number, options?: any): AxiosPromise<DocumentFillerWithSizeMediaType> {
            return localVarFp.documentFillerControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 埋草詳細取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerDetail(id: number, options?: any): AxiosPromise<DocumentFillerWithSizeMediaType> {
            return localVarFp.documentFillerControllerDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 埋草一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 検索ワード
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerList(take?: number, skip?: number, name?: string, options?: any): AxiosPromise<DocumentFillerWithCountDto> {
            return localVarFp.documentFillerControllerList(take, skip, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 埋め草更新
         * @param {number} id id
         * @param {string} [code] 埋草コード
         * @param {string} [name] 埋め草名称
         * @param {File} [image] 画像パス
         * @param {File} [imageConvert] 変換済み画像パス
         * @param {string} [freeWord] 自由入力欄
         * @param {string} [comment] 備考欄
         * @param {Array<string>} [mediaTypes] 媒体種別
         * @param {string} [documentSizeCode] 原稿サイズ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentFillerControllerUpdate(id: number, code?: string, name?: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, documentSizeCode?: string, options?: any): AxiosPromise<DocumentFillerWithSizeMediaType> {
            return localVarFp.documentFillerControllerUpdate(id, code, name, image, imageConvert, freeWord, comment, mediaTypes, documentSizeCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentFillersApi - object-oriented interface
 * @export
 * @class DocumentFillersApi
 * @extends {BaseAPI}
 */
export class DocumentFillersApi extends BaseAPI {
    /**
     * 
     * @summary 埋め草作成
     * @param {string} code コード
     * @param {string} name 名称
     * @param {string} documentSizeCode 原稿サイズ
     * @param {File} [image] 画像パス
     * @param {File} [imageConvert] 変換済み画像パス
     * @param {string} [freeWord] 自由入力欄
     * @param {string} [comment] 備考欄
     * @param {Array<string>} [mediaTypes] 媒体種別
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFillersApi
     */
    public documentFillerControllerCreate(code: string, name: string, documentSizeCode: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentFillersApiFp(this.configuration).documentFillerControllerCreate(code, name, documentSizeCode, image, imageConvert, freeWord, comment, mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 埋め草削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFillersApi
     */
    public documentFillerControllerDelete(id: number, options?: AxiosRequestConfig) {
        return DocumentFillersApiFp(this.configuration).documentFillerControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 埋草詳細取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFillersApi
     */
    public documentFillerControllerDetail(id: number, options?: AxiosRequestConfig) {
        return DocumentFillersApiFp(this.configuration).documentFillerControllerDetail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 埋草一覧取得
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {string} [name] 検索ワード
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFillersApi
     */
    public documentFillerControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig) {
        return DocumentFillersApiFp(this.configuration).documentFillerControllerList(take, skip, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 埋め草更新
     * @param {number} id id
     * @param {string} [code] 埋草コード
     * @param {string} [name] 埋め草名称
     * @param {File} [image] 画像パス
     * @param {File} [imageConvert] 変換済み画像パス
     * @param {string} [freeWord] 自由入力欄
     * @param {string} [comment] 備考欄
     * @param {Array<string>} [mediaTypes] 媒体種別
     * @param {string} [documentSizeCode] 原稿サイズ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFillersApi
     */
    public documentFillerControllerUpdate(id: number, code?: string, name?: string, image?: File, imageConvert?: File, freeWord?: string, comment?: string, mediaTypes?: Array<string>, documentSizeCode?: string, options?: AxiosRequestConfig) {
        return DocumentFillersApiFp(this.configuration).documentFillerControllerUpdate(id, code, name, image, imageConvert, freeWord, comment, mediaTypes, documentSizeCode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentHeadLinesApi - axios parameter creator
 * @export
 */
export const DocumentHeadLinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 見出し作成
         * @param {string} name 見出し名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<string>} [codes] code1,code2 in the above order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerCreate: async (name: string, mediaTypes?: Array<string>, editionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('documentHeadLineControllerCreate', 'name', name)
            const localVarPath = `/v1/document-head-lines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

                if (editionCodes) {
                localVarFormParams.append('editionCodes', editionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

                if (codes) {
                localVarFormParams.append('codes', codes.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 見出し削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentHeadLineControllerDelete', 'id', id)
            const localVarPath = `/v1/document-head-lines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 見出しイメージ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerDeleteImage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentHeadLineControllerDeleteImage', 'id', id)
            const localVarPath = `/v1/document-head-lines/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 見出し取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerGetById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentHeadLineControllerGetById', 'id', id)
            const localVarPath = `/v1/document-head-lines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 見出し一覧
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 見出し名称
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerList: async (take?: number, skip?: number, name?: string, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/document-head-lines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (editionCodes) {
                localVarQueryParameter['editionCodes'] = editionCodes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 見出し更新
         * @param {number} id 
         * @param {string} [name] 見出し名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 登録順にcodeを追加する更新しない場合はnull
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerUpdate: async (id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentHeadLineControllerUpdate', 'id', id)
            const localVarPath = `/v1/document-head-lines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

                if (imageIds) {
                localVarFormParams.append('imageIds', imageIds.join(COLLECTION_FORMATS.csv));
            }

                if (editionCodes) {
                localVarFormParams.append('editionCodes', editionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (deleteEditionCodes) {
                localVarFormParams.append('deleteEditionCodes', deleteEditionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

                if (codes) {
                localVarFormParams.append('codes', codes.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 見出しの版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} documentHeadLineId documentHeadLineId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerUpdateEditionByCode: async (editionCode: string, documentHeadLineId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionCode' is not null or undefined
            assertParamExists('documentHeadLineControllerUpdateEditionByCode', 'editionCode', editionCode)
            // verify required parameter 'documentHeadLineId' is not null or undefined
            assertParamExists('documentHeadLineControllerUpdateEditionByCode', 'documentHeadLineId', documentHeadLineId)
            const localVarPath = `/v1/document-head-lines/edition-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (editionCode !== undefined) { 
                localVarFormParams.append('editionCode', editionCode as any);
            }
                if (imageIds) {
                localVarFormParams.append('imageIds', imageIds.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

                if (codes) {
                localVarFormParams.append('codes', codes.join(COLLECTION_FORMATS.csv));
            }

    
            if (documentHeadLineId !== undefined) { 
                localVarFormParams.append('documentHeadLineId', documentHeadLineId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 見出し画像コードアップデート
         * @param {ImageCodePublicDto} imageCodePublicDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerUpdateImageCode: async (imageCodePublicDto: ImageCodePublicDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageCodePublicDto' is not null or undefined
            assertParamExists('documentHeadLineControllerUpdateImageCode', 'imageCodePublicDto', imageCodePublicDto)
            const localVarPath = `/v1/document-head-lines/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageCodePublicDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentHeadLinesApi - functional programming interface
 * @export
 */
export const DocumentHeadLinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentHeadLinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 見出し作成
         * @param {string} name 見出し名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<string>} [codes] code1,code2 in the above order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerCreate(name: string, mediaTypes?: Array<string>, editionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerCreate(name, mediaTypes, editionCodes, images, imageConverts, codes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 見出し削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 見出しイメージ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerDeleteImage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerDeleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 見出し取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerGetById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerGetById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 見出し一覧
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 見出し名称
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerList(take?: number, skip?: number, name?: string, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerList(take, skip, name, editionCodes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 見出し更新
         * @param {number} id 
         * @param {string} [name] 見出し名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 登録順にcodeを追加する更新しない場合はnull
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerUpdate(id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerUpdate(id, name, mediaTypes, imageIds, editionCodes, deleteEditionCodes, images, imageConverts, codes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 見出しの版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} documentHeadLineId documentHeadLineId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerUpdateEditionByCode(editionCode: string, documentHeadLineId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerUpdateEditionByCode(editionCode, documentHeadLineId, imageIds, images, imageConverts, codes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 見出し画像コードアップデート
         * @param {ImageCodePublicDto} imageCodePublicDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentHeadLineControllerUpdateImageCode(imageCodePublicDto: ImageCodePublicDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentHeadLineImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentHeadLineControllerUpdateImageCode(imageCodePublicDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentHeadLinesApi - factory interface
 * @export
 */
export const DocumentHeadLinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentHeadLinesApiFp(configuration)
    return {
        /**
         * 
         * @summary 見出し作成
         * @param {string} name 見出し名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<string>} [codes] code1,code2 in the above order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerCreate(name: string, mediaTypes?: Array<string>, editionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: any): AxiosPromise<DocumentHeadLineResponseDto> {
            return localVarFp.documentHeadLineControllerCreate(name, mediaTypes, editionCodes, images, imageConverts, codes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 見出し削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerDelete(id: number, options?: any): AxiosPromise<DocumentHeadLineResponseDto> {
            return localVarFp.documentHeadLineControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 見出しイメージ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerDeleteImage(id: number, options?: any): AxiosPromise<DocumentHeadLineImageResponseDto> {
            return localVarFp.documentHeadLineControllerDeleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 見出し取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerGetById(id: number, options?: any): AxiosPromise<DocumentHeadLineResponseDto> {
            return localVarFp.documentHeadLineControllerGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 見出し一覧
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 見出し名称
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerList(take?: number, skip?: number, name?: string, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options?: any): AxiosPromise<DocumentHeadLineWithCountDto> {
            return localVarFp.documentHeadLineControllerList(take, skip, name, editionCodes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 見出し更新
         * @param {number} id 
         * @param {string} [name] 見出し名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 登録順にcodeを追加する更新しない場合はnull
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerUpdate(id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: any): AxiosPromise<DocumentHeadLineResponseDto> {
            return localVarFp.documentHeadLineControllerUpdate(id, name, mediaTypes, imageIds, editionCodes, deleteEditionCodes, images, imageConverts, codes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 見出しの版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} documentHeadLineId documentHeadLineId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerUpdateEditionByCode(editionCode: string, documentHeadLineId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: any): AxiosPromise<DocumentHeadLineResponseDto> {
            return localVarFp.documentHeadLineControllerUpdateEditionByCode(editionCode, documentHeadLineId, imageIds, images, imageConverts, codes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 見出し画像コードアップデート
         * @param {ImageCodePublicDto} imageCodePublicDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentHeadLineControllerUpdateImageCode(imageCodePublicDto: ImageCodePublicDto, options?: any): AxiosPromise<DocumentHeadLineImageResponseDto> {
            return localVarFp.documentHeadLineControllerUpdateImageCode(imageCodePublicDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentHeadLinesApi - object-oriented interface
 * @export
 * @class DocumentHeadLinesApi
 * @extends {BaseAPI}
 */
export class DocumentHeadLinesApi extends BaseAPI {
    /**
     * 
     * @summary 見出し作成
     * @param {string} name 見出し名
     * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
     * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
     * @param {Array<string>} [codes] code1,code2 in the above order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerCreate(name: string, mediaTypes?: Array<string>, editionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerCreate(name, mediaTypes, editionCodes, images, imageConverts, codes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 見出し削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerDelete(id: number, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 見出しイメージ削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerDeleteImage(id: number, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerDeleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 見出し取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerGetById(id: number, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 見出し一覧
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {string} [name] 見出し名称
     * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerList(take?: number, skip?: number, name?: string, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerList(take, skip, name, editionCodes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 見出し更新
     * @param {number} id 
     * @param {string} [name] 見出し名
     * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
     * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
     * @param {Array<string>} [editionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
     * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<string>} [codes] 登録順にcodeを追加する更新しない場合はnull
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerUpdate(id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerUpdate(id, name, mediaTypes, imageIds, editionCodes, deleteEditionCodes, images, imageConverts, codes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 見出しの版&画像登録
     * @param {string} editionCode 画像ファイルを登録する版コードを指定する
     * @param {number} documentHeadLineId documentHeadLineId
     * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerUpdateEditionByCode(editionCode: string, documentHeadLineId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerUpdateEditionByCode(editionCode, documentHeadLineId, imageIds, images, imageConverts, codes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 見出し画像コードアップデート
     * @param {ImageCodePublicDto} imageCodePublicDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentHeadLinesApi
     */
    public documentHeadLineControllerUpdateImageCode(imageCodePublicDto: ImageCodePublicDto, options?: AxiosRequestConfig) {
        return DocumentHeadLinesApiFp(this.configuration).documentHeadLineControllerUpdateImageCode(imageCodePublicDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentMyStocksApi - axios parameter creator
 * @export
 */
export const DocumentMyStocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary マイストック作成
         * @param {DocumentMyStockDto} documentMyStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerCreate: async (documentMyStockDto: DocumentMyStockDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentMyStockDto' is not null or undefined
            assertParamExists('documentMyStockControllerCreate', 'documentMyStockDto', documentMyStockDto)
            const localVarPath = `/v1/document-my-stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentMyStockDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マイストック削除
         * @param {DeleteDocumentMyStockDto} deleteDocumentMyStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerDelete: async (deleteDocumentMyStockDto: DeleteDocumentMyStockDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteDocumentMyStockDto' is not null or undefined
            assertParamExists('documentMyStockControllerDelete', 'deleteDocumentMyStockDto', deleteDocumentMyStockDto)
            const localVarPath = `/v1/document-my-stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDocumentMyStockDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マイストック取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentMyStockControllerGet', 'id', id)
            const localVarPath = `/v1/document-my-stocks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary マイストック検索
         * @param {string} createPersonCognito 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerList: async (createPersonCognito: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPersonCognito' is not null or undefined
            assertParamExists('documentMyStockControllerList', 'createPersonCognito', createPersonCognito)
            const localVarPath = `/v1/document-my-stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (createPersonCognito !== undefined) {
                localVarQueryParameter['createPersonCognito'] = createPersonCognito;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentMyStocksApi - functional programming interface
 * @export
 */
export const DocumentMyStocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentMyStocksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary マイストック作成
         * @param {DocumentMyStockDto} documentMyStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentMyStockControllerCreate(documentMyStockDto: DocumentMyStockDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMyStockResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentMyStockControllerCreate(documentMyStockDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary マイストック削除
         * @param {DeleteDocumentMyStockDto} deleteDocumentMyStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentMyStockControllerDelete(deleteDocumentMyStockDto: DeleteDocumentMyStockDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMyStockResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentMyStockControllerDelete(deleteDocumentMyStockDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary マイストック取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentMyStockControllerGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMyStockPublicDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentMyStockControllerGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary マイストック検索
         * @param {string} createPersonCognito 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentMyStockControllerList(createPersonCognito: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMyStockResponseWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentMyStockControllerList(createPersonCognito, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentMyStocksApi - factory interface
 * @export
 */
export const DocumentMyStocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentMyStocksApiFp(configuration)
    return {
        /**
         * 
         * @summary マイストック作成
         * @param {DocumentMyStockDto} documentMyStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerCreate(documentMyStockDto: DocumentMyStockDto, options?: any): AxiosPromise<DocumentMyStockResponseDto> {
            return localVarFp.documentMyStockControllerCreate(documentMyStockDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マイストック削除
         * @param {DeleteDocumentMyStockDto} deleteDocumentMyStockDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerDelete(deleteDocumentMyStockDto: DeleteDocumentMyStockDto, options?: any): AxiosPromise<DocumentMyStockResponseDto> {
            return localVarFp.documentMyStockControllerDelete(deleteDocumentMyStockDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マイストック取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerGet(id: number, options?: any): AxiosPromise<DocumentMyStockPublicDto> {
            return localVarFp.documentMyStockControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary マイストック検索
         * @param {string} createPersonCognito 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentMyStockControllerList(createPersonCognito: string, take?: number, skip?: number, options?: any): AxiosPromise<DocumentMyStockResponseWithCountDto> {
            return localVarFp.documentMyStockControllerList(createPersonCognito, take, skip, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentMyStocksApi - object-oriented interface
 * @export
 * @class DocumentMyStocksApi
 * @extends {BaseAPI}
 */
export class DocumentMyStocksApi extends BaseAPI {
    /**
     * 
     * @summary マイストック作成
     * @param {DocumentMyStockDto} documentMyStockDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentMyStocksApi
     */
    public documentMyStockControllerCreate(documentMyStockDto: DocumentMyStockDto, options?: AxiosRequestConfig) {
        return DocumentMyStocksApiFp(this.configuration).documentMyStockControllerCreate(documentMyStockDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マイストック削除
     * @param {DeleteDocumentMyStockDto} deleteDocumentMyStockDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentMyStocksApi
     */
    public documentMyStockControllerDelete(deleteDocumentMyStockDto: DeleteDocumentMyStockDto, options?: AxiosRequestConfig) {
        return DocumentMyStocksApiFp(this.configuration).documentMyStockControllerDelete(deleteDocumentMyStockDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マイストック取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentMyStocksApi
     */
    public documentMyStockControllerGet(id: number, options?: AxiosRequestConfig) {
        return DocumentMyStocksApiFp(this.configuration).documentMyStockControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary マイストック検索
     * @param {string} createPersonCognito 
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentMyStocksApi
     */
    public documentMyStockControllerList(createPersonCognito: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return DocumentMyStocksApiFp(this.configuration).documentMyStockControllerList(createPersonCognito, take, skip, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentPartsApi - axios parameter creator
 * @export
 */
export const DocumentPartsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary パーツ作成
         * @param {string} documentPartsClass 種別
         * @param {number} documentPartsCategoryId カテゴリid
         * @param {string} documentSizeCode 原稿サイズ
         * @param {string} name パーツ名称
         * @param {File} [imageThumbnail] サムネイル
         * @param {File} [inDesignFile] インデザインファイル
         * @param {string} [comment] パーツ内容
         * @param {string} [freeWord] パーツ備考
         * @param {boolean} [canUse] 不可&#x3D;false
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerCreateDocumentParts: async (documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, name: string, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentPartsClass' is not null or undefined
            assertParamExists('documentPartsControllerCreateDocumentParts', 'documentPartsClass', documentPartsClass)
            // verify required parameter 'documentPartsCategoryId' is not null or undefined
            assertParamExists('documentPartsControllerCreateDocumentParts', 'documentPartsCategoryId', documentPartsCategoryId)
            // verify required parameter 'documentSizeCode' is not null or undefined
            assertParamExists('documentPartsControllerCreateDocumentParts', 'documentSizeCode', documentSizeCode)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('documentPartsControllerCreateDocumentParts', 'name', name)
            const localVarPath = `/v1/document-parts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (imageThumbnail !== undefined) { 
                localVarFormParams.append('imageThumbnail', imageThumbnail as any);
            }
    
            if (inDesignFile !== undefined) { 
                localVarFormParams.append('inDesignFile', inDesignFile as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
    
            if (freeWord !== undefined) { 
                localVarFormParams.append('freeWord', freeWord as any);
            }
    
            if (canUse !== undefined) { 
                localVarFormParams.append('canUse', canUse as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
            if (documentPartsClass !== undefined) { 
                localVarFormParams.append('documentPartsClass', documentPartsClass as any);
            }
    
            if (documentPartsCategoryId !== undefined) { 
                localVarFormParams.append('documentPartsCategoryId', documentPartsCategoryId as any);
            }
    
            if (documentSizeCode !== undefined) { 
                localVarFormParams.append('documentSizeCode', documentSizeCode as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツデータ作成
         * @param {CreateDocumentPartsContentDto} createDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerCreateDocumentPartsContent: async (createDocumentPartsContentDto: CreateDocumentPartsContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDocumentPartsContentDto' is not null or undefined
            assertParamExists('documentPartsControllerCreateDocumentPartsContent', 'createDocumentPartsContentDto', createDocumentPartsContentDto)
            const localVarPath = `/v1/document-parts/content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDocumentPartsContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerDeleteDocumentParts: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentPartsControllerDeleteDocumentParts', 'id', id)
            const localVarPath = `/v1/document-parts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツデータ削除
         * @param {DeleteDocumentPartsContentDto} deleteDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerDeleteDocumentPartsContent: async (deleteDocumentPartsContentDto: DeleteDocumentPartsContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteDocumentPartsContentDto' is not null or undefined
            assertParamExists('documentPartsControllerDeleteDocumentPartsContent', 'deleteDocumentPartsContentDto', deleteDocumentPartsContentDto)
            const localVarPath = `/v1/document-parts/content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteDocumentPartsContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツ詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerGetDocumentParts: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentPartsControllerGetDocumentParts', 'id', id)
            const localVarPath = `/v1/document-parts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツ種別とカテゴリ取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerGetDocumentPartsClassAndCategories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/document-parts/class-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツデータ取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerGetDocumentPartsContent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentPartsControllerGetDocumentPartsContent', 'id', id)
            const localVarPath = `/v1/document-parts/content/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 評価パーツ名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerList: async (take?: number, skip?: number, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/document-parts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツ更新
         * @param {string} documentPartsClass 種別
         * @param {number} documentPartsCategoryId カテゴリid
         * @param {string} documentSizeCode 原稿サイズ
         * @param {number} id id
         * @param {File} [imageThumbnail] サムネイル
         * @param {File} [inDesignFile] インデザインファイル
         * @param {string} [comment] パーツ内容
         * @param {string} [freeWord] パーツ備考
         * @param {boolean} [canUse] 不可&#x3D;false
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {string} [name] パーツ名称
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerUpdateDocumentParts: async (documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, id: number, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentPartsClass' is not null or undefined
            assertParamExists('documentPartsControllerUpdateDocumentParts', 'documentPartsClass', documentPartsClass)
            // verify required parameter 'documentPartsCategoryId' is not null or undefined
            assertParamExists('documentPartsControllerUpdateDocumentParts', 'documentPartsCategoryId', documentPartsCategoryId)
            // verify required parameter 'documentSizeCode' is not null or undefined
            assertParamExists('documentPartsControllerUpdateDocumentParts', 'documentSizeCode', documentSizeCode)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentPartsControllerUpdateDocumentParts', 'id', id)
            const localVarPath = `/v1/document-parts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (imageThumbnail !== undefined) { 
                localVarFormParams.append('imageThumbnail', imageThumbnail as any);
            }
    
            if (inDesignFile !== undefined) { 
                localVarFormParams.append('inDesignFile', inDesignFile as any);
            }
    
            if (comment !== undefined) { 
                localVarFormParams.append('comment', comment as any);
            }
    
            if (freeWord !== undefined) { 
                localVarFormParams.append('freeWord', freeWord as any);
            }
    
            if (canUse !== undefined) { 
                localVarFormParams.append('canUse', canUse as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

    
            if (documentPartsClass !== undefined) { 
                localVarFormParams.append('documentPartsClass', documentPartsClass as any);
            }
    
            if (documentPartsCategoryId !== undefined) { 
                localVarFormParams.append('documentPartsCategoryId', documentPartsCategoryId as any);
            }
    
            if (documentSizeCode !== undefined) { 
                localVarFormParams.append('documentSizeCode', documentSizeCode as any);
            }
    
            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary パーツデータ更新
         * @param {UpdateDocumentPartsContentDto} updateDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerUpdateDocumentPartsContent: async (updateDocumentPartsContentDto: UpdateDocumentPartsContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDocumentPartsContentDto' is not null or undefined
            assertParamExists('documentPartsControllerUpdateDocumentPartsContent', 'updateDocumentPartsContentDto', updateDocumentPartsContentDto)
            const localVarPath = `/v1/document-parts/content`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentPartsContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentPartsApi - functional programming interface
 * @export
 */
export const DocumentPartsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentPartsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary パーツ作成
         * @param {string} documentPartsClass 種別
         * @param {number} documentPartsCategoryId カテゴリid
         * @param {string} documentSizeCode 原稿サイズ
         * @param {string} name パーツ名称
         * @param {File} [imageThumbnail] サムネイル
         * @param {File} [inDesignFile] インデザインファイル
         * @param {string} [comment] パーツ内容
         * @param {string} [freeWord] パーツ備考
         * @param {boolean} [canUse] 不可&#x3D;false
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerCreateDocumentParts(documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, name: string, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerCreateDocumentParts(documentPartsClass, documentPartsCategoryId, documentSizeCode, name, imageThumbnail, inDesignFile, comment, freeWord, canUse, mediaTypes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツデータ作成
         * @param {CreateDocumentPartsContentDto} createDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerCreateDocumentPartsContent(createDocumentPartsContentDto: CreateDocumentPartsContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsContentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerCreateDocumentPartsContent(createDocumentPartsContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerDeleteDocumentParts(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerDeleteDocumentParts(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツデータ削除
         * @param {DeleteDocumentPartsContentDto} deleteDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerDeleteDocumentPartsContent(deleteDocumentPartsContentDto: DeleteDocumentPartsContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsContentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerDeleteDocumentPartsContent(deleteDocumentPartsContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツ詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerGetDocumentParts(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerGetDocumentParts(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツ種別とカテゴリ取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerGetDocumentPartsClassAndCategories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MasterPartsClassDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerGetDocumentPartsClassAndCategories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツデータ取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerGetDocumentPartsContent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsContentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerGetDocumentPartsContent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 評価パーツ名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerList(take, skip, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツ更新
         * @param {string} documentPartsClass 種別
         * @param {number} documentPartsCategoryId カテゴリid
         * @param {string} documentSizeCode 原稿サイズ
         * @param {number} id id
         * @param {File} [imageThumbnail] サムネイル
         * @param {File} [inDesignFile] インデザインファイル
         * @param {string} [comment] パーツ内容
         * @param {string} [freeWord] パーツ備考
         * @param {boolean} [canUse] 不可&#x3D;false
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {string} [name] パーツ名称
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerUpdateDocumentParts(documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, id: number, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerUpdateDocumentParts(documentPartsClass, documentPartsCategoryId, documentSizeCode, id, imageThumbnail, inDesignFile, comment, freeWord, canUse, mediaTypes, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary パーツデータ更新
         * @param {UpdateDocumentPartsContentDto} updateDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentPartsControllerUpdateDocumentPartsContent(updateDocumentPartsContentDto: UpdateDocumentPartsContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPartsContentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentPartsControllerUpdateDocumentPartsContent(updateDocumentPartsContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentPartsApi - factory interface
 * @export
 */
export const DocumentPartsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentPartsApiFp(configuration)
    return {
        /**
         * 
         * @summary パーツ作成
         * @param {string} documentPartsClass 種別
         * @param {number} documentPartsCategoryId カテゴリid
         * @param {string} documentSizeCode 原稿サイズ
         * @param {string} name パーツ名称
         * @param {File} [imageThumbnail] サムネイル
         * @param {File} [inDesignFile] インデザインファイル
         * @param {string} [comment] パーツ内容
         * @param {string} [freeWord] パーツ備考
         * @param {boolean} [canUse] 不可&#x3D;false
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerCreateDocumentParts(documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, name: string, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, options?: any): AxiosPromise<DocumentPartsResponseDto> {
            return localVarFp.documentPartsControllerCreateDocumentParts(documentPartsClass, documentPartsCategoryId, documentSizeCode, name, imageThumbnail, inDesignFile, comment, freeWord, canUse, mediaTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツデータ作成
         * @param {CreateDocumentPartsContentDto} createDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerCreateDocumentPartsContent(createDocumentPartsContentDto: CreateDocumentPartsContentDto, options?: any): AxiosPromise<DocumentPartsContentResponseDto> {
            return localVarFp.documentPartsControllerCreateDocumentPartsContent(createDocumentPartsContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerDeleteDocumentParts(id: number, options?: any): AxiosPromise<DocumentPartsResponseDto> {
            return localVarFp.documentPartsControllerDeleteDocumentParts(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツデータ削除
         * @param {DeleteDocumentPartsContentDto} deleteDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerDeleteDocumentPartsContent(deleteDocumentPartsContentDto: DeleteDocumentPartsContentDto, options?: any): AxiosPromise<DocumentPartsContentResponseDto> {
            return localVarFp.documentPartsControllerDeleteDocumentPartsContent(deleteDocumentPartsContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツ詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerGetDocumentParts(id: number, options?: any): AxiosPromise<DocumentPartsResponseDto> {
            return localVarFp.documentPartsControllerGetDocumentParts(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツ種別とカテゴリ取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerGetDocumentPartsClassAndCategories(options?: any): AxiosPromise<Array<MasterPartsClassDto>> {
            return localVarFp.documentPartsControllerGetDocumentPartsClassAndCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツデータ取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerGetDocumentPartsContent(id: number, options?: any): AxiosPromise<DocumentPartsContentResponseDto> {
            return localVarFp.documentPartsControllerGetDocumentPartsContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツ一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] 評価パーツ名
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerList(take?: number, skip?: number, name?: string, options?: any): AxiosPromise<DocumentPartsWithCountDto> {
            return localVarFp.documentPartsControllerList(take, skip, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツ更新
         * @param {string} documentPartsClass 種別
         * @param {number} documentPartsCategoryId カテゴリid
         * @param {string} documentSizeCode 原稿サイズ
         * @param {number} id id
         * @param {File} [imageThumbnail] サムネイル
         * @param {File} [inDesignFile] インデザインファイル
         * @param {string} [comment] パーツ内容
         * @param {string} [freeWord] パーツ備考
         * @param {boolean} [canUse] 不可&#x3D;false
         * @param {Array<string>} [mediaTypes] 媒体
         * @param {string} [name] パーツ名称
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerUpdateDocumentParts(documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, id: number, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, name?: string, options?: any): AxiosPromise<DocumentPartsResponseDto> {
            return localVarFp.documentPartsControllerUpdateDocumentParts(documentPartsClass, documentPartsCategoryId, documentSizeCode, id, imageThumbnail, inDesignFile, comment, freeWord, canUse, mediaTypes, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary パーツデータ更新
         * @param {UpdateDocumentPartsContentDto} updateDocumentPartsContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentPartsControllerUpdateDocumentPartsContent(updateDocumentPartsContentDto: UpdateDocumentPartsContentDto, options?: any): AxiosPromise<DocumentPartsContentResponseDto> {
            return localVarFp.documentPartsControllerUpdateDocumentPartsContent(updateDocumentPartsContentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentPartsApi - object-oriented interface
 * @export
 * @class DocumentPartsApi
 * @extends {BaseAPI}
 */
export class DocumentPartsApi extends BaseAPI {
    /**
     * 
     * @summary パーツ作成
     * @param {string} documentPartsClass 種別
     * @param {number} documentPartsCategoryId カテゴリid
     * @param {string} documentSizeCode 原稿サイズ
     * @param {string} name パーツ名称
     * @param {File} [imageThumbnail] サムネイル
     * @param {File} [inDesignFile] インデザインファイル
     * @param {string} [comment] パーツ内容
     * @param {string} [freeWord] パーツ備考
     * @param {boolean} [canUse] 不可&#x3D;false
     * @param {Array<string>} [mediaTypes] 媒体
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerCreateDocumentParts(documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, name: string, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerCreateDocumentParts(documentPartsClass, documentPartsCategoryId, documentSizeCode, name, imageThumbnail, inDesignFile, comment, freeWord, canUse, mediaTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツデータ作成
     * @param {CreateDocumentPartsContentDto} createDocumentPartsContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerCreateDocumentPartsContent(createDocumentPartsContentDto: CreateDocumentPartsContentDto, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerCreateDocumentPartsContent(createDocumentPartsContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツ削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerDeleteDocumentParts(id: number, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerDeleteDocumentParts(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツデータ削除
     * @param {DeleteDocumentPartsContentDto} deleteDocumentPartsContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerDeleteDocumentPartsContent(deleteDocumentPartsContentDto: DeleteDocumentPartsContentDto, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerDeleteDocumentPartsContent(deleteDocumentPartsContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツ詳細
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerGetDocumentParts(id: number, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerGetDocumentParts(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツ種別とカテゴリ取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerGetDocumentPartsClassAndCategories(options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerGetDocumentPartsClassAndCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツデータ取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerGetDocumentPartsContent(id: number, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerGetDocumentPartsContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツ一覧取得
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {string} [name] 評価パーツ名
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerList(take, skip, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツ更新
     * @param {string} documentPartsClass 種別
     * @param {number} documentPartsCategoryId カテゴリid
     * @param {string} documentSizeCode 原稿サイズ
     * @param {number} id id
     * @param {File} [imageThumbnail] サムネイル
     * @param {File} [inDesignFile] インデザインファイル
     * @param {string} [comment] パーツ内容
     * @param {string} [freeWord] パーツ備考
     * @param {boolean} [canUse] 不可&#x3D;false
     * @param {Array<string>} [mediaTypes] 媒体
     * @param {string} [name] パーツ名称
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerUpdateDocumentParts(documentPartsClass: string, documentPartsCategoryId: number, documentSizeCode: string, id: number, imageThumbnail?: File, inDesignFile?: File, comment?: string, freeWord?: string, canUse?: boolean, mediaTypes?: Array<string>, name?: string, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerUpdateDocumentParts(documentPartsClass, documentPartsCategoryId, documentSizeCode, id, imageThumbnail, inDesignFile, comment, freeWord, canUse, mediaTypes, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary パーツデータ更新
     * @param {UpdateDocumentPartsContentDto} updateDocumentPartsContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentPartsApi
     */
    public documentPartsControllerUpdateDocumentPartsContent(updateDocumentPartsContentDto: UpdateDocumentPartsContentDto, options?: AxiosRequestConfig) {
        return DocumentPartsApiFp(this.configuration).documentPartsControllerUpdateDocumentPartsContent(updateDocumentPartsContentDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentTemplatesApi - axios parameter creator
 * @export
 */
export const DocumentTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary テンプレート一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] テンプレート名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentTemplateControllerList: async (take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/document-templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (documentSizeCode !== undefined) {
                localVarQueryParameter['documentSizeCode'] = documentSizeCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentTemplatesApi - functional programming interface
 * @export
 */
export const DocumentTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary テンプレート一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] テンプレート名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentTemplateControllerList(take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentTemplateWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentTemplateControllerList(take, skip, name, documentSizeCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentTemplatesApi - factory interface
 * @export
 */
export const DocumentTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentTemplatesApiFp(configuration)
    return {
        /**
         * 
         * @summary テンプレート一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] テンプレート名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentTemplateControllerList(take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options?: any): AxiosPromise<DocumentTemplateWithCountDto> {
            return localVarFp.documentTemplateControllerList(take, skip, name, documentSizeCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentTemplatesApi - object-oriented interface
 * @export
 * @class DocumentTemplatesApi
 * @extends {BaseAPI}
 */
export class DocumentTemplatesApi extends BaseAPI {
    /**
     * 
     * @summary テンプレート一覧取得
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {string} [name] テンプレート名
     * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentTemplatesApi
     */
    public documentTemplateControllerList(take?: number, skip?: number, name?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', options?: AxiosRequestConfig) {
        return DocumentTemplatesApiFp(this.configuration).documentTemplateControllerList(take, skip, name, documentSizeCode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 原稿作成
         * @param {CreateDocumentDto} createDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateDocument: async (createDocumentDto: CreateDocumentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDocumentDto' is not null or undefined
            assertParamExists('documentControllerCreateDocument', 'createDocumentDto', createDocumentDto)
            const localVarPath = `/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDocumentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocument: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerDeleteDocument', 'id', id)
            const localVarPath = `/v1/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿流用
         * @param {number} originalDocumentId 流用元原稿ID
         * @param {number} destinationDocumentId 流用先原稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDiversion: async (originalDocumentId: number, destinationDocumentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'originalDocumentId' is not null or undefined
            assertParamExists('documentControllerDiversion', 'originalDocumentId', originalDocumentId)
            // verify required parameter 'destinationDocumentId' is not null or undefined
            assertParamExists('documentControllerDiversion', 'destinationDocumentId', destinationDocumentId)
            const localVarPath = `/v1/documents/diversion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (originalDocumentId !== undefined) {
                localVarQueryParameter['originalDocumentId'] = originalDocumentId;
            }

            if (destinationDocumentId !== undefined) {
                localVarQueryParameter['destinationDocumentId'] = destinationDocumentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocument: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerGetDocument', 'id', id)
            const localVarPath = `/v1/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿内容取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocumentContent: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerGetDocumentContent', 'id', id)
            const localVarPath = `/v1/documents/content/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿ゲット
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerList: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿複数id対応ステータス更新
         * @param {UpdateManyDocumentStatusDto} updateManyDocumentStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerManyUpdateDocumentStatus: async (updateManyDocumentStatusDto: UpdateManyDocumentStatusDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateManyDocumentStatusDto' is not null or undefined
            assertParamExists('documentControllerManyUpdateDocumentStatus', 'updateManyDocumentStatusDto', updateManyDocumentStatusDto)
            const localVarPath = `/v1/documents/manyUpdateStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateManyDocumentStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿を移動する
         * @param {MoveDocumentDto} moveDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerMoveDocument: async (moveDocumentDto: MoveDocumentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moveDocumentDto' is not null or undefined
            assertParamExists('documentControllerMoveDocument', 'moveDocumentDto', moveDocumentDto)
            const localVarPath = `/v1/documents/move-document`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveDocumentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿相乗り解除
         * @param {number} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemoveAlias: async (documentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentControllerRemoveAlias', 'documentId', documentId)
            const localVarPath = `/v1/documents/removeAlias/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿検索
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {number} [projectId] プロジェクトID
         * @param {Array<any>} [statusCodes] 原稿ステータスコード
         * @param {Array<any>} [mediaTypeCodes] 媒体種別マスタ
         * @param {Array<any>} [editionCodes] 版コード
         * @param {Array<string>} [issueYearMonth] 月号 年月 &#x3D;&gt; バックエンド側でパースする
         * @param {string} [hotelCode] ホテルコード
         * @param {string} [hotelName] ホテル名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
         * @param {Array<string>} [manuscriptPersonCognito] 編集担当のcognitoID配列
         * @param {Array<string>} [salesPersonCognito] 営業担当のcognitoID配列
         * @param {string} [documentCode] 
         * @param {string} [documentModifiedAtFrom] ドキュメント最終更新日From
         * @param {string} [documentModifiedAtTo] ドキュメント最終更新日To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSearch: async (take?: number, skip?: number, projectId?: number, statusCodes?: Array<any>, mediaTypeCodes?: Array<any>, editionCodes?: Array<any>, issueYearMonth?: Array<string>, hotelCode?: string, hotelName?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', manuscriptPersonCognito?: Array<string>, salesPersonCognito?: Array<string>, documentCode?: string, documentModifiedAtFrom?: string, documentModifiedAtTo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/documents/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (statusCodes) {
                localVarQueryParameter['statusCodes'] = statusCodes;
            }

            if (mediaTypeCodes) {
                localVarQueryParameter['mediaTypeCodes'] = mediaTypeCodes;
            }

            if (editionCodes) {
                localVarQueryParameter['editionCodes'] = editionCodes;
            }

            if (issueYearMonth) {
                localVarQueryParameter['issueYearMonth'] = issueYearMonth;
            }

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotelCode'] = hotelCode;
            }

            if (hotelName !== undefined) {
                localVarQueryParameter['hotelName'] = hotelName;
            }

            if (documentSizeCode !== undefined) {
                localVarQueryParameter['documentSizeCode'] = documentSizeCode;
            }

            if (manuscriptPersonCognito) {
                localVarQueryParameter['manuscriptPersonCognito'] = manuscriptPersonCognito;
            }

            if (salesPersonCognito) {
                localVarQueryParameter['salesPersonCognito'] = salesPersonCognito;
            }

            if (documentCode !== undefined) {
                localVarQueryParameter['documentCode'] = documentCode;
            }

            if (documentModifiedAtFrom !== undefined) {
                localVarQueryParameter['documentModifiedAtFrom'] = (documentModifiedAtFrom as any instanceof Date) ?
                    (documentModifiedAtFrom as any).toISOString() :
                    documentModifiedAtFrom;
            }

            if (documentModifiedAtTo !== undefined) {
                localVarQueryParameter['documentModifiedAtTo'] = (documentModifiedAtTo as any instanceof Date) ?
                    (documentModifiedAtTo as any).toISOString() :
                    documentModifiedAtTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 相乗り原稿検索
         * @param {number} documentId 原稿ID
         * @param {string} createPersonCognito マイストック登録者コード
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSearchAlias: async (documentId: number, createPersonCognito: string, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentControllerSearchAlias', 'documentId', documentId)
            // verify required parameter 'createPersonCognito' is not null or undefined
            assertParamExists('documentControllerSearchAlias', 'createPersonCognito', createPersonCognito)
            const localVarPath = `/v1/documents/searchAlias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (documentId !== undefined) {
                localVarQueryParameter['documentId'] = documentId;
            }

            if (createPersonCognito !== undefined) {
                localVarQueryParameter['createPersonCognito'] = createPersonCognito;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 流用原稿検索
         * @param {number} documentId 原稿ID
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSearchDiversion: async (documentId: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentControllerSearchDiversion', 'documentId', documentId)
            const localVarPath = `/v1/documents/searchDiversion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (documentId !== undefined) {
                localVarQueryParameter['documentId'] = documentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿相乗り
         * @param {number} originalDocumentId 流用元原稿ID
         * @param {number} destinationDocumentId 流用先原稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSetAlias: async (originalDocumentId: number, destinationDocumentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'originalDocumentId' is not null or undefined
            assertParamExists('documentControllerSetAlias', 'originalDocumentId', originalDocumentId)
            // verify required parameter 'destinationDocumentId' is not null or undefined
            assertParamExists('documentControllerSetAlias', 'destinationDocumentId', destinationDocumentId)
            const localVarPath = `/v1/documents/setAlias`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (originalDocumentId !== undefined) {
                localVarQueryParameter['originalDocumentId'] = originalDocumentId;
            }

            if (destinationDocumentId !== undefined) {
                localVarQueryParameter['destinationDocumentId'] = destinationDocumentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿情報更新
         * @param {number} id 
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocument: async (id: number, updateDocumentDto: UpdateDocumentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerUpdateDocument', 'id', id)
            // verify required parameter 'updateDocumentDto' is not null or undefined
            assertParamExists('documentControllerUpdateDocument', 'updateDocumentDto', updateDocumentDto)
            const localVarPath = `/v1/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿内容更新
         * @param {number} id 
         * @param {UpdateDocumentContentDto} updateDocumentContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocumentContent: async (id: number, updateDocumentContentDto: UpdateDocumentContentDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerUpdateDocumentContent', 'id', id)
            // verify required parameter 'updateDocumentContentDto' is not null or undefined
            assertParamExists('documentControllerUpdateDocumentContent', 'updateDocumentContentDto', updateDocumentContentDto)
            const localVarPath = `/v1/documents/content/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentContentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿内容更新
         * @param {number} id 
         * @param {boolean} [bathExclusiveFlag] 風呂評価対象外
         * @param {string} [furiganaSmall] ふりがな小
         * @param {string} [hotelNameSmall] 宿名小
         * @param {string} [spaName] 温泉地名
         * @param {string} [hotelCatchCopy] 宿のキャッチテキスト
         * @param {File} [exteriorPhotoFile] 宿外観写真ファイル
         * @param {string} [accessInfoText] アクセス情報テキスト
         * @param {string} [breakfastPlace] 朝食場所
         * @param {string} [dinnerPlace] 夕食場所
         * @param {boolean} [hasElevator] エレベーター？
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocumentContentAndIDML: async (id: number, bathExclusiveFlag?: boolean, furiganaSmall?: string, hotelNameSmall?: string, spaName?: string, hotelCatchCopy?: string, exteriorPhotoFile?: File, accessInfoText?: string, breakfastPlace?: string, dinnerPlace?: string, hasElevator?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerUpdateDocumentContentAndIDML', 'id', id)
            const localVarPath = `/v1/documents/contentAndIdml/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (bathExclusiveFlag !== undefined) { 
                localVarFormParams.append('bathExclusiveFlag', bathExclusiveFlag as any);
            }
    
            if (furiganaSmall !== undefined) { 
                localVarFormParams.append('furiganaSmall', furiganaSmall as any);
            }
    
            if (hotelNameSmall !== undefined) { 
                localVarFormParams.append('hotelNameSmall', hotelNameSmall as any);
            }
    
            if (spaName !== undefined) { 
                localVarFormParams.append('spaName', spaName as any);
            }
    
            if (hotelCatchCopy !== undefined) { 
                localVarFormParams.append('hotelCatchCopy', hotelCatchCopy as any);
            }
    
            if (exteriorPhotoFile !== undefined) { 
                localVarFormParams.append('exteriorPhotoFile', exteriorPhotoFile as any);
            }
    
            if (accessInfoText !== undefined) { 
                localVarFormParams.append('accessInfoText', accessInfoText as any);
            }
    
            if (breakfastPlace !== undefined) { 
                localVarFormParams.append('breakfastPlace', breakfastPlace as any);
            }
    
            if (dinnerPlace !== undefined) { 
                localVarFormParams.append('dinnerPlace', dinnerPlace as any);
            }
    
            if (hasElevator !== undefined) { 
                localVarFormParams.append('hasElevator', hasElevator as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿ステータス更新
         * @param {UpdateDocumentStatusDto} updateDocumentStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocumentStatus: async (updateDocumentStatusDto: UpdateDocumentStatusDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDocumentStatusDto' is not null or undefined
            assertParamExists('documentControllerUpdateDocumentStatus', 'updateDocumentStatusDto', updateDocumentStatusDto)
            const localVarPath = `/v1/documents/updateStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDocumentStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 原稿作成
         * @param {CreateDocumentDto} createDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerCreateDocument(createDocumentDto: CreateDocumentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerCreateDocument(createDocumentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDeleteDocument(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDeleteDocument(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿流用
         * @param {number} originalDocumentId 流用元原稿ID
         * @param {number} destinationDocumentId 流用先原稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerDiversion(originalDocumentId: number, destinationDocumentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseWithContentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerDiversion(originalDocumentId, destinationDocumentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetDocument(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseWithProject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocument(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿内容取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetDocumentContent(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseWithContentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocumentContent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿ゲット
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerList(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentResponseWithProject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerList(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿複数id対応ステータス更新
         * @param {UpdateManyDocumentStatusDto} updateManyDocumentStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerManyUpdateDocumentStatus(updateManyDocumentStatusDto: UpdateManyDocumentStatusDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerManyUpdateDocumentStatus(updateManyDocumentStatusDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿を移動する
         * @param {MoveDocumentDto} moveDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerMoveDocument(moveDocumentDto: MoveDocumentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerMoveDocument(moveDocumentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿相乗り解除
         * @param {number} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerRemoveAlias(documentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseWithContentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerRemoveAlias(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿検索
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {number} [projectId] プロジェクトID
         * @param {Array<any>} [statusCodes] 原稿ステータスコード
         * @param {Array<any>} [mediaTypeCodes] 媒体種別マスタ
         * @param {Array<any>} [editionCodes] 版コード
         * @param {Array<string>} [issueYearMonth] 月号 年月 &#x3D;&gt; バックエンド側でパースする
         * @param {string} [hotelCode] ホテルコード
         * @param {string} [hotelName] ホテル名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
         * @param {Array<string>} [manuscriptPersonCognito] 編集担当のcognitoID配列
         * @param {Array<string>} [salesPersonCognito] 営業担当のcognitoID配列
         * @param {string} [documentCode] 
         * @param {string} [documentModifiedAtFrom] ドキュメント最終更新日From
         * @param {string} [documentModifiedAtTo] ドキュメント最終更新日To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerSearch(take?: number, skip?: number, projectId?: number, statusCodes?: Array<any>, mediaTypeCodes?: Array<any>, editionCodes?: Array<any>, issueYearMonth?: Array<string>, hotelCode?: string, hotelName?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', manuscriptPersonCognito?: Array<string>, salesPersonCognito?: Array<string>, documentCode?: string, documentModifiedAtFrom?: string, documentModifiedAtTo?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSearchWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerSearch(take, skip, projectId, statusCodes, mediaTypeCodes, editionCodes, issueYearMonth, hotelCode, hotelName, documentSizeCode, manuscriptPersonCognito, salesPersonCognito, documentCode, documentModifiedAtFrom, documentModifiedAtTo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 相乗り原稿検索
         * @param {number} documentId 原稿ID
         * @param {string} createPersonCognito マイストック登録者コード
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerSearchAlias(documentId: number, createPersonCognito: string, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentAliasSearchDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerSearchAlias(documentId, createPersonCognito, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 流用原稿検索
         * @param {number} documentId 原稿ID
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerSearchDiversion(documentId: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DocumentDiversionSearchDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerSearchDiversion(documentId, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿相乗り
         * @param {number} originalDocumentId 流用元原稿ID
         * @param {number} destinationDocumentId 流用先原稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerSetAlias(originalDocumentId: number, destinationDocumentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseWithContentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerSetAlias(originalDocumentId, destinationDocumentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿情報更新
         * @param {number} id 
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateDocument(id: number, updateDocumentDto: UpdateDocumentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateDocument(id, updateDocumentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿内容更新
         * @param {number} id 
         * @param {UpdateDocumentContentDto} updateDocumentContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateDocumentContent(id: number, updateDocumentContentDto: UpdateDocumentContentDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateDocumentContent(id, updateDocumentContentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿内容更新
         * @param {number} id 
         * @param {boolean} [bathExclusiveFlag] 風呂評価対象外
         * @param {string} [furiganaSmall] ふりがな小
         * @param {string} [hotelNameSmall] 宿名小
         * @param {string} [spaName] 温泉地名
         * @param {string} [hotelCatchCopy] 宿のキャッチテキスト
         * @param {File} [exteriorPhotoFile] 宿外観写真ファイル
         * @param {string} [accessInfoText] アクセス情報テキスト
         * @param {string} [breakfastPlace] 朝食場所
         * @param {string} [dinnerPlace] 夕食場所
         * @param {boolean} [hasElevator] エレベーター？
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateDocumentContentAndIDML(id: number, bathExclusiveFlag?: boolean, furiganaSmall?: string, hotelNameSmall?: string, spaName?: string, hotelCatchCopy?: string, exteriorPhotoFile?: File, accessInfoText?: string, breakfastPlace?: string, dinnerPlace?: string, hasElevator?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateDocumentContentAndIDML(id, bathExclusiveFlag, furiganaSmall, hotelNameSmall, spaName, hotelCatchCopy, exteriorPhotoFile, accessInfoText, breakfastPlace, dinnerPlace, hasElevator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿ステータス更新
         * @param {UpdateDocumentStatusDto} updateDocumentStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerUpdateDocumentStatus(updateDocumentStatusDto: UpdateDocumentStatusDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerUpdateDocumentStatus(updateDocumentStatusDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary 原稿作成
         * @param {CreateDocumentDto} createDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerCreateDocument(createDocumentDto: CreateDocumentDto, options?: any): AxiosPromise<DocumentResponseDto> {
            return localVarFp.documentControllerCreateDocument(createDocumentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDeleteDocument(id: number, options?: any): AxiosPromise<DocumentResponseDto> {
            return localVarFp.documentControllerDeleteDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿流用
         * @param {number} originalDocumentId 流用元原稿ID
         * @param {number} destinationDocumentId 流用先原稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerDiversion(originalDocumentId: number, destinationDocumentId: number, options?: any): AxiosPromise<DocumentResponseWithContentDto> {
            return localVarFp.documentControllerDiversion(originalDocumentId, destinationDocumentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocument(id: number, options?: any): AxiosPromise<DocumentResponseWithProject> {
            return localVarFp.documentControllerGetDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿内容取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocumentContent(id: number, options?: any): AxiosPromise<DocumentResponseWithContentDto> {
            return localVarFp.documentControllerGetDocumentContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿ゲット
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerList(take?: number, skip?: number, options?: any): AxiosPromise<Array<DocumentResponseWithProject>> {
            return localVarFp.documentControllerList(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿複数id対応ステータス更新
         * @param {UpdateManyDocumentStatusDto} updateManyDocumentStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerManyUpdateDocumentStatus(updateManyDocumentStatusDto: UpdateManyDocumentStatusDto, options?: any): AxiosPromise<Array<DocumentResponseDto>> {
            return localVarFp.documentControllerManyUpdateDocumentStatus(updateManyDocumentStatusDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿を移動する
         * @param {MoveDocumentDto} moveDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerMoveDocument(moveDocumentDto: MoveDocumentDto, options?: any): AxiosPromise<DocumentResponseDto> {
            return localVarFp.documentControllerMoveDocument(moveDocumentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿相乗り解除
         * @param {number} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerRemoveAlias(documentId: number, options?: any): AxiosPromise<DocumentResponseWithContentDto> {
            return localVarFp.documentControllerRemoveAlias(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿検索
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {number} [projectId] プロジェクトID
         * @param {Array<any>} [statusCodes] 原稿ステータスコード
         * @param {Array<any>} [mediaTypeCodes] 媒体種別マスタ
         * @param {Array<any>} [editionCodes] 版コード
         * @param {Array<string>} [issueYearMonth] 月号 年月 &#x3D;&gt; バックエンド側でパースする
         * @param {string} [hotelCode] ホテルコード
         * @param {string} [hotelName] ホテル名
         * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
         * @param {Array<string>} [manuscriptPersonCognito] 編集担当のcognitoID配列
         * @param {Array<string>} [salesPersonCognito] 営業担当のcognitoID配列
         * @param {string} [documentCode] 
         * @param {string} [documentModifiedAtFrom] ドキュメント最終更新日From
         * @param {string} [documentModifiedAtTo] ドキュメント最終更新日To
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSearch(take?: number, skip?: number, projectId?: number, statusCodes?: Array<any>, mediaTypeCodes?: Array<any>, editionCodes?: Array<any>, issueYearMonth?: Array<string>, hotelCode?: string, hotelName?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', manuscriptPersonCognito?: Array<string>, salesPersonCognito?: Array<string>, documentCode?: string, documentModifiedAtFrom?: string, documentModifiedAtTo?: string, options?: any): AxiosPromise<DocumentSearchWithCountDto> {
            return localVarFp.documentControllerSearch(take, skip, projectId, statusCodes, mediaTypeCodes, editionCodes, issueYearMonth, hotelCode, hotelName, documentSizeCode, manuscriptPersonCognito, salesPersonCognito, documentCode, documentModifiedAtFrom, documentModifiedAtTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 相乗り原稿検索
         * @param {number} documentId 原稿ID
         * @param {string} createPersonCognito マイストック登録者コード
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSearchAlias(documentId: number, createPersonCognito: string, take?: number, skip?: number, options?: any): AxiosPromise<Array<DocumentAliasSearchDto>> {
            return localVarFp.documentControllerSearchAlias(documentId, createPersonCognito, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 流用原稿検索
         * @param {number} documentId 原稿ID
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSearchDiversion(documentId: number, take?: number, skip?: number, options?: any): AxiosPromise<Array<DocumentDiversionSearchDto>> {
            return localVarFp.documentControllerSearchDiversion(documentId, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿相乗り
         * @param {number} originalDocumentId 流用元原稿ID
         * @param {number} destinationDocumentId 流用先原稿ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerSetAlias(originalDocumentId: number, destinationDocumentId: number, options?: any): AxiosPromise<DocumentResponseWithContentDto> {
            return localVarFp.documentControllerSetAlias(originalDocumentId, destinationDocumentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿情報更新
         * @param {number} id 
         * @param {UpdateDocumentDto} updateDocumentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocument(id: number, updateDocumentDto: UpdateDocumentDto, options?: any): AxiosPromise<DocumentResponseDto> {
            return localVarFp.documentControllerUpdateDocument(id, updateDocumentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿内容更新
         * @param {number} id 
         * @param {UpdateDocumentContentDto} updateDocumentContentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocumentContent(id: number, updateDocumentContentDto: UpdateDocumentContentDto, options?: any): AxiosPromise<DocumentResponseDto> {
            return localVarFp.documentControllerUpdateDocumentContent(id, updateDocumentContentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿内容更新
         * @param {number} id 
         * @param {boolean} [bathExclusiveFlag] 風呂評価対象外
         * @param {string} [furiganaSmall] ふりがな小
         * @param {string} [hotelNameSmall] 宿名小
         * @param {string} [spaName] 温泉地名
         * @param {string} [hotelCatchCopy] 宿のキャッチテキスト
         * @param {File} [exteriorPhotoFile] 宿外観写真ファイル
         * @param {string} [accessInfoText] アクセス情報テキスト
         * @param {string} [breakfastPlace] 朝食場所
         * @param {string} [dinnerPlace] 夕食場所
         * @param {boolean} [hasElevator] エレベーター？
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocumentContentAndIDML(id: number, bathExclusiveFlag?: boolean, furiganaSmall?: string, hotelNameSmall?: string, spaName?: string, hotelCatchCopy?: string, exteriorPhotoFile?: File, accessInfoText?: string, breakfastPlace?: string, dinnerPlace?: string, hasElevator?: boolean, options?: any): AxiosPromise<DocumentResponseDto> {
            return localVarFp.documentControllerUpdateDocumentContentAndIDML(id, bathExclusiveFlag, furiganaSmall, hotelNameSmall, spaName, hotelCatchCopy, exteriorPhotoFile, accessInfoText, breakfastPlace, dinnerPlace, hasElevator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿ステータス更新
         * @param {UpdateDocumentStatusDto} updateDocumentStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerUpdateDocumentStatus(updateDocumentStatusDto: UpdateDocumentStatusDto, options?: any): AxiosPromise<DocumentResponseDto> {
            return localVarFp.documentControllerUpdateDocumentStatus(updateDocumentStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * 
     * @summary 原稿作成
     * @param {CreateDocumentDto} createDocumentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerCreateDocument(createDocumentDto: CreateDocumentDto, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerCreateDocument(createDocumentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerDeleteDocument(id: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDeleteDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿流用
     * @param {number} originalDocumentId 流用元原稿ID
     * @param {number} destinationDocumentId 流用先原稿ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerDiversion(originalDocumentId: number, destinationDocumentId: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerDiversion(originalDocumentId, destinationDocumentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerGetDocument(id: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿内容取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerGetDocumentContent(id: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerGetDocumentContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿ゲット
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerList(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerList(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿複数id対応ステータス更新
     * @param {UpdateManyDocumentStatusDto} updateManyDocumentStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerManyUpdateDocumentStatus(updateManyDocumentStatusDto: UpdateManyDocumentStatusDto, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerManyUpdateDocumentStatus(updateManyDocumentStatusDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿を移動する
     * @param {MoveDocumentDto} moveDocumentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerMoveDocument(moveDocumentDto: MoveDocumentDto, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerMoveDocument(moveDocumentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿相乗り解除
     * @param {number} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerRemoveAlias(documentId: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerRemoveAlias(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿検索
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {number} [projectId] プロジェクトID
     * @param {Array<any>} [statusCodes] 原稿ステータスコード
     * @param {Array<any>} [mediaTypeCodes] 媒体種別マスタ
     * @param {Array<any>} [editionCodes] 版コード
     * @param {Array<string>} [issueYearMonth] 月号 年月 &#x3D;&gt; バックエンド側でパースする
     * @param {string} [hotelCode] ホテルコード
     * @param {string} [hotelName] ホテル名
     * @param {'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR'} [documentSizeCode] 原稿サイズコード
     * @param {Array<string>} [manuscriptPersonCognito] 編集担当のcognitoID配列
     * @param {Array<string>} [salesPersonCognito] 営業担当のcognitoID配列
     * @param {string} [documentCode] 
     * @param {string} [documentModifiedAtFrom] ドキュメント最終更新日From
     * @param {string} [documentModifiedAtTo] ドキュメント最終更新日To
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerSearch(take?: number, skip?: number, projectId?: number, statusCodes?: Array<any>, mediaTypeCodes?: Array<any>, editionCodes?: Array<any>, issueYearMonth?: Array<string>, hotelCode?: string, hotelName?: string, documentSizeCode?: 'ONE_ONE' | 'ONE_TWO' | 'ONE_FOUR', manuscriptPersonCognito?: Array<string>, salesPersonCognito?: Array<string>, documentCode?: string, documentModifiedAtFrom?: string, documentModifiedAtTo?: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerSearch(take, skip, projectId, statusCodes, mediaTypeCodes, editionCodes, issueYearMonth, hotelCode, hotelName, documentSizeCode, manuscriptPersonCognito, salesPersonCognito, documentCode, documentModifiedAtFrom, documentModifiedAtTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 相乗り原稿検索
     * @param {number} documentId 原稿ID
     * @param {string} createPersonCognito マイストック登録者コード
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerSearchAlias(documentId: number, createPersonCognito: string, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerSearchAlias(documentId, createPersonCognito, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 流用原稿検索
     * @param {number} documentId 原稿ID
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerSearchDiversion(documentId: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerSearchDiversion(documentId, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿相乗り
     * @param {number} originalDocumentId 流用元原稿ID
     * @param {number} destinationDocumentId 流用先原稿ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerSetAlias(originalDocumentId: number, destinationDocumentId: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerSetAlias(originalDocumentId, destinationDocumentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿情報更新
     * @param {number} id 
     * @param {UpdateDocumentDto} updateDocumentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerUpdateDocument(id: number, updateDocumentDto: UpdateDocumentDto, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateDocument(id, updateDocumentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿内容更新
     * @param {number} id 
     * @param {UpdateDocumentContentDto} updateDocumentContentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerUpdateDocumentContent(id: number, updateDocumentContentDto: UpdateDocumentContentDto, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateDocumentContent(id, updateDocumentContentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿内容更新
     * @param {number} id 
     * @param {boolean} [bathExclusiveFlag] 風呂評価対象外
     * @param {string} [furiganaSmall] ふりがな小
     * @param {string} [hotelNameSmall] 宿名小
     * @param {string} [spaName] 温泉地名
     * @param {string} [hotelCatchCopy] 宿のキャッチテキスト
     * @param {File} [exteriorPhotoFile] 宿外観写真ファイル
     * @param {string} [accessInfoText] アクセス情報テキスト
     * @param {string} [breakfastPlace] 朝食場所
     * @param {string} [dinnerPlace] 夕食場所
     * @param {boolean} [hasElevator] エレベーター？
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerUpdateDocumentContentAndIDML(id: number, bathExclusiveFlag?: boolean, furiganaSmall?: string, hotelNameSmall?: string, spaName?: string, hotelCatchCopy?: string, exteriorPhotoFile?: File, accessInfoText?: string, breakfastPlace?: string, dinnerPlace?: string, hasElevator?: boolean, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateDocumentContentAndIDML(id, bathExclusiveFlag, furiganaSmall, hotelNameSmall, spaName, hotelCatchCopy, exteriorPhotoFile, accessInfoText, breakfastPlace, dinnerPlace, hasElevator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿ステータス更新
     * @param {UpdateDocumentStatusDto} updateDocumentStatusDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentControllerUpdateDocumentStatus(updateDocumentStatusDto: UpdateDocumentStatusDto, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentControllerUpdateDocumentStatus(updateDocumentStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExportsApi - axios parameter creator
 * @export
 */
export const ExportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary idよりエクスポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportCancel: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportsControllerExportCancel', 'id', id)
            const localVarPath = `/v1/exports/export-cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 原稿進捗状況エクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportDocumentProgress: async (projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportsControllerExportDocumentProgress', 'projectId', projectId)
            const localVarPath = `/v1/exports/document-progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (editionCode !== undefined) {
                localVarQueryParameter['editionCode'] = editionCode;
            }

            if (outputFormat !== undefined) {
                localVarQueryParameter['outputFormat'] = outputFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 台割り補助エクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportDraftAssistance: async (projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportsControllerExportDraftAssistance', 'projectId', projectId)
            const localVarPath = `/v1/exports/draft-assistance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (editionCode !== undefined) {
                localVarQueryParameter['editionCode'] = editionCode;
            }

            if (outputFormat !== undefined) {
                localVarQueryParameter['outputFormat'] = outputFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 台割りエクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportDraftPages: async (projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportsControllerExportDraftPages', 'projectId', projectId)
            const localVarPath = `/v1/exports/draft-pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            if (editionCode !== undefined) {
                localVarQueryParameter['editionCode'] = editionCode;
            }

            if (outputFormat !== undefined) {
                localVarQueryParameter['outputFormat'] = outputFormat;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary idよりエクスポート進捗取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerGetProgress: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('exportsControllerGetProgress', 'id', id)
            const localVarPath = `/v1/exports/export-progress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportsApi - functional programming interface
 * @export
 */
export const ExportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary idよりエクスポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsControllerExportCancel(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsControllerExportCancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 原稿進捗状況エクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsControllerExportDocumentProgress(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsControllerExportDocumentProgress(projectId, editionCode, outputFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 台割り補助エクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsControllerExportDraftAssistance(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsControllerExportDraftAssistance(projectId, editionCode, outputFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 台割りエクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsControllerExportDraftPages(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsControllerExportDraftPages(projectId, editionCode, outputFormat, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary idよりエクスポート進捗取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsControllerGetProgress(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsControllerGetProgress(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExportsApi - factory interface
 * @export
 */
export const ExportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExportsApiFp(configuration)
    return {
        /**
         * 
         * @summary idよりエクスポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportCancel(id: number, options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.exportsControllerExportCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 原稿進捗状況エクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportDocumentProgress(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.exportsControllerExportDocumentProgress(projectId, editionCode, outputFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 台割り補助エクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportDraftAssistance(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.exportsControllerExportDraftAssistance(projectId, editionCode, outputFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 台割りエクスポート
         * @param {number} projectId projectId
         * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
         * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerExportDraftPages(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.exportsControllerExportDraftPages(projectId, editionCode, outputFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary idよりエクスポート進捗取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsControllerGetProgress(id: number, options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.exportsControllerGetProgress(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExportsApi - object-oriented interface
 * @export
 * @class ExportsApi
 * @extends {BaseAPI}
 */
export class ExportsApi extends BaseAPI {
    /**
     * 
     * @summary idよりエクスポートキャンセル
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportsApi
     */
    public exportsControllerExportCancel(id: number, options?: AxiosRequestConfig) {
        return ExportsApiFp(this.configuration).exportsControllerExportCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 原稿進捗状況エクスポート
     * @param {number} projectId projectId
     * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
     * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportsApi
     */
    public exportsControllerExportDocumentProgress(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: AxiosRequestConfig) {
        return ExportsApiFp(this.configuration).exportsControllerExportDocumentProgress(projectId, editionCode, outputFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 台割り補助エクスポート
     * @param {number} projectId projectId
     * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
     * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportsApi
     */
    public exportsControllerExportDraftAssistance(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: AxiosRequestConfig) {
        return ExportsApiFp(this.configuration).exportsControllerExportDraftAssistance(projectId, editionCode, outputFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 台割りエクスポート
     * @param {number} projectId projectId
     * @param {'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'} [editionCode] 版コード
     * @param {'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI'} [outputFormat] 出力データ形式
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportsApi
     */
    public exportsControllerExportDraftPages(projectId: number, editionCode?: 'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST', outputFormat?: 'INDEX_DATA' | 'DAIWARI_HOJO_DATA' | 'PAGE_KUMIHAN' | 'KANMATSU_KEISAIYADO' | 'DAIWARI', options?: AxiosRequestConfig) {
        return ExportsApiFp(this.configuration).exportsControllerExportDraftPages(projectId, editionCode, outputFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary idよりエクスポート進捗取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportsApi
     */
    public exportsControllerGetProgress(id: number, options?: AxiosRequestConfig) {
        return ExportsApiFp(this.configuration).exportsControllerGetProgress(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealthchecker: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthControllerHealthchecker(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthControllerHealthchecker(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthControllerHealthchecker(options?: any): AxiosPromise<void> {
            return localVarFp.healthControllerHealthchecker(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthControllerHealthchecker(options?: AxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthControllerHealthchecker(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HotelApi - axios parameter creator
 * @export
 */
export const HotelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 宿情報取得
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelInfoControllerGetHotelInfo: async (hotelCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('hotelInfoControllerGetHotelInfo', 'hotelCode', hotelCode)
            const localVarPath = `/v1/hotel/{hotelCode}`
                .replace(`{${"hotelCode"}}`, encodeURIComponent(String(hotelCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HotelApi - functional programming interface
 * @export
 */
export const HotelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HotelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 宿情報取得
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hotelInfoControllerGetHotelInfo(hotelCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HotelInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hotelInfoControllerGetHotelInfo(hotelCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HotelApi - factory interface
 * @export
 */
export const HotelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HotelApiFp(configuration)
    return {
        /**
         * 
         * @summary 宿情報取得
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hotelInfoControllerGetHotelInfo(hotelCode: string, options?: any): AxiosPromise<HotelInfoResponse> {
            return localVarFp.hotelInfoControllerGetHotelInfo(hotelCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HotelApi - object-oriented interface
 * @export
 * @class HotelApi
 * @extends {BaseAPI}
 */
export class HotelApi extends BaseAPI {
    /**
     * 
     * @summary 宿情報取得
     * @param {string} hotelCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotelApi
     */
    public hotelInfoControllerGetHotelInfo(hotelCode: string, options?: AxiosRequestConfig) {
        return HotelApiFp(this.configuration).hotelInfoControllerGetHotelInfo(hotelCode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IdmlReplaceApi - axios parameter creator
 * @export
 */
export const IdmlReplaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Share Link
         * @param {CreateIdmlDocumentShare} createIdmlDocumentShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateShareLink: async (createIdmlDocumentShare: CreateIdmlDocumentShare, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createIdmlDocumentShare' is not null or undefined
            assertParamExists('idmlReplaceControllerCreateShareLink', 'createIdmlDocumentShare', createIdmlDocumentShare)
            const localVarPath = `/v1/idml-replace/create-share-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createIdmlDocumentShare, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspace料金表ヘッダ作成
         * @param {CreateWorkspaceFeetableHeaderRequestDto} createWorkspaceFeetableHeaderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspacFeeTableHeader: async (createWorkspaceFeetableHeaderRequestDto: CreateWorkspaceFeetableHeaderRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkspaceFeetableHeaderRequestDto' is not null or undefined
            assertParamExists('idmlReplaceControllerCreateWorkspacFeeTableHeader', 'createWorkspaceFeetableHeaderRequestDto', createWorkspaceFeetableHeaderRequestDto)
            const localVarPath = `/v1/idml-replace/workspace/feetable-header`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceFeetableHeaderRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspace訴求レイアウト作成
         * @param {CreateWorkspaceAppealLayoutRequestDto} createWorkspaceAppealLayoutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspaceAppealLayout: async (createWorkspaceAppealLayoutRequestDto: CreateWorkspaceAppealLayoutRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkspaceAppealLayoutRequestDto' is not null or undefined
            assertParamExists('idmlReplaceControllerCreateWorkspaceAppealLayout', 'createWorkspaceAppealLayoutRequestDto', createWorkspaceAppealLayoutRequestDto)
            const localVarPath = `/v1/idml-replace/workspace/appeal-layout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceAppealLayoutRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspaceパーツコラム作成
         * @param {CreateWorkspacePartsRequestDto} createWorkspacePartsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspacePartsCoumn: async (createWorkspacePartsRequestDto: CreateWorkspacePartsRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkspacePartsRequestDto' is not null or undefined
            assertParamExists('idmlReplaceControllerCreateWorkspacePartsCoumn', 'createWorkspacePartsRequestDto', createWorkspacePartsRequestDto)
            const localVarPath = `/v1/idml-replace/workspace/parts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspacePartsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspaceパーツレイアウト作成
         * @param {CreateWorkspacePartsLayoutRequestDto} createWorkspacePartsLayoutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspacePartsLayout: async (createWorkspacePartsLayoutRequestDto: CreateWorkspacePartsLayoutRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkspacePartsLayoutRequestDto' is not null or undefined
            assertParamExists('idmlReplaceControllerCreateWorkspacePartsLayout', 'createWorkspacePartsLayoutRequestDto', createWorkspacePartsLayoutRequestDto)
            const localVarPath = `/v1/idml-replace/workspace/parts-layout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspacePartsLayoutRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerExprotToPagePdf: async (pageId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageId' is not null or undefined
            assertParamExists('idmlReplaceControllerExprotToPagePdf', 'pageId', pageId)
            const localVarPath = `/v1/idml-replace/export/page/{pageId}`
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetColors: async (fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('idmlReplaceControllerGetColors', 'fileName', fileName)
            const localVarPath = `/v1/idml-replace/idml-colors/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspace背景画像ファイル取得
         * @param {string} sizeCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceBackgroundImage: async (sizeCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sizeCode' is not null or undefined
            assertParamExists('idmlReplaceControllerGetWorkspaceBackgroundImage', 'sizeCode', sizeCode)
            const localVarPath = `/v1/idml-replace/workspace/bg-image/{sizeCode}`
                .replace(`{${"sizeCode"}}`, encodeURIComponent(String(sizeCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspace画像ファイル取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceImage: async (fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('idmlReplaceControllerGetWorkspaceImage', 'fileName', fileName)
            const localVarPath = `/v1/idml-replace/workspace/image/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspaceアイテム一覧取得
         * @param {string} editId 編集ID
         * @param {string} [packageId] パッケージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceItems: async (editId: string, packageId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editId' is not null or undefined
            assertParamExists('idmlReplaceControllerGetWorkspaceItems', 'editId', editId)
            const localVarPath = `/v1/idml-replace/workspace/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (editId !== undefined) {
                localVarQueryParameter['editId'] = editId;
            }

            if (packageId !== undefined) {
                localVarQueryParameter['packageId'] = packageId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspaceパッケージのタグ一覧取得
         * @param {string} editId 編集ID
         * @param {string} [packageId] パッケージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceTags: async (editId: string, packageId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editId' is not null or undefined
            assertParamExists('idmlReplaceControllerGetWorkspaceTags', 'editId', editId)
            const localVarPath = `/v1/idml-replace/workspace/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (editId !== undefined) {
                localVarQueryParameter['editId'] = editId;
            }

            if (packageId !== undefined) {
                localVarQueryParameter['packageId'] = packageId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerIdmlLinks: async (fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('idmlReplaceControllerIdmlLinks', 'fileName', fileName)
            const localVarPath = `/v1/idml-replace/idml-links/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerIdmlTags: async (fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('idmlReplaceControllerIdmlTags', 'fileName', fileName)
            const localVarPath = `/v1/idml-replace/idml-tags/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 画像トリミング処理
         * @param {number} width 切り取り画像幅
         * @param {number} height 切り取り画像高さ
         * @param {number} x 切り取り場所座標x
         * @param {number} y 切り取り場所座標y
         * @param {File} file 処理対象画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerImageCropping: async (width: number, height: number, x: number, y: number, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'width' is not null or undefined
            assertParamExists('idmlReplaceControllerImageCropping', 'width', width)
            // verify required parameter 'height' is not null or undefined
            assertParamExists('idmlReplaceControllerImageCropping', 'height', height)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('idmlReplaceControllerImageCropping', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('idmlReplaceControllerImageCropping', 'y', y)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('idmlReplaceControllerImageCropping', 'file', file)
            const localVarPath = `/v1/idml-replace/image-crop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (width !== undefined) { 
                localVarFormParams.append('width', width as any);
            }
    
            if (height !== undefined) { 
                localVarFormParams.append('height', height as any);
            }
    
            if (x !== undefined) { 
                localVarFormParams.append('x', x as any);
            }
    
            if (y !== undefined) { 
                localVarFormParams.append('y', y as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ファイル一覧の取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/idml-replace/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspaceアイコンファイルリセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerResetWorkspaceIcons: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/idml-replace/workspace/reset-iconfiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} editId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerSendToIndesignServer: async (editId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editId' is not null or undefined
            assertParamExists('idmlReplaceControllerSendToIndesignServer', 'editId', editId)
            const localVarPath = `/v1/idml-replace/export/document/{editId}`
                .replace(`{${"editId"}}`, encodeURIComponent(String(editId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} editId 
         * @param {string} packageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerTags: async (editId: string, packageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editId' is not null or undefined
            assertParamExists('idmlReplaceControllerTags', 'editId', editId)
            // verify required parameter 'packageId' is not null or undefined
            assertParamExists('idmlReplaceControllerTags', 'packageId', packageId)
            const localVarPath = `/v1/idml-replace/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (editId !== undefined) {
                localVarQueryParameter['editId'] = editId;
            }

            if (packageId !== undefined) {
                localVarQueryParameter['packageId'] = packageId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sizeCode 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateSetting: async (sizeCode: string, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sizeCode' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateSetting', 'sizeCode', sizeCode)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateSetting', 'body', body)
            const localVarPath = `/v1/idml-replace/update-settings/{sizeCode}`
                .replace(`{${"sizeCode"}}`, encodeURIComponent(String(sizeCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspaceコンテンツの更新
         * @param {UpdateWorkspaceContentRequestDto} updateWorkspaceContentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateWorkspaceContents: async (updateWorkspaceContentRequestDto: UpdateWorkspaceContentRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateWorkspaceContentRequestDto' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateWorkspaceContents', 'updateWorkspaceContentRequestDto', updateWorkspaceContentRequestDto)
            const localVarPath = `/v1/idml-replace/workspace/contents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkspaceContentRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspaceアイコンの更新
         * @param {UpdateWorkspaceIconsRequestDto} updateWorkspaceIconsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateWorkspaceIcons: async (updateWorkspaceIconsRequestDto: UpdateWorkspaceIconsRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateWorkspaceIconsRequestDto' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateWorkspaceIcons', 'updateWorkspaceIconsRequestDto', updateWorkspaceIconsRequestDto)
            const localVarPath = `/v1/idml-replace/workspace/icons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkspaceIconsRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Workspace画像の更新
         * @param {string} editId 編集ID
         * @param {string} packageId パッケージID
         * @param {string} tagId タグID
         * @param {File} file 画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateWorkspaceImage: async (editId: string, packageId: string, tagId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editId' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateWorkspaceImage', 'editId', editId)
            // verify required parameter 'packageId' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateWorkspaceImage', 'packageId', packageId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateWorkspaceImage', 'tagId', tagId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('idmlReplaceControllerUpdateWorkspaceImage', 'file', file)
            const localVarPath = `/v1/idml-replace/workspace/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (editId !== undefined) { 
                localVarFormParams.append('editId', editId as any);
            }
    
            if (packageId !== undefined) { 
                localVarFormParams.append('packageId', packageId as any);
            }
    
            if (tagId !== undefined) { 
                localVarFormParams.append('tagId', tagId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IDMLファイルの追加
         * @param {File} file IDMLファイル (データ)
         * @param {string} fileName IDMLファイル (*.idml)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpload: async (file: File, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('idmlReplaceControllerUpload', 'file', file)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('idmlReplaceControllerUpload', 'fileName', fileName)
            const localVarPath = `/v1/idml-replace/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileName !== undefined) { 
                localVarFormParams.append('fileName', fileName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 背景画像ファイル登録
         * @param {string} templateId 
         * @param {File} file 画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUploadOriginalBackgroundImage: async (templateId: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('idmlReplaceControllerUploadOriginalBackgroundImage', 'templateId', templateId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('idmlReplaceControllerUploadOriginalBackgroundImage', 'file', file)
            const localVarPath = `/v1/idml-replace/background-image/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} editId 
         * @param {string} partsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerWorkspaceIdmlLinks: async (editId: string, partsId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editId' is not null or undefined
            assertParamExists('idmlReplaceControllerWorkspaceIdmlLinks', 'editId', editId)
            // verify required parameter 'partsId' is not null or undefined
            assertParamExists('idmlReplaceControllerWorkspaceIdmlLinks', 'partsId', partsId)
            const localVarPath = `/v1/idml-replace/idml-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (editId !== undefined) {
                localVarQueryParameter['editId'] = editId;
            }

            if (partsId !== undefined) {
                localVarQueryParameter['partsId'] = partsId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IdmlReplaceApi - functional programming interface
 * @export
 */
export const IdmlReplaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IdmlReplaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Share Link
         * @param {CreateIdmlDocumentShare} createIdmlDocumentShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerCreateShareLink(createIdmlDocumentShare: CreateIdmlDocumentShare, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerCreateShareLink(createIdmlDocumentShare, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspace料金表ヘッダ作成
         * @param {CreateWorkspaceFeetableHeaderRequestDto} createWorkspaceFeetableHeaderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerCreateWorkspacFeeTableHeader(createWorkspaceFeetableHeaderRequestDto: CreateWorkspaceFeetableHeaderRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerCreateWorkspacFeeTableHeader(createWorkspaceFeetableHeaderRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspace訴求レイアウト作成
         * @param {CreateWorkspaceAppealLayoutRequestDto} createWorkspaceAppealLayoutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerCreateWorkspaceAppealLayout(createWorkspaceAppealLayoutRequestDto: CreateWorkspaceAppealLayoutRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerCreateWorkspaceAppealLayout(createWorkspaceAppealLayoutRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspaceパーツコラム作成
         * @param {CreateWorkspacePartsRequestDto} createWorkspacePartsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerCreateWorkspacePartsCoumn(createWorkspacePartsRequestDto: CreateWorkspacePartsRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerCreateWorkspacePartsCoumn(createWorkspacePartsRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspaceパーツレイアウト作成
         * @param {CreateWorkspacePartsLayoutRequestDto} createWorkspacePartsLayoutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerCreateWorkspacePartsLayout(createWorkspacePartsLayoutRequestDto: CreateWorkspacePartsLayoutRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerCreateWorkspacePartsLayout(createWorkspacePartsLayoutRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerExprotToPagePdf(pageId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerExprotToPagePdf(pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerGetColors(fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerGetColors(fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspace背景画像ファイル取得
         * @param {string} sizeCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerGetWorkspaceBackgroundImage(sizeCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerGetWorkspaceBackgroundImage(sizeCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspace画像ファイル取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerGetWorkspaceImage(fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerGetWorkspaceImage(fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspaceアイテム一覧取得
         * @param {string} editId 編集ID
         * @param {string} [packageId] パッケージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerGetWorkspaceItems(editId: string, packageId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdmlItemsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerGetWorkspaceItems(editId, packageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspaceパッケージのタグ一覧取得
         * @param {string} editId 編集ID
         * @param {string} [packageId] パッケージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerGetWorkspaceTags(editId: string, packageId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerGetWorkspaceTags(editId, packageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerIdmlLinks(fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerIdmlLinks(fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerIdmlTags(fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerIdmlTags(fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 画像トリミング処理
         * @param {number} width 切り取り画像幅
         * @param {number} height 切り取り画像高さ
         * @param {number} x 切り取り場所座標x
         * @param {number} y 切り取り場所座標y
         * @param {File} file 処理対象画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerImageCropping(width: number, height: number, x: number, y: number, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerImageCropping(width, height, x, y, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ファイル一覧の取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspaceアイコンファイルリセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerResetWorkspaceIcons(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerResetWorkspaceIcons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} editId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerSendToIndesignServer(editId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerSendToIndesignServer(editId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} editId 
         * @param {string} packageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerTags(editId: string, packageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerTags(editId, packageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sizeCode 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerUpdateSetting(sizeCode: string, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerUpdateSetting(sizeCode, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspaceコンテンツの更新
         * @param {UpdateWorkspaceContentRequestDto} updateWorkspaceContentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerUpdateWorkspaceContents(updateWorkspaceContentRequestDto: UpdateWorkspaceContentRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerUpdateWorkspaceContents(updateWorkspaceContentRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspaceアイコンの更新
         * @param {UpdateWorkspaceIconsRequestDto} updateWorkspaceIconsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerUpdateWorkspaceIcons(updateWorkspaceIconsRequestDto: UpdateWorkspaceIconsRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerUpdateWorkspaceIcons(updateWorkspaceIconsRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Workspace画像の更新
         * @param {string} editId 編集ID
         * @param {string} packageId パッケージID
         * @param {string} tagId タグID
         * @param {File} file 画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerUpdateWorkspaceImage(editId: string, packageId: string, tagId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceCommonResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerUpdateWorkspaceImage(editId, packageId, tagId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IDMLファイルの追加
         * @param {File} file IDMLファイル (データ)
         * @param {string} fileName IDMLファイル (*.idml)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerUpload(file: File, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerUpload(file, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 背景画像ファイル登録
         * @param {string} templateId 
         * @param {File} file 画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerUploadOriginalBackgroundImage(templateId: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerUploadOriginalBackgroundImage(templateId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} editId 
         * @param {string} partsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async idmlReplaceControllerWorkspaceIdmlLinks(editId: string, partsId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.idmlReplaceControllerWorkspaceIdmlLinks(editId, partsId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IdmlReplaceApi - factory interface
 * @export
 */
export const IdmlReplaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IdmlReplaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Share Link
         * @param {CreateIdmlDocumentShare} createIdmlDocumentShare 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateShareLink(createIdmlDocumentShare: CreateIdmlDocumentShare, options?: any): AxiosPromise<string> {
            return localVarFp.idmlReplaceControllerCreateShareLink(createIdmlDocumentShare, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspace料金表ヘッダ作成
         * @param {CreateWorkspaceFeetableHeaderRequestDto} createWorkspaceFeetableHeaderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspacFeeTableHeader(createWorkspaceFeetableHeaderRequestDto: CreateWorkspaceFeetableHeaderRequestDto, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerCreateWorkspacFeeTableHeader(createWorkspaceFeetableHeaderRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspace訴求レイアウト作成
         * @param {CreateWorkspaceAppealLayoutRequestDto} createWorkspaceAppealLayoutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspaceAppealLayout(createWorkspaceAppealLayoutRequestDto: CreateWorkspaceAppealLayoutRequestDto, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerCreateWorkspaceAppealLayout(createWorkspaceAppealLayoutRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspaceパーツコラム作成
         * @param {CreateWorkspacePartsRequestDto} createWorkspacePartsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspacePartsCoumn(createWorkspacePartsRequestDto: CreateWorkspacePartsRequestDto, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerCreateWorkspacePartsCoumn(createWorkspacePartsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspaceパーツレイアウト作成
         * @param {CreateWorkspacePartsLayoutRequestDto} createWorkspacePartsLayoutRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerCreateWorkspacePartsLayout(createWorkspacePartsLayoutRequestDto: CreateWorkspacePartsLayoutRequestDto, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerCreateWorkspacePartsLayout(createWorkspacePartsLayoutRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} pageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerExprotToPagePdf(pageId: number, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerExprotToPagePdf(pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetColors(fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerGetColors(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspace背景画像ファイル取得
         * @param {string} sizeCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceBackgroundImage(sizeCode: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerGetWorkspaceBackgroundImage(sizeCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspace画像ファイル取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceImage(fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerGetWorkspaceImage(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspaceアイテム一覧取得
         * @param {string} editId 編集ID
         * @param {string} [packageId] パッケージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceItems(editId: string, packageId?: string, options?: any): AxiosPromise<IdmlItemsResponseDto> {
            return localVarFp.idmlReplaceControllerGetWorkspaceItems(editId, packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspaceパッケージのタグ一覧取得
         * @param {string} editId 編集ID
         * @param {string} [packageId] パッケージID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerGetWorkspaceTags(editId: string, packageId?: string, options?: any): AxiosPromise<object> {
            return localVarFp.idmlReplaceControllerGetWorkspaceTags(editId, packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerIdmlLinks(fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerIdmlLinks(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerIdmlTags(fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerIdmlTags(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 画像トリミング処理
         * @param {number} width 切り取り画像幅
         * @param {number} height 切り取り画像高さ
         * @param {number} x 切り取り場所座標x
         * @param {number} y 切り取り場所座標y
         * @param {File} file 処理対象画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerImageCropping(width: number, height: number, x: number, y: number, file: File, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerImageCropping(width, height, x, y, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ファイル一覧の取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerList(options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspaceアイコンファイルリセット
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerResetWorkspaceIcons(options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerResetWorkspaceIcons(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} editId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerSendToIndesignServer(editId: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerSendToIndesignServer(editId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} editId 
         * @param {string} packageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerTags(editId: string, packageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerTags(editId, packageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sizeCode 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateSetting(sizeCode: string, body: object, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerUpdateSetting(sizeCode, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspaceコンテンツの更新
         * @param {UpdateWorkspaceContentRequestDto} updateWorkspaceContentRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateWorkspaceContents(updateWorkspaceContentRequestDto: UpdateWorkspaceContentRequestDto, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerUpdateWorkspaceContents(updateWorkspaceContentRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspaceアイコンの更新
         * @param {UpdateWorkspaceIconsRequestDto} updateWorkspaceIconsRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateWorkspaceIcons(updateWorkspaceIconsRequestDto: UpdateWorkspaceIconsRequestDto, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerUpdateWorkspaceIcons(updateWorkspaceIconsRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Workspace画像の更新
         * @param {string} editId 編集ID
         * @param {string} packageId パッケージID
         * @param {string} tagId タグID
         * @param {File} file 画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpdateWorkspaceImage(editId: string, packageId: string, tagId: string, file: File, options?: any): AxiosPromise<WorkspaceCommonResponse> {
            return localVarFp.idmlReplaceControllerUpdateWorkspaceImage(editId, packageId, tagId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IDMLファイルの追加
         * @param {File} file IDMLファイル (データ)
         * @param {string} fileName IDMLファイル (*.idml)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUpload(file: File, fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerUpload(file, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 背景画像ファイル登録
         * @param {string} templateId 
         * @param {File} file 画像ファイル
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerUploadOriginalBackgroundImage(templateId: string, file: File, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerUploadOriginalBackgroundImage(templateId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary IDML参照しているリンクを取得
         * @param {string} editId 
         * @param {string} partsId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        idmlReplaceControllerWorkspaceIdmlLinks(editId: string, partsId: string, options?: any): AxiosPromise<void> {
            return localVarFp.idmlReplaceControllerWorkspaceIdmlLinks(editId, partsId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IdmlReplaceApi - object-oriented interface
 * @export
 * @class IdmlReplaceApi
 * @extends {BaseAPI}
 */
export class IdmlReplaceApi extends BaseAPI {
    /**
     * 
     * @summary Create Share Link
     * @param {CreateIdmlDocumentShare} createIdmlDocumentShare 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerCreateShareLink(createIdmlDocumentShare: CreateIdmlDocumentShare, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerCreateShareLink(createIdmlDocumentShare, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspace料金表ヘッダ作成
     * @param {CreateWorkspaceFeetableHeaderRequestDto} createWorkspaceFeetableHeaderRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerCreateWorkspacFeeTableHeader(createWorkspaceFeetableHeaderRequestDto: CreateWorkspaceFeetableHeaderRequestDto, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerCreateWorkspacFeeTableHeader(createWorkspaceFeetableHeaderRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspace訴求レイアウト作成
     * @param {CreateWorkspaceAppealLayoutRequestDto} createWorkspaceAppealLayoutRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerCreateWorkspaceAppealLayout(createWorkspaceAppealLayoutRequestDto: CreateWorkspaceAppealLayoutRequestDto, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerCreateWorkspaceAppealLayout(createWorkspaceAppealLayoutRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspaceパーツコラム作成
     * @param {CreateWorkspacePartsRequestDto} createWorkspacePartsRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerCreateWorkspacePartsCoumn(createWorkspacePartsRequestDto: CreateWorkspacePartsRequestDto, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerCreateWorkspacePartsCoumn(createWorkspacePartsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspaceパーツレイアウト作成
     * @param {CreateWorkspacePartsLayoutRequestDto} createWorkspacePartsLayoutRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerCreateWorkspacePartsLayout(createWorkspacePartsLayoutRequestDto: CreateWorkspacePartsLayoutRequestDto, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerCreateWorkspacePartsLayout(createWorkspacePartsLayoutRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} pageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerExprotToPagePdf(pageId: number, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerExprotToPagePdf(pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IDML参照しているリンクを取得
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerGetColors(fileName: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerGetColors(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspace背景画像ファイル取得
     * @param {string} sizeCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerGetWorkspaceBackgroundImage(sizeCode: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerGetWorkspaceBackgroundImage(sizeCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspace画像ファイル取得
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerGetWorkspaceImage(fileName: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerGetWorkspaceImage(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspaceアイテム一覧取得
     * @param {string} editId 編集ID
     * @param {string} [packageId] パッケージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerGetWorkspaceItems(editId: string, packageId?: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerGetWorkspaceItems(editId, packageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspaceパッケージのタグ一覧取得
     * @param {string} editId 編集ID
     * @param {string} [packageId] パッケージID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerGetWorkspaceTags(editId: string, packageId?: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerGetWorkspaceTags(editId, packageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IDML参照しているリンクを取得
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerIdmlLinks(fileName: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerIdmlLinks(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IDML参照しているリンクを取得
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerIdmlTags(fileName: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerIdmlTags(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 画像トリミング処理
     * @param {number} width 切り取り画像幅
     * @param {number} height 切り取り画像高さ
     * @param {number} x 切り取り場所座標x
     * @param {number} y 切り取り場所座標y
     * @param {File} file 処理対象画像ファイル
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerImageCropping(width: number, height: number, x: number, y: number, file: File, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerImageCropping(width, height, x, y, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ファイル一覧の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerList(options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspaceアイコンファイルリセット
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerResetWorkspaceIcons(options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerResetWorkspaceIcons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} editId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerSendToIndesignServer(editId: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerSendToIndesignServer(editId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IDML参照しているリンクを取得
     * @param {string} editId 
     * @param {string} packageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerTags(editId: string, packageId: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerTags(editId, packageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sizeCode 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerUpdateSetting(sizeCode: string, body: object, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerUpdateSetting(sizeCode, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspaceコンテンツの更新
     * @param {UpdateWorkspaceContentRequestDto} updateWorkspaceContentRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerUpdateWorkspaceContents(updateWorkspaceContentRequestDto: UpdateWorkspaceContentRequestDto, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerUpdateWorkspaceContents(updateWorkspaceContentRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspaceアイコンの更新
     * @param {UpdateWorkspaceIconsRequestDto} updateWorkspaceIconsRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerUpdateWorkspaceIcons(updateWorkspaceIconsRequestDto: UpdateWorkspaceIconsRequestDto, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerUpdateWorkspaceIcons(updateWorkspaceIconsRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Workspace画像の更新
     * @param {string} editId 編集ID
     * @param {string} packageId パッケージID
     * @param {string} tagId タグID
     * @param {File} file 画像ファイル
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerUpdateWorkspaceImage(editId: string, packageId: string, tagId: string, file: File, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerUpdateWorkspaceImage(editId, packageId, tagId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IDMLファイルの追加
     * @param {File} file IDMLファイル (データ)
     * @param {string} fileName IDMLファイル (*.idml)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerUpload(file: File, fileName: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerUpload(file, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 背景画像ファイル登録
     * @param {string} templateId 
     * @param {File} file 画像ファイル
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerUploadOriginalBackgroundImage(templateId: string, file: File, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerUploadOriginalBackgroundImage(templateId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary IDML参照しているリンクを取得
     * @param {string} editId 
     * @param {string} partsId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IdmlReplaceApi
     */
    public idmlReplaceControllerWorkspaceIdmlLinks(editId: string, partsId: string, options?: AxiosRequestConfig) {
        return IdmlReplaceApiFp(this.configuration).idmlReplaceControllerWorkspaceIdmlLinks(editId, partsId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportsApi - axios parameter creator
 * @export
 */
export const ImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 台割りインポート
         * @param {number} id projectId
         * @param {File} draftPagesFile 台割りxls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerDraftImport: async (id: number, draftPagesFile: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importControllerDraftImport', 'id', id)
            // verify required parameter 'draftPagesFile' is not null or undefined
            assertParamExists('importControllerDraftImport', 'draftPagesFile', draftPagesFile)
            const localVarPath = `/v1/imports/draft-pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (draftPagesFile !== undefined) { 
                localVarFormParams.append('draftPagesFile', draftPagesFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary idより台割りインポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerDraftTaskCancel: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importControllerDraftTaskCancel', 'id', id)
            const localVarPath = `/v1/imports/draft-cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary エントリーインポート
         * @param {number} projectId projectId
         * @param {File} entryFile エントリーxls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerEntryImport: async (projectId: number, entryFile: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importControllerEntryImport', 'projectId', projectId)
            // verify required parameter 'entryFile' is not null or undefined
            assertParamExists('importControllerEntryImport', 'entryFile', entryFile)
            const localVarPath = `/v1/imports/entry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (projectId !== undefined) { 
                localVarFormParams.append('projectId', projectId as any);
            }
    
            if (entryFile !== undefined) { 
                localVarFormParams.append('entryFile', entryFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary エントリーインポート進捗一覧
         * @param {number} projectId projectId
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerEntryList: async (projectId: number, take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importControllerEntryList', 'projectId', projectId)
            const localVarPath = `/v1/imports/entry-progress-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary idよりエントリーインポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerEntryTaskCancel: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importControllerEntryTaskCancel', 'id', id)
            const localVarPath = `/v1/imports/entry-cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary エントリーインポート進捗
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerGetEntryProgress: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importControllerGetEntryProgress', 'id', id)
            const localVarPath = `/v1/imports/entry-progress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary エントリーインポート進捗SSEリクエスト対応
         * @param {number} id 
         * @param {number} intervalNum 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerGetEntryProgressFromSse: async (id: number, intervalNum: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importControllerGetEntryProgressFromSse', 'id', id)
            // verify required parameter 'intervalNum' is not null or undefined
            assertParamExists('importControllerGetEntryProgressFromSse', 'intervalNum', intervalNum)
            const localVarPath = `/v1/imports/entry-progress-sse/{id}/{intervalNum}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"intervalNum"}}`, encodeURIComponent(String(intervalNum)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 台割りインポート進捗
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerGetProgress: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importControllerGetProgress', 'id', id)
            const localVarPath = `/v1/imports/draft-progress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportsApi - functional programming interface
 * @export
 */
export const ImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 台割りインポート
         * @param {number} id projectId
         * @param {File} draftPagesFile 台割りxls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerDraftImport(id: number, draftPagesFile: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerDraftImport(id, draftPagesFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary idより台割りインポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerDraftTaskCancel(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerDraftTaskCancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary エントリーインポート
         * @param {number} projectId projectId
         * @param {File} entryFile エントリーxls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerEntryImport(projectId: number, entryFile: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportXlsDocumentProgressDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerEntryImport(projectId, entryFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary エントリーインポート進捗一覧
         * @param {number} projectId projectId
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerEntryList(projectId: number, take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDtoWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerEntryList(projectId, take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary idよりエントリーインポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerEntryTaskCancel(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerEntryTaskCancel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary エントリーインポート進捗
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerGetEntryProgress(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerGetEntryProgress(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary エントリーインポート進捗SSEリクエスト対応
         * @param {number} id 
         * @param {number} intervalNum 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerGetEntryProgressFromSse(id: number, intervalNum: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressSSMDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerGetEntryProgressFromSse(id, intervalNum, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 台割りインポート進捗
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importControllerGetProgress(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportXlsDocumentProgressDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importControllerGetProgress(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportsApi - factory interface
 * @export
 */
export const ImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportsApiFp(configuration)
    return {
        /**
         * 
         * @summary 台割りインポート
         * @param {number} id projectId
         * @param {File} draftPagesFile 台割りxls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerDraftImport(id: number, draftPagesFile: File, options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.importControllerDraftImport(id, draftPagesFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary idより台割りインポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerDraftTaskCancel(id: number, options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.importControllerDraftTaskCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary エントリーインポート
         * @param {number} projectId projectId
         * @param {File} entryFile エントリーxls
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerEntryImport(projectId: number, entryFile: File, options?: any): AxiosPromise<Array<ImportXlsDocumentProgressDto>> {
            return localVarFp.importControllerEntryImport(projectId, entryFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary エントリーインポート進捗一覧
         * @param {number} projectId projectId
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerEntryList(projectId: number, take?: number, skip?: number, options?: any): AxiosPromise<ImportXlsDocumentProgressDtoWithCountDto> {
            return localVarFp.importControllerEntryList(projectId, take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary idよりエントリーインポートキャンセル
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerEntryTaskCancel(id: number, options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.importControllerEntryTaskCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary エントリーインポート進捗
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerGetEntryProgress(id: number, options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.importControllerGetEntryProgress(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary エントリーインポート進捗SSEリクエスト対応
         * @param {number} id 
         * @param {number} intervalNum 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerGetEntryProgressFromSse(id: number, intervalNum: number, options?: any): AxiosPromise<ImportXlsDocumentProgressSSMDto> {
            return localVarFp.importControllerGetEntryProgressFromSse(id, intervalNum, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 台割りインポート進捗
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importControllerGetProgress(id: number, options?: any): AxiosPromise<ImportXlsDocumentProgressDto> {
            return localVarFp.importControllerGetProgress(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportsApi - object-oriented interface
 * @export
 * @class ImportsApi
 * @extends {BaseAPI}
 */
export class ImportsApi extends BaseAPI {
    /**
     * 
     * @summary 台割りインポート
     * @param {number} id projectId
     * @param {File} draftPagesFile 台割りxls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerDraftImport(id: number, draftPagesFile: File, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerDraftImport(id, draftPagesFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary idより台割りインポートキャンセル
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerDraftTaskCancel(id: number, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerDraftTaskCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary エントリーインポート
     * @param {number} projectId projectId
     * @param {File} entryFile エントリーxls
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerEntryImport(projectId: number, entryFile: File, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerEntryImport(projectId, entryFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary エントリーインポート進捗一覧
     * @param {number} projectId projectId
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerEntryList(projectId: number, take?: number, skip?: number, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerEntryList(projectId, take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary idよりエントリーインポートキャンセル
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerEntryTaskCancel(id: number, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerEntryTaskCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary エントリーインポート進捗
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerGetEntryProgress(id: number, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerGetEntryProgress(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary エントリーインポート進捗SSEリクエスト対応
     * @param {number} id 
     * @param {number} intervalNum 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerGetEntryProgressFromSse(id: number, intervalNum: number, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerGetEntryProgressFromSse(id, intervalNum, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 台割りインポート進捗
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportsApi
     */
    public importControllerGetProgress(id: number, options?: AxiosRequestConfig) {
        return ImportsApiFp(this.configuration).importControllerGetProgress(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MarginBottomApi - axios parameter creator
 * @export
 */
export const MarginBottomApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 欄外下画像作成
         * @param {string} name 欄外下画像名
         * @param {Array<string>} [pageMountMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [pageMountByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerCreate: async (name: string, pageMountMediaTypes?: Array<string>, pageMountByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pageMountControllerCreate', 'name', name)
            const localVarPath = `/v1/margin-bottom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
                if (pageMountMediaTypes) {
                localVarFormParams.append('pageMountMediaTypes', pageMountMediaTypes.join(COLLECTION_FORMATS.csv));
            }

                if (pageMountByEditionCodes) {
                localVarFormParams.append('pageMountByEditionCodes', pageMountByEditionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 欄外下画像削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageMountControllerDelete', 'id', id)
            const localVarPath = `/v1/margin-bottom/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 欄外下画像イメージ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerDeleteImage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageMountControllerDeleteImage', 'id', id)
            const localVarPath = `/v1/margin-bottom/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 欄外下画像詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerGetPageMountById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageMountControllerGetPageMountById', 'id', id)
            const localVarPath = `/v1/margin-bottom/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 欄外下画像リスト
         * @param {string} [name] 欄外下画像名
         * @param {number} [limit] limit
         * @param {number} [offset] offset
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerList: async (name?: string, limit?: number, offset?: number, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/margin-bottom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (editionCodes) {
                localVarQueryParameter['editionCodes'] = editionCodes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 欄外下画像更新
         * @param {number} id 
         * @param {string} [name] 欄外下画像名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerUpdate: async (id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageMountControllerUpdate', 'id', id)
            const localVarPath = `/v1/margin-bottom`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
                if (mediaTypes) {
                localVarFormParams.append('mediaTypes', mediaTypes.join(COLLECTION_FORMATS.csv));
            }

                if (imageIds) {
                localVarFormParams.append('imageIds', imageIds.join(COLLECTION_FORMATS.csv));
            }

                if (editionCodes) {
                localVarFormParams.append('editionCodes', editionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (deleteEditionCodes) {
                localVarFormParams.append('deleteEditionCodes', deleteEditionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 欄外下画像の版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} pageMountId pageMountId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerUpdateEditionByCode: async (editionCode: string, pageMountId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionCode' is not null or undefined
            assertParamExists('pageMountControllerUpdateEditionByCode', 'editionCode', editionCode)
            // verify required parameter 'pageMountId' is not null or undefined
            assertParamExists('pageMountControllerUpdateEditionByCode', 'pageMountId', pageMountId)
            const localVarPath = `/v1/margin-bottom/edition-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (editionCode !== undefined) { 
                localVarFormParams.append('editionCode', editionCode as any);
            }
                if (imageIds) {
                localVarFormParams.append('imageIds', imageIds.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

                if (codes) {
                localVarFormParams.append('codes', codes.join(COLLECTION_FORMATS.csv));
            }

    
            if (pageMountId !== undefined) { 
                localVarFormParams.append('pageMountId', pageMountId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarginBottomApi - functional programming interface
 * @export
 */
export const MarginBottomApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarginBottomApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 欄外下画像作成
         * @param {string} name 欄外下画像名
         * @param {Array<string>} [pageMountMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [pageMountByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageMountControllerCreate(name: string, pageMountMediaTypes?: Array<string>, pageMountByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageMountControllerCreate(name, pageMountMediaTypes, pageMountByEditionCodes, images, imageConverts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 欄外下画像削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageMountControllerDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageMountControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 欄外下画像イメージ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageMountControllerDeleteImage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMountImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageMountControllerDeleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 欄外下画像詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageMountControllerGetPageMountById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageMountControllerGetPageMountById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 欄外下画像リスト
         * @param {string} [name] 欄外下画像名
         * @param {number} [limit] limit
         * @param {number} [offset] offset
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageMountControllerList(name?: string, limit?: number, offset?: number, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMountWithCountDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageMountControllerList(name, limit, offset, editionCodes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 欄外下画像更新
         * @param {number} id 
         * @param {string} [name] 欄外下画像名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageMountControllerUpdate(id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageMountControllerUpdate(id, name, mediaTypes, imageIds, editionCodes, deleteEditionCodes, images, imageConverts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 欄外下画像の版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} pageMountId pageMountId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageMountControllerUpdateEditionByCode(editionCode: string, pageMountId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMountResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageMountControllerUpdateEditionByCode(editionCode, pageMountId, imageIds, images, imageConverts, codes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MarginBottomApi - factory interface
 * @export
 */
export const MarginBottomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarginBottomApiFp(configuration)
    return {
        /**
         * 
         * @summary 欄外下画像作成
         * @param {string} name 欄外下画像名
         * @param {Array<string>} [pageMountMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [pageMountByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerCreate(name: string, pageMountMediaTypes?: Array<string>, pageMountByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options?: any): AxiosPromise<PageMountResponseDto> {
            return localVarFp.pageMountControllerCreate(name, pageMountMediaTypes, pageMountByEditionCodes, images, imageConverts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 欄外下画像削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerDelete(id: number, options?: any): AxiosPromise<PageMountResponseDto> {
            return localVarFp.pageMountControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 欄外下画像イメージ削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerDeleteImage(id: number, options?: any): AxiosPromise<PageMountImageResponseDto> {
            return localVarFp.pageMountControllerDeleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 欄外下画像詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerGetPageMountById(id: number, options?: any): AxiosPromise<PageMountResponseDto> {
            return localVarFp.pageMountControllerGetPageMountById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 欄外下画像リスト
         * @param {string} [name] 欄外下画像名
         * @param {number} [limit] limit
         * @param {number} [offset] offset
         * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerList(name?: string, limit?: number, offset?: number, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options?: any): AxiosPromise<PageMountWithCountDto> {
            return localVarFp.pageMountControllerList(name, limit, offset, editionCodes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 欄外下画像更新
         * @param {number} id 
         * @param {string} [name] 欄外下画像名
         * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerUpdate(id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options?: any): AxiosPromise<PageMountResponseDto> {
            return localVarFp.pageMountControllerUpdate(id, name, mediaTypes, imageIds, editionCodes, deleteEditionCodes, images, imageConverts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 欄外下画像の版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} pageMountId pageMountId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageMountControllerUpdateEditionByCode(editionCode: string, pageMountId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: any): AxiosPromise<PageMountResponseDto> {
            return localVarFp.pageMountControllerUpdateEditionByCode(editionCode, pageMountId, imageIds, images, imageConverts, codes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarginBottomApi - object-oriented interface
 * @export
 * @class MarginBottomApi
 * @extends {BaseAPI}
 */
export class MarginBottomApi extends BaseAPI {
    /**
     * 
     * @summary 欄外下画像作成
     * @param {string} name 欄外下画像名
     * @param {Array<string>} [pageMountMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
     * @param {Array<string>} [pageMountByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginBottomApi
     */
    public pageMountControllerCreate(name: string, pageMountMediaTypes?: Array<string>, pageMountByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options?: AxiosRequestConfig) {
        return MarginBottomApiFp(this.configuration).pageMountControllerCreate(name, pageMountMediaTypes, pageMountByEditionCodes, images, imageConverts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 欄外下画像削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginBottomApi
     */
    public pageMountControllerDelete(id: number, options?: AxiosRequestConfig) {
        return MarginBottomApiFp(this.configuration).pageMountControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 欄外下画像イメージ削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginBottomApi
     */
    public pageMountControllerDeleteImage(id: number, options?: AxiosRequestConfig) {
        return MarginBottomApiFp(this.configuration).pageMountControllerDeleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 欄外下画像詳細
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginBottomApi
     */
    public pageMountControllerGetPageMountById(id: number, options?: AxiosRequestConfig) {
        return MarginBottomApiFp(this.configuration).pageMountControllerGetPageMountById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 欄外下画像リスト
     * @param {string} [name] 欄外下画像名
     * @param {number} [limit] limit
     * @param {number} [offset] offset
     * @param {Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginBottomApi
     */
    public pageMountControllerList(name?: string, limit?: number, offset?: number, editionCodes?: Array<'HOKKAIDO' | 'TOUHOKU' | 'JOSHINETSU' | 'KITA_KANTO' | 'KANTO' | 'TOKAI' | 'KANSAI' | 'HOKURIKU' | 'CHUGOKU_SHIKOKU' | 'KYUSHU' | 'KANSAI_HOKURIKU' | 'TOUKAI_HOKURIKU' | 'TEST'>, options?: AxiosRequestConfig) {
        return MarginBottomApiFp(this.configuration).pageMountControllerList(name, limit, offset, editionCodes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 欄外下画像更新
     * @param {number} id 
     * @param {string} [name] 欄外下画像名
     * @param {Array<string>} [mediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
     * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
     * @param {Array<string>} [editionCodes] KANTO,TOHOKUなどをarrayで送る
     * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginBottomApi
     */
    public pageMountControllerUpdate(id: number, name?: string, mediaTypes?: Array<string>, imageIds?: Array<number>, editionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, options?: AxiosRequestConfig) {
        return MarginBottomApiFp(this.configuration).pageMountControllerUpdate(id, name, mediaTypes, imageIds, editionCodes, deleteEditionCodes, images, imageConverts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 欄外下画像の版&画像登録
     * @param {string} editionCode 画像ファイルを登録する版コードを指定する
     * @param {number} pageMountId pageMountId
     * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarginBottomApi
     */
    public pageMountControllerUpdateEditionByCode(editionCode: string, pageMountId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig) {
        return MarginBottomApiFp(this.configuration).pageMountControllerUpdateEditionByCode(editionCode, pageMountId, imageIds, images, imageConverts, codes, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PagesApi - axios parameter creator
 * @export
 */
export const PagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary ページを作成
         * @param {CreatePageDto} createPageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerCreate: async (createPageDto: CreatePageDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPageDto' is not null or undefined
            assertParamExists('pageControllerCreate', 'createPageDto', createPageDto)
            const localVarPath = `/v1/pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ページを作成(宿原稿以外)
         * @param {number} projectId projectID
         * @param {number} bookletId BookletID
         * @param {number} pageNumber ページ番号
         * @param {string} pageTypeCode ページ種別
         * @param {File} image 画像パス
         * @param {number} [pageId] pageId to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerCreateImage: async (projectId: number, bookletId: number, pageNumber: number, pageTypeCode: string, image: File, pageId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('pageControllerCreateImage', 'projectId', projectId)
            // verify required parameter 'bookletId' is not null or undefined
            assertParamExists('pageControllerCreateImage', 'bookletId', bookletId)
            // verify required parameter 'pageNumber' is not null or undefined
            assertParamExists('pageControllerCreateImage', 'pageNumber', pageNumber)
            // verify required parameter 'pageTypeCode' is not null or undefined
            assertParamExists('pageControllerCreateImage', 'pageTypeCode', pageTypeCode)
            // verify required parameter 'image' is not null or undefined
            assertParamExists('pageControllerCreateImage', 'image', image)
            const localVarPath = `/v1/pages/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (pageId !== undefined) { 
                localVarFormParams.append('pageId', pageId as any);
            }
    
            if (projectId !== undefined) { 
                localVarFormParams.append('projectId', projectId as any);
            }
    
            if (bookletId !== undefined) { 
                localVarFormParams.append('bookletId', bookletId as any);
            }
    
            if (pageNumber !== undefined) { 
                localVarFormParams.append('pageNumber', pageNumber as any);
            }
    
            if (pageTypeCode !== undefined) { 
                localVarFormParams.append('pageTypeCode', pageTypeCode as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ページを削除
         * @param {number} id 
         * @param {boolean} noUpdateBooklet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerDelete: async (id: number, noUpdateBooklet: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageControllerDelete', 'id', id)
            // verify required parameter 'noUpdateBooklet' is not null or undefined
            assertParamExists('pageControllerDelete', 'noUpdateBooklet', noUpdateBooklet)
            const localVarPath = `/v1/pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (noUpdateBooklet !== undefined) {
                localVarQueryParameter['noUpdateBooklet'] = noUpdateBooklet;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CopyPageDto} copyPageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerPageCopy: async (copyPageDto: CopyPageDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'copyPageDto' is not null or undefined
            assertParamExists('pageControllerPageCopy', 'copyPageDto', copyPageDto)
            const localVarPath = `/v1/pages/copy-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(copyPageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MovePageRequestDto} movePageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerPageMove: async (movePageRequestDto: MovePageRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movePageRequestDto' is not null or undefined
            assertParamExists('pageControllerPageMove', 'movePageRequestDto', movePageRequestDto)
            const localVarPath = `/v1/pages/page-move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movePageRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ページと原稿を取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerPageWithDocuments: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pageControllerPageWithDocuments', 'id', id)
            const localVarPath = `/v1/pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} bookletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerValidPage: async (bookletId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookletId' is not null or undefined
            assertParamExists('pageControllerValidPage', 'bookletId', bookletId)
            const localVarPath = `/v1/pages/valid-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bookletId !== undefined) {
                localVarQueryParameter['bookletId'] = bookletId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PagesApi - functional programming interface
 * @export
 */
export const PagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary ページを作成
         * @param {CreatePageDto} createPageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageControllerCreate(createPageDto: CreatePageDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageControllerCreate(createPageDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ページを作成(宿原稿以外)
         * @param {number} projectId projectID
         * @param {number} bookletId BookletID
         * @param {number} pageNumber ページ番号
         * @param {string} pageTypeCode ページ種別
         * @param {File} image 画像パス
         * @param {number} [pageId] pageId to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageControllerCreateImage(projectId: number, bookletId: number, pageNumber: number, pageTypeCode: string, image: File, pageId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageControllerCreateImage(projectId, bookletId, pageNumber, pageTypeCode, image, pageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ページを削除
         * @param {number} id 
         * @param {boolean} noUpdateBooklet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageControllerDelete(id: number, noUpdateBooklet: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageControllerDelete(id, noUpdateBooklet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CopyPageDto} copyPageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageControllerPageCopy(copyPageDto: CopyPageDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageForBookletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageControllerPageCopy(copyPageDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MovePageRequestDto} movePageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageControllerPageMove(movePageRequestDto: MovePageRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageForBookletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageControllerPageMove(movePageRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ページと原稿を取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageControllerPageWithDocuments(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageForBookletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageControllerPageWithDocuments(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} bookletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageControllerValidPage(bookletId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageForBookletDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageControllerValidPage(bookletId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PagesApi - factory interface
 * @export
 */
export const PagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PagesApiFp(configuration)
    return {
        /**
         * 
         * @summary ページを作成
         * @param {CreatePageDto} createPageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerCreate(createPageDto: CreatePageDto, options?: any): AxiosPromise<PageResponseDto> {
            return localVarFp.pageControllerCreate(createPageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ページを作成(宿原稿以外)
         * @param {number} projectId projectID
         * @param {number} bookletId BookletID
         * @param {number} pageNumber ページ番号
         * @param {string} pageTypeCode ページ種別
         * @param {File} image 画像パス
         * @param {number} [pageId] pageId to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerCreateImage(projectId: number, bookletId: number, pageNumber: number, pageTypeCode: string, image: File, pageId?: number, options?: any): AxiosPromise<PageResponseDto> {
            return localVarFp.pageControllerCreateImage(projectId, bookletId, pageNumber, pageTypeCode, image, pageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ページを削除
         * @param {number} id 
         * @param {boolean} noUpdateBooklet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerDelete(id: number, noUpdateBooklet: boolean, options?: any): AxiosPromise<PageResponseDto> {
            return localVarFp.pageControllerDelete(id, noUpdateBooklet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CopyPageDto} copyPageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerPageCopy(copyPageDto: CopyPageDto, options?: any): AxiosPromise<PageForBookletDto> {
            return localVarFp.pageControllerPageCopy(copyPageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MovePageRequestDto} movePageRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerPageMove(movePageRequestDto: MovePageRequestDto, options?: any): AxiosPromise<PageForBookletDto> {
            return localVarFp.pageControllerPageMove(movePageRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ページと原稿を取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerPageWithDocuments(id: number, options?: any): AxiosPromise<PageForBookletDto> {
            return localVarFp.pageControllerPageWithDocuments(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} bookletId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageControllerValidPage(bookletId: number, options?: any): AxiosPromise<PageForBookletDto> {
            return localVarFp.pageControllerValidPage(bookletId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PagesApi - object-oriented interface
 * @export
 * @class PagesApi
 * @extends {BaseAPI}
 */
export class PagesApi extends BaseAPI {
    /**
     * 
     * @summary ページを作成
     * @param {CreatePageDto} createPageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageControllerCreate(createPageDto: CreatePageDto, options?: AxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageControllerCreate(createPageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ページを作成(宿原稿以外)
     * @param {number} projectId projectID
     * @param {number} bookletId BookletID
     * @param {number} pageNumber ページ番号
     * @param {string} pageTypeCode ページ種別
     * @param {File} image 画像パス
     * @param {number} [pageId] pageId to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageControllerCreateImage(projectId: number, bookletId: number, pageNumber: number, pageTypeCode: string, image: File, pageId?: number, options?: AxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageControllerCreateImage(projectId, bookletId, pageNumber, pageTypeCode, image, pageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ページを削除
     * @param {number} id 
     * @param {boolean} noUpdateBooklet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageControllerDelete(id: number, noUpdateBooklet: boolean, options?: AxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageControllerDelete(id, noUpdateBooklet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CopyPageDto} copyPageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageControllerPageCopy(copyPageDto: CopyPageDto, options?: AxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageControllerPageCopy(copyPageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MovePageRequestDto} movePageRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageControllerPageMove(movePageRequestDto: MovePageRequestDto, options?: AxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageControllerPageMove(movePageRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ページと原稿を取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageControllerPageWithDocuments(id: number, options?: AxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageControllerPageWithDocuments(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} bookletId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    public pageControllerValidPage(bookletId: number, options?: AxiosRequestConfig) {
        return PagesApiFp(this.configuration).pageControllerValidPage(bookletId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PriceTableApi - axios parameter creator
 * @export
 */
export const PriceTableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {Array<string>} ids List of delete IDs
         * @param {string} editPath 
         * @param {boolean} deleteAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerDelete: async (ids: Array<string>, editPath: string, deleteAll: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('priceTableControllerDelete', 'ids', ids)
            // verify required parameter 'editPath' is not null or undefined
            assertParamExists('priceTableControllerDelete', 'editPath', editPath)
            // verify required parameter 'deleteAll' is not null or undefined
            assertParamExists('priceTableControllerDelete', 'deleteAll', deleteAll)
            const localVarPath = `/v1/price-table`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (editPath !== undefined) {
                localVarQueryParameter['editPath'] = editPath;
            }

            if (deleteAll !== undefined) {
                localVarQueryParameter['deleteAll'] = deleteAll;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerDeleteAllTemp: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/price-table/all-temp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {ExclusionDateDraftDto} exclusionDateDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerExclusionDate: async (exclusionDateDraftDto: ExclusionDateDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exclusionDateDraftDto' is not null or undefined
            assertParamExists('priceTableControllerExclusionDate', 'exclusionDateDraftDto', exclusionDateDraftDto)
            const localVarPath = `/v1/price-table/exclusion-date`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exclusionDateDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MainPlanRegister} mainPlanRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerFeeHeaderRegister: async (mainPlanRegister: MainPlanRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mainPlanRegister' is not null or undefined
            assertParamExists('priceTableControllerFeeHeaderRegister', 'mainPlanRegister', mainPlanRegister)
            const localVarPath = `/v1/price-table/feeHeader/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mainPlanRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetAgeHotelCharge: async (hotelCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('priceTableControllerGetAgeHotelCharge', 'hotelCode', hotelCode)
            const localVarPath = `/v1/price-table/age-hotel-charge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotel_code'] = hotelCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetAgeHotelCharge2: async (hotelCode: string, startDate: string, endDate: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('priceTableControllerGetAgeHotelCharge2', 'hotelCode', hotelCode)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('priceTableControllerGetAgeHotelCharge2', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('priceTableControllerGetAgeHotelCharge2', 'endDate', endDate)
            const localVarPath = `/v1/price-table/age-hotel-charge-2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotel_code'] = hotelCode;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetByDocumentId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('priceTableControllerGetByDocumentId', 'id', id)
            const localVarPath = `/v1/price-table/by-document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetById: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('priceTableControllerGetById', 'id', id)
            const localVarPath = `/v1/price-table/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} mediaYearmonth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetChildrenPrice: async (mediaYearmonth: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaYearmonth' is not null or undefined
            assertParamExists('priceTableControllerGetChildrenPrice', 'mediaYearmonth', mediaYearmonth)
            const localVarPath = `/v1/price-table/children-price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mediaYearmonth !== undefined) {
                localVarQueryParameter['media_yearmonth'] = mediaYearmonth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode hotel code
         * @param {string} mediaYearMonth media_yearmonth
         * @param {boolean} [isMain] get main plan or not
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetEntryTravels: async (hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('priceTableControllerGetEntryTravels', 'hotelCode', hotelCode)
            // verify required parameter 'mediaYearMonth' is not null or undefined
            assertParamExists('priceTableControllerGetEntryTravels', 'mediaYearMonth', mediaYearMonth)
            const localVarPath = `/v1/price-table/entry-plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotelCode'] = hotelCode;
            }

            if (mediaYearMonth !== undefined) {
                localVarQueryParameter['mediaYearMonth'] = mediaYearMonth;
            }

            if (isMain !== undefined) {
                localVarQueryParameter['isMain'] = isMain;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetHotelCharge: async (hotelCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('priceTableControllerGetHotelCharge', 'hotelCode', hotelCode)
            const localVarPath = `/v1/price-table/hotel-charge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotel_code'] = hotelCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} travelPlanCode 
         * @param {string} hotelCode 
         * @param {number} projectId projectID
         * @param {string} [mediaYearMonth] 
         * @param {string} [fromDate] from date
         * @param {string} [toDate] to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetMinFeeMainPlan: async (travelPlanCode: string, hotelCode: string, projectId: number, mediaYearMonth?: string, fromDate?: string, toDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'travelPlanCode' is not null or undefined
            assertParamExists('priceTableControllerGetMinFeeMainPlan', 'travelPlanCode', travelPlanCode)
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('priceTableControllerGetMinFeeMainPlan', 'hotelCode', hotelCode)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('priceTableControllerGetMinFeeMainPlan', 'projectId', projectId)
            const localVarPath = `/v1/price-table/min-fee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (travelPlanCode !== undefined) {
                localVarQueryParameter['travelPlanCode'] = travelPlanCode;
            }

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotel_code'] = hotelCode;
            }

            if (mediaYearMonth !== undefined) {
                localVarQueryParameter['mediaYearMonth'] = mediaYearMonth;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetMonthlyNumber: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/price-table/monthly-number`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetRoomTypes: async (hotelCode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('priceTableControllerGetRoomTypes', 'hotelCode', hotelCode)
            const localVarPath = `/v1/price-table/room-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotelCode'] = hotelCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode hotel code
         * @param {string} mediaYearMonth media_yearmonth
         * @param {boolean} [isMain] get main plan or not
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetTravelPlans: async (hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hotelCode' is not null or undefined
            assertParamExists('priceTableControllerGetTravelPlans', 'hotelCode', hotelCode)
            // verify required parameter 'mediaYearMonth' is not null or undefined
            assertParamExists('priceTableControllerGetTravelPlans', 'mediaYearMonth', mediaYearMonth)
            const localVarPath = `/v1/price-table/travel-plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotelCode'] = hotelCode;
            }

            if (mediaYearMonth !== undefined) {
                localVarQueryParameter['mediaYearMonth'] = mediaYearMonth;
            }

            if (isMain !== undefined) {
                localVarQueryParameter['isMain'] = isMain;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary group day of week in month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGroupDayOfWeek: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/price-table/group-day-of-week`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerList: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/price-table`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {RegisterPriceTableDraftDto} registerPriceTableDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerRegisterDraft: async (registerPriceTableDraftDto: RegisterPriceTableDraftDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerPriceTableDraftDto' is not null or undefined
            assertParamExists('priceTableControllerRegisterDraft', 'registerPriceTableDraftDto', registerPriceTableDraftDto)
            const localVarPath = `/v1/price-table/draft`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPriceTableDraftDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {SaveToIdmlDto} saveToIdmlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerSaveToIdml: async (saveToIdmlDto: SaveToIdmlDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveToIdmlDto' is not null or undefined
            assertParamExists('priceTableControllerSaveToIdml', 'saveToIdmlDto', saveToIdmlDto)
            const localVarPath = `/v1/price-table/save-to-idml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveToIdmlDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {string} [hotelCode] hotelCode
         * @param {Array<string>} [travelPlanCode] travelPlanCode
         * @param {Array<string>} [applicableRoomTypeId] applicableRoomTypeId
         * @param {Array<number>} [numberOfGuestsByRoom] number_of_guests_by_room
         * @param {string} [fromDate] from date
         * @param {string} [toDate] to date
         * @param {string} [mediaYearMonth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerSearch: async (hotelCode?: string, travelPlanCode?: Array<string>, applicableRoomTypeId?: Array<string>, numberOfGuestsByRoom?: Array<number>, fromDate?: string, toDate?: string, mediaYearMonth?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/price-table/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hotelCode !== undefined) {
                localVarQueryParameter['hotelCode'] = hotelCode;
            }

            if (travelPlanCode) {
                localVarQueryParameter['travelPlanCode'] = travelPlanCode;
            }

            if (applicableRoomTypeId) {
                localVarQueryParameter['applicableRoomTypeId'] = applicableRoomTypeId;
            }

            if (numberOfGuestsByRoom) {
                localVarQueryParameter['numberOfGuestsByRoom'] = numberOfGuestsByRoom;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (mediaYearMonth !== undefined) {
                localVarQueryParameter['mediaYearMonth'] = mediaYearMonth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {PriceTableUpdateDocument} priceTableUpdateDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerUpdatePriceTable: async (priceTableUpdateDocument: PriceTableUpdateDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priceTableUpdateDocument' is not null or undefined
            assertParamExists('priceTableControllerUpdatePriceTable', 'priceTableUpdateDocument', priceTableUpdateDocument)
            const localVarPath = `/v1/price-table/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(priceTableUpdateDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PriceTableApi - functional programming interface
 * @export
 */
export const PriceTableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PriceTableApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {Array<string>} ids List of delete IDs
         * @param {string} editPath 
         * @param {boolean} deleteAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerDelete(ids: Array<string>, editPath: string, deleteAll: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerDelete(ids, editPath, deleteAll, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerDeleteAllTemp(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerDeleteAllTemp(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {ExclusionDateDraftDto} exclusionDateDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerExclusionDate(exclusionDateDraftDto: ExclusionDateDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerExclusionDate(exclusionDateDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MainPlanRegister} mainPlanRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerFeeHeaderRegister(mainPlanRegister: MainPlanRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerFeeHeaderRegister(mainPlanRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetAgeHotelCharge(hotelCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HotelAgeChargeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetAgeHotelCharge(hotelCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetAgeHotelCharge2(hotelCode: string, startDate: string, endDate: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HotelChargeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetAgeHotelCharge2(hotelCode, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetByDocumentId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PriceTableResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetByDocumentId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetById(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} mediaYearmonth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetChildrenPrice(mediaYearmonth: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetChildrenPrice(mediaYearmonth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode hotel code
         * @param {string} mediaYearMonth media_yearmonth
         * @param {boolean} [isMain] get main plan or not
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetEntryTravels(hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EntryPlanReponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetEntryTravels(hotelCode, mediaYearMonth, isMain, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetHotelCharge(hotelCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetHotelCharge(hotelCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} travelPlanCode 
         * @param {string} hotelCode 
         * @param {number} projectId projectID
         * @param {string} [mediaYearMonth] 
         * @param {string} [fromDate] from date
         * @param {string} [toDate] to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetMinFeeMainPlan(travelPlanCode: string, hotelCode: string, projectId: number, mediaYearMonth?: string, fromDate?: string, toDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetMinFeeMainPlan(travelPlanCode, hotelCode, projectId, mediaYearMonth, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetMonthlyNumber(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TravelPlanDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetMonthlyNumber(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetRoomTypes(hotelCode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomTypesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetRoomTypes(hotelCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode hotel code
         * @param {string} mediaYearMonth media_yearmonth
         * @param {boolean} [isMain] get main plan or not
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGetTravelPlans(hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TravelPlanDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGetTravelPlans(hotelCode, mediaYearMonth, isMain, skip, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary group day of week in month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerGroupDayOfWeek(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerGroupDayOfWeek(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerList(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerList(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {RegisterPriceTableDraftDto} registerPriceTableDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerRegisterDraft(registerPriceTableDraftDto: RegisterPriceTableDraftDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerRegisterDraft(registerPriceTableDraftDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {SaveToIdmlDto} saveToIdmlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerSaveToIdml(saveToIdmlDto: SaveToIdmlDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerSaveToIdml(saveToIdmlDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {string} [hotelCode] hotelCode
         * @param {Array<string>} [travelPlanCode] travelPlanCode
         * @param {Array<string>} [applicableRoomTypeId] applicableRoomTypeId
         * @param {Array<number>} [numberOfGuestsByRoom] number_of_guests_by_room
         * @param {string} [fromDate] from date
         * @param {string} [toDate] to date
         * @param {string} [mediaYearMonth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerSearch(hotelCode?: string, travelPlanCode?: Array<string>, applicableRoomTypeId?: Array<string>, numberOfGuestsByRoom?: Array<number>, fromDate?: string, toDate?: string, mediaYearMonth?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerSearch(hotelCode, travelPlanCode, applicableRoomTypeId, numberOfGuestsByRoom, fromDate, toDate, mediaYearMonth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {PriceTableUpdateDocument} priceTableUpdateDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceTableControllerUpdatePriceTable(priceTableUpdateDocument: PriceTableUpdateDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.priceTableControllerUpdatePriceTable(priceTableUpdateDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PriceTableApi - factory interface
 * @export
 */
export const PriceTableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PriceTableApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {Array<string>} ids List of delete IDs
         * @param {string} editPath 
         * @param {boolean} deleteAll 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerDelete(ids: Array<string>, editPath: string, deleteAll: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerDelete(ids, editPath, deleteAll, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerDeleteAllTemp(options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerDeleteAllTemp(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {ExclusionDateDraftDto} exclusionDateDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerExclusionDate(exclusionDateDraftDto: ExclusionDateDraftDto, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerExclusionDate(exclusionDateDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MainPlanRegister} mainPlanRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerFeeHeaderRegister(mainPlanRegister: MainPlanRegister, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerFeeHeaderRegister(mainPlanRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetAgeHotelCharge(hotelCode: string, options?: any): AxiosPromise<Array<HotelAgeChargeDto>> {
            return localVarFp.priceTableControllerGetAgeHotelCharge(hotelCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {string} startDate 
         * @param {string} endDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetAgeHotelCharge2(hotelCode: string, startDate: string, endDate: string, options?: any): AxiosPromise<HotelChargeResponseDto> {
            return localVarFp.priceTableControllerGetAgeHotelCharge2(hotelCode, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetByDocumentId(id: number, options?: any): AxiosPromise<Array<PriceTableResponseDto>> {
            return localVarFp.priceTableControllerGetByDocumentId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetById(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} mediaYearmonth 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetChildrenPrice(mediaYearmonth: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.priceTableControllerGetChildrenPrice(mediaYearmonth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode hotel code
         * @param {string} mediaYearMonth media_yearmonth
         * @param {boolean} [isMain] get main plan or not
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetEntryTravels(hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options?: any): AxiosPromise<Array<EntryPlanReponseDto>> {
            return localVarFp.priceTableControllerGetEntryTravels(hotelCode, mediaYearMonth, isMain, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetHotelCharge(hotelCode: string, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerGetHotelCharge(hotelCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} travelPlanCode 
         * @param {string} hotelCode 
         * @param {number} projectId projectID
         * @param {string} [mediaYearMonth] 
         * @param {string} [fromDate] from date
         * @param {string} [toDate] to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetMinFeeMainPlan(travelPlanCode: string, hotelCode: string, projectId: number, mediaYearMonth?: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<number> {
            return localVarFp.priceTableControllerGetMinFeeMainPlan(travelPlanCode, hotelCode, projectId, mediaYearMonth, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetMonthlyNumber(options?: any): AxiosPromise<Array<TravelPlanDto>> {
            return localVarFp.priceTableControllerGetMonthlyNumber(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetRoomTypes(hotelCode: string, options?: any): AxiosPromise<RoomTypesDto> {
            return localVarFp.priceTableControllerGetRoomTypes(hotelCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} hotelCode hotel code
         * @param {string} mediaYearMonth media_yearmonth
         * @param {boolean} [isMain] get main plan or not
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGetTravelPlans(hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options?: any): AxiosPromise<Array<TravelPlanDto>> {
            return localVarFp.priceTableControllerGetTravelPlans(hotelCode, mediaYearMonth, isMain, skip, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary group day of week in month
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerGroupDayOfWeek(options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerGroupDayOfWeek(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerList(take?: number, skip?: number, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerList(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {RegisterPriceTableDraftDto} registerPriceTableDraftDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerRegisterDraft(registerPriceTableDraftDto: RegisterPriceTableDraftDto, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerRegisterDraft(registerPriceTableDraftDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {SaveToIdmlDto} saveToIdmlDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerSaveToIdml(saveToIdmlDto: SaveToIdmlDto, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerSaveToIdml(saveToIdmlDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {string} [hotelCode] hotelCode
         * @param {Array<string>} [travelPlanCode] travelPlanCode
         * @param {Array<string>} [applicableRoomTypeId] applicableRoomTypeId
         * @param {Array<number>} [numberOfGuestsByRoom] number_of_guests_by_room
         * @param {string} [fromDate] from date
         * @param {string} [toDate] to date
         * @param {string} [mediaYearMonth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerSearch(hotelCode?: string, travelPlanCode?: Array<string>, applicableRoomTypeId?: Array<string>, numberOfGuestsByRoom?: Array<number>, fromDate?: string, toDate?: string, mediaYearMonth?: string, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerSearch(hotelCode, travelPlanCode, applicableRoomTypeId, numberOfGuestsByRoom, fromDate, toDate, mediaYearMonth, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {PriceTableUpdateDocument} priceTableUpdateDocument 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceTableControllerUpdatePriceTable(priceTableUpdateDocument: PriceTableUpdateDocument, options?: any): AxiosPromise<void> {
            return localVarFp.priceTableControllerUpdatePriceTable(priceTableUpdateDocument, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PriceTableApi - object-oriented interface
 * @export
 * @class PriceTableApi
 * @extends {BaseAPI}
 */
export class PriceTableApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {Array<string>} ids List of delete IDs
     * @param {string} editPath 
     * @param {boolean} deleteAll 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerDelete(ids: Array<string>, editPath: string, deleteAll: boolean, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerDelete(ids, editPath, deleteAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerDeleteAllTemp(options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerDeleteAllTemp(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {ExclusionDateDraftDto} exclusionDateDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerExclusionDate(exclusionDateDraftDto: ExclusionDateDraftDto, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerExclusionDate(exclusionDateDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MainPlanRegister} mainPlanRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerFeeHeaderRegister(mainPlanRegister: MainPlanRegister, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerFeeHeaderRegister(mainPlanRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} hotelCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetAgeHotelCharge(hotelCode: string, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetAgeHotelCharge(hotelCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} hotelCode 
     * @param {string} startDate 
     * @param {string} endDate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetAgeHotelCharge2(hotelCode: string, startDate: string, endDate: string, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetAgeHotelCharge2(hotelCode, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetByDocumentId(id: number, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetByDocumentId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetById(id: number, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} mediaYearmonth 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetChildrenPrice(mediaYearmonth: string, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetChildrenPrice(mediaYearmonth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} hotelCode hotel code
     * @param {string} mediaYearMonth media_yearmonth
     * @param {boolean} [isMain] get main plan or not
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetEntryTravels(hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetEntryTravels(hotelCode, mediaYearMonth, isMain, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} hotelCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetHotelCharge(hotelCode: string, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetHotelCharge(hotelCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} travelPlanCode 
     * @param {string} hotelCode 
     * @param {number} projectId projectID
     * @param {string} [mediaYearMonth] 
     * @param {string} [fromDate] from date
     * @param {string} [toDate] to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetMinFeeMainPlan(travelPlanCode: string, hotelCode: string, projectId: number, mediaYearMonth?: string, fromDate?: string, toDate?: string, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetMinFeeMainPlan(travelPlanCode, hotelCode, projectId, mediaYearMonth, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetMonthlyNumber(options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetMonthlyNumber(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} hotelCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetRoomTypes(hotelCode: string, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetRoomTypes(hotelCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} hotelCode hotel code
     * @param {string} mediaYearMonth media_yearmonth
     * @param {boolean} [isMain] get main plan or not
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGetTravelPlans(hotelCode: string, mediaYearMonth: string, isMain?: boolean, skip?: number, limit?: number, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGetTravelPlans(hotelCode, mediaYearMonth, isMain, skip, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary group day of week in month
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerGroupDayOfWeek(options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerGroupDayOfWeek(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerList(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerList(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {RegisterPriceTableDraftDto} registerPriceTableDraftDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerRegisterDraft(registerPriceTableDraftDto: RegisterPriceTableDraftDto, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerRegisterDraft(registerPriceTableDraftDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {SaveToIdmlDto} saveToIdmlDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerSaveToIdml(saveToIdmlDto: SaveToIdmlDto, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerSaveToIdml(saveToIdmlDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {string} [hotelCode] hotelCode
     * @param {Array<string>} [travelPlanCode] travelPlanCode
     * @param {Array<string>} [applicableRoomTypeId] applicableRoomTypeId
     * @param {Array<number>} [numberOfGuestsByRoom] number_of_guests_by_room
     * @param {string} [fromDate] from date
     * @param {string} [toDate] to date
     * @param {string} [mediaYearMonth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerSearch(hotelCode?: string, travelPlanCode?: Array<string>, applicableRoomTypeId?: Array<string>, numberOfGuestsByRoom?: Array<number>, fromDate?: string, toDate?: string, mediaYearMonth?: string, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerSearch(hotelCode, travelPlanCode, applicableRoomTypeId, numberOfGuestsByRoom, fromDate, toDate, mediaYearMonth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {PriceTableUpdateDocument} priceTableUpdateDocument 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PriceTableApi
     */
    public priceTableControllerUpdatePriceTable(priceTableUpdateDocument: PriceTableUpdateDocument, options?: AxiosRequestConfig) {
        return PriceTableApiFp(this.configuration).priceTableControllerUpdatePriceTable(priceTableUpdateDocument, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary プロジェクト作成
         * @param {CreateProjectWithEditionCodeDto} createProjectWithEditionCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate: async (createProjectWithEditionCodeDto: CreateProjectWithEditionCodeDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createProjectWithEditionCodeDto' is not null or undefined
            assertParamExists('projectControllerCreate', 'createProjectWithEditionCodeDto', createProjectWithEditionCodeDto)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createProjectWithEditionCodeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロジェクトの削除
         * @param {number} id プロジェクトid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerDelete', 'id', id)
            const localVarPath = `/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロジェクト取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDetails: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerDetails', 'id', id)
            const localVarPath = `/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 複製プロジェクト
         * @param {DuplicateProjectDto} duplicateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDuplicate: async (duplicateProjectDto: DuplicateProjectDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'duplicateProjectDto' is not null or undefined
            assertParamExists('projectControllerDuplicate', 'duplicateProjectDto', duplicateProjectDto)
            const localVarPath = `/v1/projects/copy-project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duplicateProjectDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetIssueProject: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/projects/project-issue-list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロジェクト一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerList: async (take?: number, skip?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロジェクト設定更新
         * @param {number} id プロジェクトid
         * @param {string} salesStartDate 販売開始日
         * @param {string} salesEndDate 販売終了日
         * @param {string} reviewRatingStartDate 口コミ評価開始日
         * @param {string} reviewRatingEndDate 口コミ評価終了日
         * @param {Array<string>} bookletEnables 有効にする版コードを配列で登録するKANTO,TOHOKUなどをカンマ区切りで送る
         * @param {number} [thumbIndexId] ツメ見出しid
         * @param {number} [headLineId] 見出しid
         * @param {File} [openAirIconOn] 露天アイコンOn
         * @param {File} [openAirIconOff] 露天アイコンOff
         * @param {File} [freeFlowingIconOn] かけ流しアイコンOn
         * @param {File} [freeFlowingIconOff] かけ流しアイコンOff
         * @param {File} [elevatorIconOn] エレベーターアイコンOn
         * @param {File} [elevatorIconOff] エレベーターアイコンOff
         * @param {File} [sameDayReservationIconOn] 当日予約アイコンOn
         * @param {File} [sameDayReservationIconOff] 当日予約アイコンOff
         * @param {File} [pickUpAvailableIconOn] 送迎有アイコンOn
         * @param {File} [pickUpAvailableIconOff] 送迎有アイコンOff
         * @param {File} [noSmokingIconOn] 禁煙アイコンOn
         * @param {File} [noSmokingIconOff] 禁煙アイコンOff
         * @param {File} [dinnerVenueMeal] 夕食:会場食
         * @param {File} [dinnerPrivateRoomDining] 夕食:個室会場食
         * @param {File} [dinnerRoomMeal] 夕食:部屋食
         * @param {File} [dinnerVenueMealOorPrivateDiningRoom] 夕食:会場食または個室会場食
         * @param {File} [dinnerVenueMealOrRoomService] 夕食:会場食または部屋食
         * @param {File} [dinnerRoomOrPrivateDiningRoom] 夕食:部屋食または個室会場食
         * @param {File} [dinnerNone] 夕食:なし
         * @param {File} [breakfastVenueMeal] 朝食:会場食
         * @param {File} [breakfastPrivateRoomDining] 朝食:個室会場食
         * @param {File} [breakfastRoomMeal] 朝食:部屋食
         * @param {File} [breakfastVenueMealOorPrivateDiningRoom] 朝食:会場食または個室会場食
         * @param {File} [breakfastVenueMealOrRoomService] 朝食:会場食または部屋食
         * @param {File} [breakfastRoomOrPrivateDiningRoom] 朝食:部屋食または個室会場食
         * @param {File} [breakfastNone] 朝食:なし
         * @param {File} [issueDataImage] 月号データ
         * @param {string} [consumptionTax] consumption tax
         * @param {number} [tax] 税率
         * @param {number} [pageMountId] 欄外下画像id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerProjectSetting: async (id: number, salesStartDate: string, salesEndDate: string, reviewRatingStartDate: string, reviewRatingEndDate: string, bookletEnables: Array<string>, thumbIndexId?: number, headLineId?: number, openAirIconOn?: File, openAirIconOff?: File, freeFlowingIconOn?: File, freeFlowingIconOff?: File, elevatorIconOn?: File, elevatorIconOff?: File, sameDayReservationIconOn?: File, sameDayReservationIconOff?: File, pickUpAvailableIconOn?: File, pickUpAvailableIconOff?: File, noSmokingIconOn?: File, noSmokingIconOff?: File, dinnerVenueMeal?: File, dinnerPrivateRoomDining?: File, dinnerRoomMeal?: File, dinnerVenueMealOorPrivateDiningRoom?: File, dinnerVenueMealOrRoomService?: File, dinnerRoomOrPrivateDiningRoom?: File, dinnerNone?: File, breakfastVenueMeal?: File, breakfastPrivateRoomDining?: File, breakfastRoomMeal?: File, breakfastVenueMealOorPrivateDiningRoom?: File, breakfastVenueMealOrRoomService?: File, breakfastRoomOrPrivateDiningRoom?: File, breakfastNone?: File, issueDataImage?: File, consumptionTax?: string, tax?: number, pageMountId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('projectControllerProjectSetting', 'id', id)
            // verify required parameter 'salesStartDate' is not null or undefined
            assertParamExists('projectControllerProjectSetting', 'salesStartDate', salesStartDate)
            // verify required parameter 'salesEndDate' is not null or undefined
            assertParamExists('projectControllerProjectSetting', 'salesEndDate', salesEndDate)
            // verify required parameter 'reviewRatingStartDate' is not null or undefined
            assertParamExists('projectControllerProjectSetting', 'reviewRatingStartDate', reviewRatingStartDate)
            // verify required parameter 'reviewRatingEndDate' is not null or undefined
            assertParamExists('projectControllerProjectSetting', 'reviewRatingEndDate', reviewRatingEndDate)
            // verify required parameter 'bookletEnables' is not null or undefined
            assertParamExists('projectControllerProjectSetting', 'bookletEnables', bookletEnables)
            const localVarPath = `/v1/projects/project-setting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (salesStartDate !== undefined) { 
                localVarFormParams.append('salesStartDate', salesStartDate as any);
            }
    
            if (salesEndDate !== undefined) { 
                localVarFormParams.append('salesEndDate', salesEndDate as any);
            }
    
            if (reviewRatingStartDate !== undefined) { 
                localVarFormParams.append('reviewRatingStartDate', reviewRatingStartDate as any);
            }
    
            if (reviewRatingEndDate !== undefined) { 
                localVarFormParams.append('reviewRatingEndDate', reviewRatingEndDate as any);
            }
    
            if (thumbIndexId !== undefined) { 
                localVarFormParams.append('thumbIndexId', thumbIndexId as any);
            }
    
            if (headLineId !== undefined) { 
                localVarFormParams.append('headLineId', headLineId as any);
            }
    
            if (openAirIconOn !== undefined) { 
                localVarFormParams.append('openAirIconOn', openAirIconOn as any);
            }
    
            if (openAirIconOff !== undefined) { 
                localVarFormParams.append('openAirIconOff', openAirIconOff as any);
            }
    
            if (freeFlowingIconOn !== undefined) { 
                localVarFormParams.append('freeFlowingIconOn', freeFlowingIconOn as any);
            }
    
            if (freeFlowingIconOff !== undefined) { 
                localVarFormParams.append('freeFlowingIconOff', freeFlowingIconOff as any);
            }
    
            if (elevatorIconOn !== undefined) { 
                localVarFormParams.append('elevatorIconOn', elevatorIconOn as any);
            }
    
            if (elevatorIconOff !== undefined) { 
                localVarFormParams.append('elevatorIconOff', elevatorIconOff as any);
            }
    
            if (sameDayReservationIconOn !== undefined) { 
                localVarFormParams.append('sameDayReservationIconOn', sameDayReservationIconOn as any);
            }
    
            if (sameDayReservationIconOff !== undefined) { 
                localVarFormParams.append('sameDayReservationIconOff', sameDayReservationIconOff as any);
            }
    
            if (pickUpAvailableIconOn !== undefined) { 
                localVarFormParams.append('pickUpAvailableIconOn', pickUpAvailableIconOn as any);
            }
    
            if (pickUpAvailableIconOff !== undefined) { 
                localVarFormParams.append('pickUpAvailableIconOff', pickUpAvailableIconOff as any);
            }
    
            if (noSmokingIconOn !== undefined) { 
                localVarFormParams.append('noSmokingIconOn', noSmokingIconOn as any);
            }
    
            if (noSmokingIconOff !== undefined) { 
                localVarFormParams.append('noSmokingIconOff', noSmokingIconOff as any);
            }
    
            if (dinnerVenueMeal !== undefined) { 
                localVarFormParams.append('dinnerVenueMeal', dinnerVenueMeal as any);
            }
    
            if (dinnerPrivateRoomDining !== undefined) { 
                localVarFormParams.append('dinnerPrivateRoomDining', dinnerPrivateRoomDining as any);
            }
    
            if (dinnerRoomMeal !== undefined) { 
                localVarFormParams.append('dinnerRoomMeal', dinnerRoomMeal as any);
            }
    
            if (dinnerVenueMealOorPrivateDiningRoom !== undefined) { 
                localVarFormParams.append('dinnerVenueMealOorPrivateDiningRoom', dinnerVenueMealOorPrivateDiningRoom as any);
            }
    
            if (dinnerVenueMealOrRoomService !== undefined) { 
                localVarFormParams.append('dinnerVenueMealOrRoomService', dinnerVenueMealOrRoomService as any);
            }
    
            if (dinnerRoomOrPrivateDiningRoom !== undefined) { 
                localVarFormParams.append('dinnerRoomOrPrivateDiningRoom', dinnerRoomOrPrivateDiningRoom as any);
            }
    
            if (dinnerNone !== undefined) { 
                localVarFormParams.append('dinnerNone', dinnerNone as any);
            }
    
            if (breakfastVenueMeal !== undefined) { 
                localVarFormParams.append('breakfastVenueMeal', breakfastVenueMeal as any);
            }
    
            if (breakfastPrivateRoomDining !== undefined) { 
                localVarFormParams.append('breakfastPrivateRoomDining', breakfastPrivateRoomDining as any);
            }
    
            if (breakfastRoomMeal !== undefined) { 
                localVarFormParams.append('breakfastRoomMeal', breakfastRoomMeal as any);
            }
    
            if (breakfastVenueMealOorPrivateDiningRoom !== undefined) { 
                localVarFormParams.append('breakfastVenueMealOorPrivateDiningRoom', breakfastVenueMealOorPrivateDiningRoom as any);
            }
    
            if (breakfastVenueMealOrRoomService !== undefined) { 
                localVarFormParams.append('breakfastVenueMealOrRoomService', breakfastVenueMealOrRoomService as any);
            }
    
            if (breakfastRoomOrPrivateDiningRoom !== undefined) { 
                localVarFormParams.append('breakfastRoomOrPrivateDiningRoom', breakfastRoomOrPrivateDiningRoom as any);
            }
    
            if (breakfastNone !== undefined) { 
                localVarFormParams.append('breakfastNone', breakfastNone as any);
            }
    
            if (issueDataImage !== undefined) { 
                localVarFormParams.append('issueDataImage', issueDataImage as any);
            }
                if (bookletEnables) {
                localVarFormParams.append('bookletEnables', bookletEnables.join(COLLECTION_FORMATS.csv));
            }

    
            if (consumptionTax !== undefined) { 
                localVarFormParams.append('consumptionTax', consumptionTax as any);
            }
    
            if (tax !== undefined) { 
                localVarFormParams.append('tax', tax as any);
            }
    
            if (pageMountId !== undefined) { 
                localVarFormParams.append('pageMountId', pageMountId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary プロジェクト年月の更新
         * @param {ProjectIssueDto} projectIssueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate: async (projectIssueDto: ProjectIssueDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectIssueDto' is not null or undefined
            assertParamExists('projectControllerUpdate', 'projectIssueDto', projectIssueDto)
            const localVarPath = `/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectIssueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary プロジェクト作成
         * @param {CreateProjectWithEditionCodeDto} createProjectWithEditionCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerCreate(createProjectWithEditionCodeDto: CreateProjectWithEditionCodeDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectCreatedResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerCreate(createProjectWithEditionCodeDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary プロジェクトの削除
         * @param {number} id プロジェクトid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary プロジェクト取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDetails(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsWithImagesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDetails(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 複製プロジェクト
         * @param {DuplicateProjectDto} duplicateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerDuplicate(duplicateProjectDto: DuplicateProjectDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerDuplicate(duplicateProjectDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerGetIssueProject(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectIssueYearMonth>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerGetIssueProject(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary プロジェクト一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerList(take?: number, skip?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectWithCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerList(take, skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary プロジェクト設定更新
         * @param {number} id プロジェクトid
         * @param {string} salesStartDate 販売開始日
         * @param {string} salesEndDate 販売終了日
         * @param {string} reviewRatingStartDate 口コミ評価開始日
         * @param {string} reviewRatingEndDate 口コミ評価終了日
         * @param {Array<string>} bookletEnables 有効にする版コードを配列で登録するKANTO,TOHOKUなどをカンマ区切りで送る
         * @param {number} [thumbIndexId] ツメ見出しid
         * @param {number} [headLineId] 見出しid
         * @param {File} [openAirIconOn] 露天アイコンOn
         * @param {File} [openAirIconOff] 露天アイコンOff
         * @param {File} [freeFlowingIconOn] かけ流しアイコンOn
         * @param {File} [freeFlowingIconOff] かけ流しアイコンOff
         * @param {File} [elevatorIconOn] エレベーターアイコンOn
         * @param {File} [elevatorIconOff] エレベーターアイコンOff
         * @param {File} [sameDayReservationIconOn] 当日予約アイコンOn
         * @param {File} [sameDayReservationIconOff] 当日予約アイコンOff
         * @param {File} [pickUpAvailableIconOn] 送迎有アイコンOn
         * @param {File} [pickUpAvailableIconOff] 送迎有アイコンOff
         * @param {File} [noSmokingIconOn] 禁煙アイコンOn
         * @param {File} [noSmokingIconOff] 禁煙アイコンOff
         * @param {File} [dinnerVenueMeal] 夕食:会場食
         * @param {File} [dinnerPrivateRoomDining] 夕食:個室会場食
         * @param {File} [dinnerRoomMeal] 夕食:部屋食
         * @param {File} [dinnerVenueMealOorPrivateDiningRoom] 夕食:会場食または個室会場食
         * @param {File} [dinnerVenueMealOrRoomService] 夕食:会場食または部屋食
         * @param {File} [dinnerRoomOrPrivateDiningRoom] 夕食:部屋食または個室会場食
         * @param {File} [dinnerNone] 夕食:なし
         * @param {File} [breakfastVenueMeal] 朝食:会場食
         * @param {File} [breakfastPrivateRoomDining] 朝食:個室会場食
         * @param {File} [breakfastRoomMeal] 朝食:部屋食
         * @param {File} [breakfastVenueMealOorPrivateDiningRoom] 朝食:会場食または個室会場食
         * @param {File} [breakfastVenueMealOrRoomService] 朝食:会場食または部屋食
         * @param {File} [breakfastRoomOrPrivateDiningRoom] 朝食:部屋食または個室会場食
         * @param {File} [breakfastNone] 朝食:なし
         * @param {File} [issueDataImage] 月号データ
         * @param {string} [consumptionTax] consumption tax
         * @param {number} [tax] 税率
         * @param {number} [pageMountId] 欄外下画像id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerProjectSetting(id: number, salesStartDate: string, salesEndDate: string, reviewRatingStartDate: string, reviewRatingEndDate: string, bookletEnables: Array<string>, thumbIndexId?: number, headLineId?: number, openAirIconOn?: File, openAirIconOff?: File, freeFlowingIconOn?: File, freeFlowingIconOff?: File, elevatorIconOn?: File, elevatorIconOff?: File, sameDayReservationIconOn?: File, sameDayReservationIconOff?: File, pickUpAvailableIconOn?: File, pickUpAvailableIconOff?: File, noSmokingIconOn?: File, noSmokingIconOff?: File, dinnerVenueMeal?: File, dinnerPrivateRoomDining?: File, dinnerRoomMeal?: File, dinnerVenueMealOorPrivateDiningRoom?: File, dinnerVenueMealOrRoomService?: File, dinnerRoomOrPrivateDiningRoom?: File, dinnerNone?: File, breakfastVenueMeal?: File, breakfastPrivateRoomDining?: File, breakfastRoomMeal?: File, breakfastVenueMealOorPrivateDiningRoom?: File, breakfastVenueMealOrRoomService?: File, breakfastRoomOrPrivateDiningRoom?: File, breakfastNone?: File, issueDataImage?: File, consumptionTax?: string, tax?: number, pageMountId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectWithXlsFilesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerProjectSetting(id, salesStartDate, salesEndDate, reviewRatingStartDate, reviewRatingEndDate, bookletEnables, thumbIndexId, headLineId, openAirIconOn, openAirIconOff, freeFlowingIconOn, freeFlowingIconOff, elevatorIconOn, elevatorIconOff, sameDayReservationIconOn, sameDayReservationIconOff, pickUpAvailableIconOn, pickUpAvailableIconOff, noSmokingIconOn, noSmokingIconOff, dinnerVenueMeal, dinnerPrivateRoomDining, dinnerRoomMeal, dinnerVenueMealOorPrivateDiningRoom, dinnerVenueMealOrRoomService, dinnerRoomOrPrivateDiningRoom, dinnerNone, breakfastVenueMeal, breakfastPrivateRoomDining, breakfastRoomMeal, breakfastVenueMealOorPrivateDiningRoom, breakfastVenueMealOrRoomService, breakfastRoomOrPrivateDiningRoom, breakfastNone, issueDataImage, consumptionTax, tax, pageMountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary プロジェクト年月の更新
         * @param {ProjectIssueDto} projectIssueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectControllerUpdate(projectIssueDto: ProjectIssueDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectControllerUpdate(projectIssueDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @summary プロジェクト作成
         * @param {CreateProjectWithEditionCodeDto} createProjectWithEditionCodeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerCreate(createProjectWithEditionCodeDto: CreateProjectWithEditionCodeDto, options?: any): AxiosPromise<ProjectCreatedResponseDto> {
            return localVarFp.projectControllerCreate(createProjectWithEditionCodeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロジェクトの削除
         * @param {number} id プロジェクトid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDelete(id: number, options?: any): AxiosPromise<ProjectResponseDto> {
            return localVarFp.projectControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロジェクト取得
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDetails(id: number, options?: any): AxiosPromise<ProjectsWithImagesResponseDto> {
            return localVarFp.projectControllerDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 複製プロジェクト
         * @param {DuplicateProjectDto} duplicateProjectDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerDuplicate(duplicateProjectDto: DuplicateProjectDto, options?: any): AxiosPromise<ProjectResponseDto> {
            return localVarFp.projectControllerDuplicate(duplicateProjectDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerGetIssueProject(options?: any): AxiosPromise<Array<ProjectIssueYearMonth>> {
            return localVarFp.projectControllerGetIssueProject(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロジェクト一覧取得
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerList(take?: number, skip?: number, options?: any): AxiosPromise<ProjectWithCountResponse> {
            return localVarFp.projectControllerList(take, skip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロジェクト設定更新
         * @param {number} id プロジェクトid
         * @param {string} salesStartDate 販売開始日
         * @param {string} salesEndDate 販売終了日
         * @param {string} reviewRatingStartDate 口コミ評価開始日
         * @param {string} reviewRatingEndDate 口コミ評価終了日
         * @param {Array<string>} bookletEnables 有効にする版コードを配列で登録するKANTO,TOHOKUなどをカンマ区切りで送る
         * @param {number} [thumbIndexId] ツメ見出しid
         * @param {number} [headLineId] 見出しid
         * @param {File} [openAirIconOn] 露天アイコンOn
         * @param {File} [openAirIconOff] 露天アイコンOff
         * @param {File} [freeFlowingIconOn] かけ流しアイコンOn
         * @param {File} [freeFlowingIconOff] かけ流しアイコンOff
         * @param {File} [elevatorIconOn] エレベーターアイコンOn
         * @param {File} [elevatorIconOff] エレベーターアイコンOff
         * @param {File} [sameDayReservationIconOn] 当日予約アイコンOn
         * @param {File} [sameDayReservationIconOff] 当日予約アイコンOff
         * @param {File} [pickUpAvailableIconOn] 送迎有アイコンOn
         * @param {File} [pickUpAvailableIconOff] 送迎有アイコンOff
         * @param {File} [noSmokingIconOn] 禁煙アイコンOn
         * @param {File} [noSmokingIconOff] 禁煙アイコンOff
         * @param {File} [dinnerVenueMeal] 夕食:会場食
         * @param {File} [dinnerPrivateRoomDining] 夕食:個室会場食
         * @param {File} [dinnerRoomMeal] 夕食:部屋食
         * @param {File} [dinnerVenueMealOorPrivateDiningRoom] 夕食:会場食または個室会場食
         * @param {File} [dinnerVenueMealOrRoomService] 夕食:会場食または部屋食
         * @param {File} [dinnerRoomOrPrivateDiningRoom] 夕食:部屋食または個室会場食
         * @param {File} [dinnerNone] 夕食:なし
         * @param {File} [breakfastVenueMeal] 朝食:会場食
         * @param {File} [breakfastPrivateRoomDining] 朝食:個室会場食
         * @param {File} [breakfastRoomMeal] 朝食:部屋食
         * @param {File} [breakfastVenueMealOorPrivateDiningRoom] 朝食:会場食または個室会場食
         * @param {File} [breakfastVenueMealOrRoomService] 朝食:会場食または部屋食
         * @param {File} [breakfastRoomOrPrivateDiningRoom] 朝食:部屋食または個室会場食
         * @param {File} [breakfastNone] 朝食:なし
         * @param {File} [issueDataImage] 月号データ
         * @param {string} [consumptionTax] consumption tax
         * @param {number} [tax] 税率
         * @param {number} [pageMountId] 欄外下画像id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerProjectSetting(id: number, salesStartDate: string, salesEndDate: string, reviewRatingStartDate: string, reviewRatingEndDate: string, bookletEnables: Array<string>, thumbIndexId?: number, headLineId?: number, openAirIconOn?: File, openAirIconOff?: File, freeFlowingIconOn?: File, freeFlowingIconOff?: File, elevatorIconOn?: File, elevatorIconOff?: File, sameDayReservationIconOn?: File, sameDayReservationIconOff?: File, pickUpAvailableIconOn?: File, pickUpAvailableIconOff?: File, noSmokingIconOn?: File, noSmokingIconOff?: File, dinnerVenueMeal?: File, dinnerPrivateRoomDining?: File, dinnerRoomMeal?: File, dinnerVenueMealOorPrivateDiningRoom?: File, dinnerVenueMealOrRoomService?: File, dinnerRoomOrPrivateDiningRoom?: File, dinnerNone?: File, breakfastVenueMeal?: File, breakfastPrivateRoomDining?: File, breakfastRoomMeal?: File, breakfastVenueMealOorPrivateDiningRoom?: File, breakfastVenueMealOrRoomService?: File, breakfastRoomOrPrivateDiningRoom?: File, breakfastNone?: File, issueDataImage?: File, consumptionTax?: string, tax?: number, pageMountId?: number, options?: any): AxiosPromise<ProjectWithXlsFilesResponseDto> {
            return localVarFp.projectControllerProjectSetting(id, salesStartDate, salesEndDate, reviewRatingStartDate, reviewRatingEndDate, bookletEnables, thumbIndexId, headLineId, openAirIconOn, openAirIconOff, freeFlowingIconOn, freeFlowingIconOff, elevatorIconOn, elevatorIconOff, sameDayReservationIconOn, sameDayReservationIconOff, pickUpAvailableIconOn, pickUpAvailableIconOff, noSmokingIconOn, noSmokingIconOff, dinnerVenueMeal, dinnerPrivateRoomDining, dinnerRoomMeal, dinnerVenueMealOorPrivateDiningRoom, dinnerVenueMealOrRoomService, dinnerRoomOrPrivateDiningRoom, dinnerNone, breakfastVenueMeal, breakfastPrivateRoomDining, breakfastRoomMeal, breakfastVenueMealOorPrivateDiningRoom, breakfastVenueMealOrRoomService, breakfastRoomOrPrivateDiningRoom, breakfastNone, issueDataImage, consumptionTax, tax, pageMountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary プロジェクト年月の更新
         * @param {ProjectIssueDto} projectIssueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectControllerUpdate(projectIssueDto: ProjectIssueDto, options?: any): AxiosPromise<ProjectResponseDto> {
            return localVarFp.projectControllerUpdate(projectIssueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @summary プロジェクト作成
     * @param {CreateProjectWithEditionCodeDto} createProjectWithEditionCodeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerCreate(createProjectWithEditionCodeDto: CreateProjectWithEditionCodeDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerCreate(createProjectWithEditionCodeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロジェクトの削除
     * @param {number} id プロジェクトid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerDelete(id: number, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロジェクト取得
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerDetails(id: number, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerDetails(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 複製プロジェクト
     * @param {DuplicateProjectDto} duplicateProjectDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerDuplicate(duplicateProjectDto: DuplicateProjectDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerDuplicate(duplicateProjectDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerGetIssueProject(options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerGetIssueProject(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロジェクト一覧取得
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerList(take?: number, skip?: number, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerList(take, skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロジェクト設定更新
     * @param {number} id プロジェクトid
     * @param {string} salesStartDate 販売開始日
     * @param {string} salesEndDate 販売終了日
     * @param {string} reviewRatingStartDate 口コミ評価開始日
     * @param {string} reviewRatingEndDate 口コミ評価終了日
     * @param {Array<string>} bookletEnables 有効にする版コードを配列で登録するKANTO,TOHOKUなどをカンマ区切りで送る
     * @param {number} [thumbIndexId] ツメ見出しid
     * @param {number} [headLineId] 見出しid
     * @param {File} [openAirIconOn] 露天アイコンOn
     * @param {File} [openAirIconOff] 露天アイコンOff
     * @param {File} [freeFlowingIconOn] かけ流しアイコンOn
     * @param {File} [freeFlowingIconOff] かけ流しアイコンOff
     * @param {File} [elevatorIconOn] エレベーターアイコンOn
     * @param {File} [elevatorIconOff] エレベーターアイコンOff
     * @param {File} [sameDayReservationIconOn] 当日予約アイコンOn
     * @param {File} [sameDayReservationIconOff] 当日予約アイコンOff
     * @param {File} [pickUpAvailableIconOn] 送迎有アイコンOn
     * @param {File} [pickUpAvailableIconOff] 送迎有アイコンOff
     * @param {File} [noSmokingIconOn] 禁煙アイコンOn
     * @param {File} [noSmokingIconOff] 禁煙アイコンOff
     * @param {File} [dinnerVenueMeal] 夕食:会場食
     * @param {File} [dinnerPrivateRoomDining] 夕食:個室会場食
     * @param {File} [dinnerRoomMeal] 夕食:部屋食
     * @param {File} [dinnerVenueMealOorPrivateDiningRoom] 夕食:会場食または個室会場食
     * @param {File} [dinnerVenueMealOrRoomService] 夕食:会場食または部屋食
     * @param {File} [dinnerRoomOrPrivateDiningRoom] 夕食:部屋食または個室会場食
     * @param {File} [dinnerNone] 夕食:なし
     * @param {File} [breakfastVenueMeal] 朝食:会場食
     * @param {File} [breakfastPrivateRoomDining] 朝食:個室会場食
     * @param {File} [breakfastRoomMeal] 朝食:部屋食
     * @param {File} [breakfastVenueMealOorPrivateDiningRoom] 朝食:会場食または個室会場食
     * @param {File} [breakfastVenueMealOrRoomService] 朝食:会場食または部屋食
     * @param {File} [breakfastRoomOrPrivateDiningRoom] 朝食:部屋食または個室会場食
     * @param {File} [breakfastNone] 朝食:なし
     * @param {File} [issueDataImage] 月号データ
     * @param {string} [consumptionTax] consumption tax
     * @param {number} [tax] 税率
     * @param {number} [pageMountId] 欄外下画像id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerProjectSetting(id: number, salesStartDate: string, salesEndDate: string, reviewRatingStartDate: string, reviewRatingEndDate: string, bookletEnables: Array<string>, thumbIndexId?: number, headLineId?: number, openAirIconOn?: File, openAirIconOff?: File, freeFlowingIconOn?: File, freeFlowingIconOff?: File, elevatorIconOn?: File, elevatorIconOff?: File, sameDayReservationIconOn?: File, sameDayReservationIconOff?: File, pickUpAvailableIconOn?: File, pickUpAvailableIconOff?: File, noSmokingIconOn?: File, noSmokingIconOff?: File, dinnerVenueMeal?: File, dinnerPrivateRoomDining?: File, dinnerRoomMeal?: File, dinnerVenueMealOorPrivateDiningRoom?: File, dinnerVenueMealOrRoomService?: File, dinnerRoomOrPrivateDiningRoom?: File, dinnerNone?: File, breakfastVenueMeal?: File, breakfastPrivateRoomDining?: File, breakfastRoomMeal?: File, breakfastVenueMealOorPrivateDiningRoom?: File, breakfastVenueMealOrRoomService?: File, breakfastRoomOrPrivateDiningRoom?: File, breakfastNone?: File, issueDataImage?: File, consumptionTax?: string, tax?: number, pageMountId?: number, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerProjectSetting(id, salesStartDate, salesEndDate, reviewRatingStartDate, reviewRatingEndDate, bookletEnables, thumbIndexId, headLineId, openAirIconOn, openAirIconOff, freeFlowingIconOn, freeFlowingIconOff, elevatorIconOn, elevatorIconOff, sameDayReservationIconOn, sameDayReservationIconOff, pickUpAvailableIconOn, pickUpAvailableIconOff, noSmokingIconOn, noSmokingIconOff, dinnerVenueMeal, dinnerPrivateRoomDining, dinnerRoomMeal, dinnerVenueMealOorPrivateDiningRoom, dinnerVenueMealOrRoomService, dinnerRoomOrPrivateDiningRoom, dinnerNone, breakfastVenueMeal, breakfastPrivateRoomDining, breakfastRoomMeal, breakfastVenueMealOorPrivateDiningRoom, breakfastVenueMealOrRoomService, breakfastRoomOrPrivateDiningRoom, breakfastNone, issueDataImage, consumptionTax, tax, pageMountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary プロジェクト年月の更新
     * @param {ProjectIssueDto} projectIssueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectControllerUpdate(projectIssueDto: ProjectIssueDto, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectControllerUpdate(projectIssueDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReviewSummaryApi - axios parameter creator
 * @export
 */
export const ReviewSummaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSummaryControllerGetListReview: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/review-summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {number} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSummaryControllerGetReviewByDocument: async (documentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('reviewSummaryControllerGetReviewByDocument', 'documentId', documentId)
            const localVarPath = `/v1/review-summary/{documentId}`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReviewSummaryApi - functional programming interface
 * @export
 */
export const ReviewSummaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReviewSummaryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewSummaryControllerGetListReview(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewSummaryControllerGetListReview(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 
         * @param {number} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewSummaryControllerGetReviewByDocument(documentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewSummaryControllerGetReviewByDocument(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReviewSummaryApi - factory interface
 * @export
 */
export const ReviewSummaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReviewSummaryApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSummaryControllerGetListReview(options?: any): AxiosPromise<void> {
            return localVarFp.reviewSummaryControllerGetListReview(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {number} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewSummaryControllerGetReviewByDocument(documentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.reviewSummaryControllerGetReviewByDocument(documentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReviewSummaryApi - object-oriented interface
 * @export
 * @class ReviewSummaryApi
 * @extends {BaseAPI}
 */
export class ReviewSummaryApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewSummaryApi
     */
    public reviewSummaryControllerGetListReview(options?: AxiosRequestConfig) {
        return ReviewSummaryApiFp(this.configuration).reviewSummaryControllerGetListReview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {number} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReviewSummaryApi
     */
    public reviewSummaryControllerGetReviewByDocument(documentId: number, options?: AxiosRequestConfig) {
        return ReviewSummaryApiFp(this.configuration).reviewSummaryControllerGetReviewByDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 原稿関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerDocumentSetting: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary ページ関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerPagesSetting: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 検索関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerSearchParams: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/search-params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 原稿関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingControllerDocumentSetting(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSettingsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingControllerDocumentSetting(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary ページ関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingControllerPagesSetting(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageSettingsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingControllerPagesSetting(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 検索関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingControllerSearchParams(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchParamsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingControllerSearchParams(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary 原稿関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerDocumentSetting(options?: any): AxiosPromise<DocumentSettingsDto> {
            return localVarFp.settingControllerDocumentSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary ページ関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerPagesSetting(options?: any): AxiosPromise<PageSettingsDto> {
            return localVarFp.settingControllerPagesSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 検索関連のマスタ情報を取得
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingControllerSearchParams(options?: any): AxiosPromise<SearchParamsDto> {
            return localVarFp.settingControllerSearchParams(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @summary 原稿関連のマスタ情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingControllerDocumentSetting(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingControllerDocumentSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary ページ関連のマスタ情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingControllerPagesSetting(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingControllerPagesSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 検索関連のマスタ情報を取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingControllerSearchParams(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingControllerSearchParams(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThumbIndexApi - axios parameter creator
 * @export
 */
export const ThumbIndexApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary つめ見出し作成
         * @param {string} name name
         * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番に変換ファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerCreate: async (name: string, thumbIndexMediaTypes?: Array<string>, thumbIndexByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('thumbIndexControllerCreate', 'name', name)
            const localVarPath = `/v1/thumb-index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
                if (thumbIndexMediaTypes) {
                localVarFormParams.append('thumbIndexMediaTypes', thumbIndexMediaTypes.join(COLLECTION_FORMATS.csv));
            }

                if (thumbIndexByEditionCodes) {
                localVarFormParams.append('thumbIndexByEditionCodes', thumbIndexByEditionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

                if (codes) {
                localVarFormParams.append('codes', codes.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary つめ見出し削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thumbIndexControllerDelete', 'id', id)
            const localVarPath = `/v1/thumb-index/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary つめ見出し画像削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerDeleteImage: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thumbIndexControllerDeleteImage', 'id', id)
            const localVarPath = `/v1/thumb-index/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary つめ見出し詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerDetails: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thumbIndexControllerDetails', 'id', id)
            const localVarPath = `/v1/thumb-index/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary つめ見出し一覧
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerList: async (take?: number, skip?: number, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/thumb-index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary つめ見出し更新
         * @param {number} id id
         * @param {string} [name] name
         * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerUpdate: async (id: number, name?: string, thumbIndexMediaTypes?: Array<string>, imageIds?: Array<number>, thumbIndexByEditionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thumbIndexControllerUpdate', 'id', id)
            const localVarPath = `/v1/thumb-index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
                if (thumbIndexMediaTypes) {
                localVarFormParams.append('thumbIndexMediaTypes', thumbIndexMediaTypes.join(COLLECTION_FORMATS.csv));
            }

                if (imageIds) {
                localVarFormParams.append('imageIds', imageIds.join(COLLECTION_FORMATS.csv));
            }

                if (thumbIndexByEditionCodes) {
                localVarFormParams.append('thumbIndexByEditionCodes', thumbIndexByEditionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (deleteEditionCodes) {
                localVarFormParams.append('deleteEditionCodes', deleteEditionCodes.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

                if (codes) {
                localVarFormParams.append('codes', codes.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary つめ見出しの版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} thumbIndexId thumbIndexId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerUpdateEditionByCode: async (editionCode: string, thumbIndexId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'editionCode' is not null or undefined
            assertParamExists('thumbIndexControllerUpdateEditionByCode', 'editionCode', editionCode)
            // verify required parameter 'thumbIndexId' is not null or undefined
            assertParamExists('thumbIndexControllerUpdateEditionByCode', 'thumbIndexId', thumbIndexId)
            const localVarPath = `/v1/thumb-index/edition-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (editionCode !== undefined) { 
                localVarFormParams.append('editionCode', editionCode as any);
            }
                if (imageIds) {
                localVarFormParams.append('imageIds', imageIds.join(COLLECTION_FORMATS.csv));
            }

                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

                if (imageConverts) {
                imageConverts.forEach((element) => {
                    localVarFormParams.append('imageConverts', element as any);
                })
            }

                if (codes) {
                localVarFormParams.append('codes', codes.join(COLLECTION_FORMATS.csv));
            }

    
            if (thumbIndexId !== undefined) { 
                localVarFormParams.append('thumbIndexId', thumbIndexId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary つめ見出し画像コードアップデート
         * @param {ImageCodePublicDto} imageCodePublicDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerUpdateImageCode: async (imageCodePublicDto: ImageCodePublicDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageCodePublicDto' is not null or undefined
            assertParamExists('thumbIndexControllerUpdateImageCode', 'imageCodePublicDto', imageCodePublicDto)
            const localVarPath = `/v1/thumb-index/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imageCodePublicDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThumbIndexApi - functional programming interface
 * @export
 */
export const ThumbIndexApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThumbIndexApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary つめ見出し作成
         * @param {string} name name
         * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番に変換ファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerCreate(name: string, thumbIndexMediaTypes?: Array<string>, thumbIndexByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerCreate(name, thumbIndexMediaTypes, thumbIndexByEditionCodes, images, imageConverts, codes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary つめ見出し削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary つめ見出し画像削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerDeleteImage(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerDeleteImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary つめ見出し詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerDetails(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerDetails(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary つめ見出し一覧
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexWithCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerList(take, skip, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary つめ見出し更新
         * @param {number} id id
         * @param {string} [name] name
         * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerUpdate(id: number, name?: string, thumbIndexMediaTypes?: Array<string>, imageIds?: Array<number>, thumbIndexByEditionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerUpdate(id, name, thumbIndexMediaTypes, imageIds, thumbIndexByEditionCodes, deleteEditionCodes, images, imageConverts, codes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary つめ見出しの版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} thumbIndexId thumbIndexId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerUpdateEditionByCode(editionCode: string, thumbIndexId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerUpdateEditionByCode(editionCode, thumbIndexId, imageIds, images, imageConverts, codes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary つめ見出し画像コードアップデート
         * @param {ImageCodePublicDto} imageCodePublicDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thumbIndexControllerUpdateImageCode(imageCodePublicDto: ImageCodePublicDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThumbIndexImageResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thumbIndexControllerUpdateImageCode(imageCodePublicDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ThumbIndexApi - factory interface
 * @export
 */
export const ThumbIndexApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThumbIndexApiFp(configuration)
    return {
        /**
         * 
         * @summary つめ見出し作成
         * @param {string} name name
         * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<File>} [imageConverts] 上記で指定した順番に変換ファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerCreate(name: string, thumbIndexMediaTypes?: Array<string>, thumbIndexByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: any): AxiosPromise<ThumbIndexResponseDto> {
            return localVarFp.thumbIndexControllerCreate(name, thumbIndexMediaTypes, thumbIndexByEditionCodes, images, imageConverts, codes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary つめ見出し削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerDelete(id: number, options?: any): AxiosPromise<ThumbIndexResponseDto> {
            return localVarFp.thumbIndexControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary つめ見出し画像削除
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerDeleteImage(id: number, options?: any): AxiosPromise<ThumbIndexImageResponseDto> {
            return localVarFp.thumbIndexControllerDeleteImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary つめ見出し詳細
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerDetails(id: number, options?: any): AxiosPromise<ThumbIndexResponseDto> {
            return localVarFp.thumbIndexControllerDetails(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary つめ見出し一覧
         * @param {number} [take] 取得件数
         * @param {number} [skip] スキップ値
         * @param {string} [name] name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerList(take?: number, skip?: number, name?: string, options?: any): AxiosPromise<ThumbIndexWithCountResponse> {
            return localVarFp.thumbIndexControllerList(take, skip, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary つめ見出し更新
         * @param {number} id id
         * @param {string} [name] name
         * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
         * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerUpdate(id: number, name?: string, thumbIndexMediaTypes?: Array<string>, imageIds?: Array<number>, thumbIndexByEditionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: any): AxiosPromise<ThumbIndexResponseDto> {
            return localVarFp.thumbIndexControllerUpdate(id, name, thumbIndexMediaTypes, imageIds, thumbIndexByEditionCodes, deleteEditionCodes, images, imageConverts, codes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary つめ見出しの版&画像登録
         * @param {string} editionCode 画像ファイルを登録する版コードを指定する
         * @param {number} thumbIndexId thumbIndexId
         * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
         * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
         * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerUpdateEditionByCode(editionCode: string, thumbIndexId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: any): AxiosPromise<ThumbIndexResponseDto> {
            return localVarFp.thumbIndexControllerUpdateEditionByCode(editionCode, thumbIndexId, imageIds, images, imageConverts, codes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary つめ見出し画像コードアップデート
         * @param {ImageCodePublicDto} imageCodePublicDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thumbIndexControllerUpdateImageCode(imageCodePublicDto: ImageCodePublicDto, options?: any): AxiosPromise<ThumbIndexImageResponseDto> {
            return localVarFp.thumbIndexControllerUpdateImageCode(imageCodePublicDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThumbIndexApi - object-oriented interface
 * @export
 * @class ThumbIndexApi
 * @extends {BaseAPI}
 */
export class ThumbIndexApi extends BaseAPI {
    /**
     * 
     * @summary つめ見出し作成
     * @param {string} name name
     * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
     * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
     * @param {Array<File>} [imageConverts] 上記で指定した順番に変換ファイルを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル] といった具合
     * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerCreate(name: string, thumbIndexMediaTypes?: Array<string>, thumbIndexByEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerCreate(name, thumbIndexMediaTypes, thumbIndexByEditionCodes, images, imageConverts, codes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary つめ見出し削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerDelete(id: number, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary つめ見出し画像削除
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerDeleteImage(id: number, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerDeleteImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary つめ見出し詳細
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerDetails(id: number, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerDetails(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary つめ見出し一覧
     * @param {number} [take] 取得件数
     * @param {number} [skip] スキップ値
     * @param {string} [name] name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerList(take?: number, skip?: number, name?: string, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerList(take, skip, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary つめ見出し更新
     * @param {number} id id
     * @param {string} [name] name
     * @param {Array<string>} [thumbIndexMediaTypes] 登録する媒体コードをMAGAZINE,PREMIUMなどをカンマ区切りで送る。
     * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
     * @param {Array<string>} [thumbIndexByEditionCodes] 画像ファイルを登録する版コードをKANTO,TOHOKUなどをカンマ区切りで送る。
     * @param {Array<string>} [deleteEditionCodes] 削除する版コードをKANTO,TOHOKUなどをarrayで送る&lt;br /&gt;更新時に作成の方に入っていた場合は無視される
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;     HOKKAIDO,KANTOならば[北海道のファイル,関東のファイル]といった具合&lt;br/&gt;     ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する&lt;br/&gt;HOKKAIDO,KANTOならば[北海道のコード,関東のコード] といった具合
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerUpdate(id: number, name?: string, thumbIndexMediaTypes?: Array<string>, imageIds?: Array<number>, thumbIndexByEditionCodes?: Array<string>, deleteEditionCodes?: Array<string>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerUpdate(id, name, thumbIndexMediaTypes, imageIds, thumbIndexByEditionCodes, deleteEditionCodes, images, imageConverts, codes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary つめ見出しの版&画像登録
     * @param {string} editionCode 画像ファイルを登録する版コードを指定する
     * @param {number} thumbIndexId thumbIndexId
     * @param {Array<number>} [imageIds] 画像id配列(変更の場合は数字を入力、新規登録の場合はnullを登録)
     * @param {Array<File>} [images] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<File>} [imageConverts] 上記で指定した順番にファイルを追加する&lt;br/&gt;       ファイルを更新しない場合は\\\&quot;empty\\\&quot;というファイル名を作成して登録
     * @param {Array<string>} [codes] 上記で指定した順番にコードを追加する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerUpdateEditionByCode(editionCode: string, thumbIndexId: number, imageIds?: Array<number>, images?: Array<File>, imageConverts?: Array<File>, codes?: Array<string>, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerUpdateEditionByCode(editionCode, thumbIndexId, imageIds, images, imageConverts, codes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary つめ見出し画像コードアップデート
     * @param {ImageCodePublicDto} imageCodePublicDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThumbIndexApi
     */
    public thumbIndexControllerUpdateImageCode(imageCodePublicDto: ImageCodePublicDto, options?: AxiosRequestConfig) {
        return ThumbIndexApiFp(this.configuration).thumbIndexControllerUpdateImageCode(imageCodePublicDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * YukodbTestApi - axios parameter creator
 * @export
 */
export const YukodbTestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 
         * @param {string} path 
         * @param {string} method 
         * @param {BodyRequesDto} bodyRequesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yukodbTestControllerGetYukoApi: async (path: string, method: string, bodyRequesDto: BodyRequesDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('yukodbTestControllerGetYukoApi', 'path', path)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('yukodbTestControllerGetYukoApi', 'method', method)
            // verify required parameter 'bodyRequesDto' is not null or undefined
            assertParamExists('yukodbTestControllerGetYukoApi', 'bodyRequesDto', bodyRequesDto)
            const localVarPath = `/v1/yukodb-test/{path}/{method}`
                .replace(`{${"path"}}`, encodeURIComponent(String(path)))
                .replace(`{${"method"}}`, encodeURIComponent(String(method)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyRequesDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * YukodbTestApi - functional programming interface
 * @export
 */
export const YukodbTestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = YukodbTestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {string} path 
         * @param {string} method 
         * @param {BodyRequesDto} bodyRequesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async yukodbTestControllerGetYukoApi(path: string, method: string, bodyRequesDto: BodyRequesDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.yukodbTestControllerGetYukoApi(path, method, bodyRequesDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * YukodbTestApi - factory interface
 * @export
 */
export const YukodbTestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = YukodbTestApiFp(configuration)
    return {
        /**
         * 
         * @summary 
         * @param {string} path 
         * @param {string} method 
         * @param {BodyRequesDto} bodyRequesDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        yukodbTestControllerGetYukoApi(path: string, method: string, bodyRequesDto: BodyRequesDto, options?: any): AxiosPromise<void> {
            return localVarFp.yukodbTestControllerGetYukoApi(path, method, bodyRequesDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * YukodbTestApi - object-oriented interface
 * @export
 * @class YukodbTestApi
 * @extends {BaseAPI}
 */
export class YukodbTestApi extends BaseAPI {
    /**
     * 
     * @summary 
     * @param {string} path 
     * @param {string} method 
     * @param {BodyRequesDto} bodyRequesDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof YukodbTestApi
     */
    public yukodbTestControllerGetYukoApi(path: string, method: string, bodyRequesDto: BodyRequesDto, options?: AxiosRequestConfig) {
        return YukodbTestApiFp(this.configuration).yukodbTestControllerGetYukoApi(path, method, bodyRequesDto, options).then((request) => request(this.axios, this.basePath));
    }
}


